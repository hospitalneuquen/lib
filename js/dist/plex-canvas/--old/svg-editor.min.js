(function(b)
{
    b.hotkeys = {
        version: "0.8", specialKeys: {
                8: "backspace", 9: "tab", 13: "return", 16: "shift", 17: "ctrl", 18: "alt", 19: "pause", 20: "capslock", 27: "esc", 32: "space", 33: "pageup", 34: "pagedown", 35: "end", 36: "home", 37: "left", 38: "up", 39: "right", 40: "down", 45: "insert", 46: "del", 96: "0", 97: "1", 98: "2", 99: "3", 100: "4", 101: "5", 102: "6", 103: "7", 104: "8", 105: "9", 106: "*", 107: "+", 109: "-", 110: ".", 111: "/", 112: "f1", 113: "f2", 114: "f3", 115: "f4", 116: "f5", 117: "f6", 118: "f7", 119: "f8", 120: "f9", 121: "f10", 122: "f11", 123: "f12", 144: "numlock", 145: "scroll", 191: "/", 224: "meta", 219: "[", 221: "]"
            }, shiftNums: {
                "`": "~", "1": "!", "2": "@", "3": "#", "4": "$", "5": "%", "6": "^", "7": "&", "8": "*", "9": "(", "0": ")", "-": "_", "=": "+", ";": ": ", "'": '"', ",": "<", ".": ">", "/": "?", "\\": "|"
            }
    };
    function a(d)
    {
        if (typeof d.data !== "string")
        {
            return
        }
        var c = d.handler,
            e = d.data.toLowerCase().split(" ");
        d.handler = function(n)
        {
            if (this !== n.target && (/textarea|select/i.test(n.target.nodeName) || n.target.type === "text"))
            {
                return
            }
            var h = n.type !== "keypress" && b.hotkeys.specialKeys[n.which],
                o = String.fromCharCode(n.which).toLowerCase(),
                k,
                m = "",
                g = {};
            if (n.altKey && h !== "alt")
            {
                m += "alt+"
            }
            if (n.ctrlKey && h !== "ctrl")
            {
                m += "ctrl+"
            }
            if (n.metaKey && !n.ctrlKey && h !== "meta")
            {
                m += "meta+"
            }
            if (n.shiftKey && h !== "shift")
            {
                m += "shift+"
            }
            if (h)
            {
                g[m + h] = true
            }
            else
            {
                g[m + o] = true;
                g[m + b.hotkeys.shiftNums[o]] = true;
                if (m === "shift+")
                {
                    g[b.hotkeys.shiftNums[o]] = true
                }
            }
            for (var j = 0, f = e.length; j < f; j++)
            {
                if (g[e[j]])
                {
                    return c.apply(this, arguments)
                }
            }
        }
    }
    b.each(["keydown", "keyup", "keypress"], function()
    {
        b.event.special[this] = {add: a}
    })
})(jQuery);
(function($, p)
{
    var i,
        m = Array.prototype.slice,
        r = decodeURIComponent,
        a = $.param,
        c,
        l,
        v,
        b = $.bbq = $.bbq || {},
        q,
        u,
        j,
        e = $.event.special,
        d = "hashchange",
        A = "querystring",
        D = "fragment",
        y = "elemUrlAttr",
        g = "location",
        k = "href",
        t = "src",
        x = /^.*\?|#.*$/g,
        w = /^.*\#/,
        h,
        C = {};
    function E(F)
    {
        return typeof F === "string"
    }
    function B(G)
    {
        var F = m.call(arguments, 1);
        return function()
            {
                return G.apply(this, F.concat(m.call(arguments)))
            }
    }
    function n(F)
    {
        return F.replace(/^[^#]*#?(.*)$/, "$1")
    }
    function o(F)
    {
        return F.replace(/(?:^[^?#]*\?([^#]*).*$)?.*/, "$1")
    }
    function f(H, M, F, I, G)
    {
        var O,
            L,
            K,
            N,
            J;
        if (I !== i)
        {
            K = F.match(H ? /^([^#]*)\#?(.*)$/ : /^([^#?]*)\??([^#]*)(#?.*)/);
            J = K[3] || "";
            if (G === 2 && E(I))
            {
                L = I.replace(H ? w : x, "")
            }
            else
            {
                N = l(K[2]);
                I = E(I) ? l[H ? D : A](I) : I;
                L = G === 2 ? I : G === 1 ? $.extend({}, I, N) : $.extend({}, N, I);
                L = a(L);
                if (H)
                {
                    L = L.replace(h, r)
                }
            }
            O = K[1] + (H ? "#" : L || !K[1] ? "?" : "") + L + J
        }
        else
        {
            O = M(F !== i ? F : p[g][k])
        }
        return O
    }
    a[A] = B(f, 0, o);
    a[D] = c = B(f, 1, n);
    c.noEscape = function(G)
    {
        G = G || "";
        var F = $.map(G.split(""), encodeURIComponent);
        h = new RegExp(F.join("|"), "g")
    };
    c.noEscape(",/");
    $.deparam = l = function(I, F)
    {
        var H = {},
            G = {
                "true": !0, "false": !1, "null": null
            };
        $.each(I.replace(/\+/g, " ").split("&"), function(L, Q)
        {
            var K = Q.split("="),
                P = r(K[0]),
                J,
                O = H,
                M = 0,
                R = P.split("]["),
                N = R.length - 1;
            if (/\[/.test(R[0]) && /\]$/.test(R[N]))
            {
                R[N] = R[N].replace(/\]$/, "");
                R = R.shift().split("[").concat(R);
                N = R.length - 1
            }
            else
            {
                N = 0
            }
            if (K.length === 2)
            {
                J = r(K[1]);
                if (F)
                {
                    J = J && !isNaN(J) ? +J : J === "undefined" ? i : G[J] !== i ? G[J] : J
                }
                if (N)
                {
                    for (; M <= N; M++)
                    {
                        P = R[M] === "" ? O.length : R[M];
                        O = O[P] = M < N ? O[P] || (R[M + 1] && isNaN(R[M + 1]) ? {} : []) : J
                    }
                }
                else
                {
                    if ($.isArray(H[P]))
                    {
                        H[P].push(J)
                    }
                    else
                    {
                        if (H[P] !== i)
                        {
                            H[P] = [H[P], J]
                        }
                        else
                        {
                            H[P] = J
                        }
                    }
                }
            }
            else
            {
                if (P)
                {
                    H[P] = F ? i : ""
                }
            }
        });
        return H
    };
    function z(H, F, G)
    {
        if (F === i || typeof F === "boolean")
        {
            G = F;
            F = a[H ? D : A]()
        }
        else
        {
            F = E(F) ? F.replace(H ? w : x, "") : F
        }
        return l(F, G)
    }
    l[A] = B(z, 0);
    l[D] = v = B(z, 1);
    $[y] || ($[y] = function(F)
    {
        return $.extend(C, F)
    })({
        a: k, base: k, iframe: t, img: t, input: t, form: "action", link: k, script: t
    });
    j = $[y];
    function s(I, G, H, F)
    {
        if (!E(H) && typeof H !== "object")
        {
            F = H;
            H = G;
            G = i
        }
        return this.each(function()
            {
                var L = $(this),
                    J = G || j()[(this.nodeName || "").toLowerCase()] || "",
                    K = J && L.attr(J) || "";
                L.attr(J, a[I](K, H, F))
            })
    }
    $.fn[A] = B(s, A);
    $.fn[D] = B(s, D);
    b.pushState = q = function(I, F)
    {
        if (E(I) && /^#/.test(I) && F === i)
        {
            F = 2
        }
        var H = I !== i,
            G = c(p[g][k], H ? I : {}, H ? F : 2);
        p[g][k] = G + (/#/.test(G) ? "" : "#")
    };
    b.getState = u = function(F, G)
    {
        return F === i || typeof F === "boolean" ? v(F) : v(G)[F]
    };
    b.removeState = function(F)
    {
        var G = {};
        if (F !== i)
        {
            G = u();
            $.each($.isArray(F) ? F : arguments, function(I, H)
            {
                delete G[H]
            })
        }
        q(G, 2)
    };
    e[d] = $.extend(e[d], {add: function(F)
        {
            var H;
            function G(J)
            {
                var I = J[D] = c();
                J.getState = function(K, L)
                {
                    return K === i || typeof K === "boolean" ? l(I, K) : l(I, L)[K]
                };
                H.apply(this, arguments)
            }
            if ($.isFunction(F))
            {
                H = F;
                return G
            }
            else
            {
                H = F.handler;
                F.handler = G
            }
        }})
})(jQuery, this);
(function($, i, b)
{
    var j,
        k = $.event.special,
        c = "location",
        d = "hashchange",
        l = "href",
        f = $.browser,
        g = document.documentMode,
        h = false,
        e = "on" + d in i && !h;
    function a(m)
    {
        m = m || i[c][l];
        return m.replace(/^[^#]*#?(.*)$/, "$1")
    }
    $[d + "Delay"] = 100;
    k[d] = $.extend(k[d], {
        setup: function()
        {
            if (e)
            {
                return false
            }
            $(j.start)
        }, teardown: function()
            {
                if (e)
                {
                    return false
                }
                $(j.stop)
            }
    });
    j = (function()
    {
        var m = {},
            r,
            n,
            o,
            q;
        function p()
        {
            o = q = function(s)
            {
                return s
            };
            if (h)
            {
                n = $('<iframe src="javascript:0"/>').hide().insertAfter("body")[0].contentWindow;
                q = function()
                {
                    return a(n.document[c][l])
                };
                o = function(u, s)
                {
                    if (u !== s)
                    {
                        var t = n.document;
                        t.open().close();
                        t[c].hash = "#" + u
                    }
                };
                o(a())
            }
        }
        m.start = function()
        {
            if (r)
            {
                return
            }
            var t = a();
            o || p();
            (function s()
            {
                var v = a(),
                    u = q(t);
                if (v !== t)
                {
                    o(t = v, u);
                    $(i).trigger(d)
                }
                else
                {
                    if (u !== t)
                    {
                        i[c][l] = i[c][l].replace(/#.*/, "") + "#" + u
                    }
                }
                r = setTimeout(s, $[d + "Delay"])
            })()
        };
        m.stop = function()
        {
            if (!n)
            {
                r && clearTimeout(r);
                r = 0
            }
        };
        return m
    })()
})(jQuery, this);
(function($)
{
    var svg_icons = {},
        fixIDs;
    $.svgIcons = function(file, opts)
    {
        var svgns = "http://www.w3.org/2000/svg",
            xlinkns = "http://www.w3.org/1999/xlink",
            icon_w = opts.w ? opts.w : 24,
            icon_h = opts.h ? opts.h : 24,
            elems,
            svgdoc,
            testImg,
            icons_made = false,
            data_loaded = false,
            load_attempts = 0,
            ua = navigator.userAgent,
            isOpera = !!window.opera,
            isSafari = (ua.indexOf('Safari/') > -1 && ua.indexOf('Chrome/') == -1),
            data_pre = 'data:image/svg+xml;charset=utf-8;base64,';
        if (opts.svgz)
        {
            var data_el = $('<object data="' + file + '" type=image/svg+xml>').appendTo('body').hide();
            try
            {
                svgdoc = data_el[0].contentDocument;
                data_el.load(getIcons);
                getIcons(0, true)
            }
            catch(err1)
            {
                useFallback()
            }
        }
        else
        {
            var parser = new DOMParser;
            $.ajax({
                url: file, dataType: 'string', success: function(data)
                    {
                        if (!data)
                        {
                            $(useFallback);
                            return
                        }
                        svgdoc = parser.parseFromString(data, "text/xml");
                        $(function()
                        {
                            getIcons('ajax')
                        })
                    }, error: function(err)
                    {
                        if (window.opera)
                        {
                            $(function()
                            {
                                useFallback()
                            })
                        }
                        else
                        {
                            if (err.responseText)
                            {
                                svgdoc = parser.parseFromString(err.responseText, "text/xml");
                                if (!svgdoc.childNodes.length)
                                {
                                    $(useFallback)
                                }
                                $(function()
                                {
                                    getIcons('ajax')
                                })
                            }
                            else
                            {
                                $(useFallback)
                            }
                        }
                    }
            })
        }
        function getIcons(evt, no_wait)
        {
            if (evt !== 'ajax')
            {
                if (data_loaded)
                    return;
                svgdoc = data_el[0].contentDocument;
                var isReady = (svgdoc && svgdoc.getElementById('svg_eof'));
                if (!isReady && !(no_wait && isReady))
                {
                    load_attempts++;
                    if (load_attempts < 50)
                    {
                        setTimeout(getIcons, 20)
                    }
                    else
                    {
                        useFallback();
                        data_loaded = true
                    }
                    return
                }
                data_loaded = true
            }
            elems = $(svgdoc.firstChild).children();
            if (!opts.no_img)
            {
                var testSrc = data_pre + 'PHN2ZyB4bWxucz0iaHR0cDovL3d3dy53My5vcmcvMjAwMC9zdmciIHdpZHRoPSIyNzUiIGhlaWdodD0iMjc1Ij48L3N2Zz4%3D';
                testImg = $(new Image).attr({
                    src: testSrc, width: 0, height: 0
                }).appendTo('body').load(function()
                {
                    makeIcons(true)
                }).error(function()
                {
                    makeIcons()
                })
            }
            else
            {
                setTimeout(function()
                {
                    if (!icons_made)
                        makeIcons()
                }, 500)
            }
        }
        var setIcon = function(target, icon, id, setID)
            {
                if (isOpera)
                    icon.css('visibility', 'hidden');
                if (opts.replace)
                {
                    if (setID)
                        icon.attr('id', id);
                    var cl = target.attr('class');
                    if (cl)
                        icon.attr('class', 'svg_icon ' + cl);
                    target.replaceWith(icon)
                }
                else
                {
                    target.append(icon)
                }
                if (isOpera)
                {
                    setTimeout(function()
                    {
                        icon.removeAttr('style')
                    }, 1)
                }
            };
        var addIcon = function(icon, id)
            {
                if (opts.id_match === undefined || opts.id_match !== false)
                {
                    setIcon(holder, icon, id, true)
                }
                svg_icons[id] = icon
            };
        function makeIcons(toImage, fallback)
        {
            if (icons_made)
                return;
            if (opts.no_img)
                toImage = false;
            var holder;
            if (toImage)
            {
                var temp_holder = $(document.createElement('div'));
                temp_holder.hide().appendTo('body')
            }
            if (fallback)
            {
                var path = opts.fallback_path ? opts.fallback_path : '';
                $.each(fallback, function(id, imgsrc)
                {
                    holder = $('#' + id);
                    var icon = $(new Image).attr({
                            'class': 'svg_icon', src: path + imgsrc, width: icon_w, height: icon_h, alt: 'icon'
                        });
                    addIcon(icon, id)
                })
            }
            else
            {
                var len = elems.length;
                for (var i = 0; i < len; i++)
                {
                    var elem = elems[i];
                    var id = elem.id;
                    if (id === 'svg_eof')
                        break;
                    holder = $('#' + id);
                    var svg = elem.getElementsByTagNameNS(svgns, 'svg')[0];
                    var svgroot = document.createElementNS(svgns, "svg");
                    svgroot.setAttributeNS(svgns, 'viewBox', [0, 0, icon_w, icon_h].join(' '));
                    var w = svg.getAttribute('width');
                    var h = svg.getAttribute('height');
                    svg.removeAttribute('width');
                    svg.removeAttribute('height');
                    var vb = svg.getAttribute('viewBox');
                    if (!vb)
                    {
                        svg.setAttribute('viewBox', [0, 0, w, h].join(' '))
                    }
                    svgroot.setAttribute('xmlns', svgns);
                    svgroot.setAttribute('width', icon_w);
                    svgroot.setAttribute('height', icon_h);
                    svgroot.setAttribute("xmlns:xlink", xlinkns);
                    svgroot.setAttribute("class", 'svg_icon');
                    if (!isOpera)
                        svg = svg.cloneNode(true);
                    svgroot.appendChild(svg);
                    if (toImage)
                    {
                        var svgcontent = isOpera ? svgroot : svgroot.cloneNode(true);
                        temp_holder.empty().append(svgroot);
                        var str = data_pre + encode64(temp_holder.html());
                        var icon = $(new Image).attr({
                                'class': 'svg_icon', src: str
                            })
                    }
                    else
                    {
                        var icon = fixIDs($(svgroot), i)
                    }
                    addIcon(icon, id)
                }
            }
            if (opts.placement)
            {
                $.each(opts.placement, function(sel, id)
                {
                    if (!svg_icons[id])
                        return;
                    $(sel).each(function(i)
                    {
                        var copy = svg_icons[id].clone();
                        if (i > 0 && !toImage)
                            copy = fixIDs(copy, i, true);
                        setIcon($(this), copy, id)
                    })
                })
            }
            if (!fallback)
            {
                if (toImage)
                    temp_holder.remove();
                if (data_el)
                    data_el.remove();
                if (testImg)
                    testImg.remove()
            }
            if (opts.resize)
                $.resizeSvgIcons(opts.resize);
            icons_made = true;
            if (opts.callback)
                opts.callback(svg_icons)
        }
        fixIDs = function(svg_el, svg_num, force)
        {
            var defs = svg_el.find('defs');
            if (!defs.length)
                return svg_el;
            if (isOpera)
            {
                var id_elems = defs.find('*').filter(function()
                    {
                        return !!this.id
                    })
            }
            else
            {
                var id_elems = defs.find('[id]')
            }
            var all_elems = svg_el[0].getElementsByTagName('*'),
                len = all_elems.length;
            id_elems.each(function(i)
            {
                var id = this.id;
                var no_dupes = ($(svgdoc).find('#' + id).length <= 1);
                if (isOpera)
                    no_dupes = false;
                var new_id = 'x' + id + svg_num + i;
                this.id = new_id;
                var old_val = 'url(#' + id + ')';
                var new_val = 'url(#' + new_id + ')';
                for (var i = 0; i < len; i++)
                {
                    var elem = all_elems[i];
                    if (elem.getAttribute('fill') === old_val)
                    {
                        elem.setAttribute('fill', new_val)
                    }
                    if (elem.getAttribute('stroke') === old_val)
                    {
                        elem.setAttribute('stroke', new_val)
                    }
                    if (elem.getAttribute('filter') === old_val)
                    {
                        elem.setAttribute('filter', new_val)
                    }
                }
            });
            return svg_el
        };
        function useFallback()
        {
            if (file.indexOf('.svgz') != -1)
            {
                var reg_file = file.replace('.svgz', '.svg');
                if (window.console)
                {
                    console.log('.svgz failed, trying with .svg')
                }
                $.svgIcons(reg_file, opts)
            }
            else if (opts.fallback)
            {
                makeIcons(false, opts.fallback)
            }
        }
        function encode64(input)
        {
            if (window.btoa)
                return window.btoa(input);
            var _keyStr = "ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=";
            var output = new Array(Math.floor((input.length + 2) / 3) * 4);
            var chr1,
                chr2,
                chr3;
            var enc1,
                enc2,
                enc3,
                enc4;
            var i = 0,
                p = 0;
            do
            {
                chr1 = input.charCodeAt(i++);
                chr2 = input.charCodeAt(i++);
                chr3 = input.charCodeAt(i++);
                enc1 = chr1 >> 2;
                enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
                enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
                enc4 = chr3 & 63;
                if (isNaN(chr2))
                {
                    enc3 = enc4 = 64
                }
                else if (isNaN(chr3))
                {
                    enc4 = 64
                }
                output[p++] = _keyStr.charAt(enc1);
                output[p++] = _keyStr.charAt(enc2);
                output[p++] = _keyStr.charAt(enc3);
                output[p++] = _keyStr.charAt(enc4)
            } while (i < input.length);
            return output.join('')
        }
    };
    $.getSvgIcon = function(id, uniqueClone)
    {
        var icon = svg_icons[id];
        if (uniqueClone && icon)
        {
            icon = fixIDs(icon, 0, true).clone(true)
        }
        return icon
    };
    $.resizeSvgIcons = function(obj)
    {
        var change_sel = !$('.svg_icon:first').length;
        $.each(obj, function(sel, size)
        {
            var arr = $.isArray(size);
            var w = arr ? size[0] : size,
                h = arr ? size[1] : size;
            if (change_sel)
            {
                sel = sel.replace(/\.svg_icon/g, 'svg')
            }
            $(sel).each(function()
            {
                this.setAttribute('width', w);
                this.setAttribute('height', h);
                if (window.opera && window.widget)
                {
                    this.parentNode.style.width = w + 'px';
                    this.parentNode.style.height = h + 'px'
                }
            })
        })
    }
})(jQuery);
(function()
{
    function r(i, z, t)
    {
        i = document.createElementNS(A.svg, i);
        if (Ba)
            for (var B in z)
                i.setAttribute(B, z[B]);
        else
            for (B in z)
            {
                var W = z[B],
                    w = i[B];
                if (w && w.constructor === "SVGLength")
                    w.baseVal.value = W;
                else
                    i.setAttribute(B, W)
            }
        t && t.appendChild(i);
        return i
    }
    var A = {
            svg: "http://www.w3.org/2000/svg", xlink: "http://www.w3.org/1999/xlink"
        };
    if (!window.console)
        window.console = new function()
        {
            this.log = function(){};
            this.dir = function(){}
        };
    $.jGraduate = {Paint: function(i)
        {
            i = i || {};
            this.alpha = isNaN(i.alpha) ? 100 : i.alpha;
            if (i.copy)
            {
                this.type = i.copy.type;
                this.alpha = i.copy.alpha;
                this.radialGradient = this.linearGradient = this.solidColor = null;
                switch (this.type)
                {
                    case"solidColor":
                        this.solidColor = i.copy.solidColor;
                        break;
                    case"linearGradient":
                        this.linearGradient = i.copy.linearGradient.cloneNode(true);
                        break;
                    case"radialGradient":
                        this.radialGradient = i.copy.radialGradient.cloneNode(true)
                }
            }
            else if (i.linearGradient)
            {
                this.type = "linearGradient";
                this.radialGradient = this.solidColor = null;
                this.linearGradient = i.linearGradient.cloneNode(true)
            }
            else if (i.radialGradient)
            {
                this.type = "radialGradient";
                this.linearGradient = this.solidColor = null;
                this.radialGradient = i.radialGradient.cloneNode(true)
            }
            else if (i.solidColor)
            {
                this.type = "solidColor";
                this.solidColor = i.solidColor
            }
            else
            {
                this.type = "none";
                this.radialGradient = this.linearGradient = this.solidColor = null
            }
        }};
    jQuery.fn.jGraduateDefaults = {
        paint: new $.jGraduate.Paint, window: {pickerTitle: "Drag markers to pick a paint"}, images: {clientPath: "images/"}, newstop: "inverse"
    };
    var Ba = navigator.userAgent.indexOf("Gecko/") >= 0;
    jQuery.fn.jGraduate = function(i)
    {
        var z = arguments;
        return this.each(function()
            {
                function t(c, a, d, h, f)
                {
                    var l = f || r("stop", {
                            "stop-color": a, "stop-opacity": d, offset: c
                        }, g);
                    if (f)
                    {
                        a = f.getAttribute("stop-color");
                        d = f.getAttribute("stop-opacity");
                        c = f.getAttribute("offset")
                    }
                    else
                        g.appendChild(l);
                    if (d === null)
                        d = 1;
                    f = r("path", {
                        d: "M-6.2,0.9c3.6-4,6.7-4.3,6.7-12.4c-0.2,7.9,3.1,8.8,6.5,12.4c3.5,3.8,2.9,9.6,0,12.3c-3.1,2.8-10.4,2.7-13.2,0C-9.6,9.9-9.4,4.4-6.2,0.9z", fill: "url(#jGraduate_trans)", transform: "translate(" + (10 + c * j) + ", 26)"
                    }, fa);
                    var X = r("path", {
                            d: "M-6.2,0.9c3.6-4,6.7-4.3,6.7-12.4c-0.2,7.9,3.1,8.8,6.5,12.4c3.5,3.8,2.9,9.6,0,12.3c-3.1,2.8-10.4,2.7-13.2,0C-9.6,9.9-9.4,4.4-6.2,0.9z", fill: a, "fill-opacity": d, transform: "translate(" + (10 + c * j) + ", 26)", stroke: "#000", "stroke-width": 1.5
                        }, fa);
                    $(X).mousedown(function(M)
                    {
                        B(this);
                        R = F;
                        N.mousemove(la).mouseup(W);
                        S = ga.offset();
                        M.preventDefault();
                        return false
                    }).data("stop", l).data("bg", f).dblclick(function()
                    {
                        $("div.jGraduate_LightBox").show();
                        for (var M = this, I = +l.getAttribute("stop-opacity") || 1, C = l.getAttribute("stop-color") || 1, Y = (parseFloat(I) * 255).toString(16); Y.length < 2; )
                            Y = "0" + Y;
                        a = C.substr(1) + Y;
                        $("#" + b + "_jGraduate_stopPicker").css({
                            left: 100, bottom: 15
                        }).jPicker({
                            window: {title: "Pick the start color and opacity for the gradient"}, images: {clientPath: o.images.clientPath}, color: {
                                    active: a, alphaSupport: true
                                }
                        }, function(Z)
                        {
                            C = Z.val("hex") ? "#" + Z.val("hex") : "none";
                            I = Z.val("a") !== null ? Z.val("a") / 256 : 1;
                            M.setAttribute("fill", C);
                            M.setAttribute("fill-opacity", I);
                            l.setAttribute("stop-color", C);
                            l.setAttribute("stop-opacity", I);
                            $("div.jGraduate_LightBox").hide();
                            $("#" + b + "_jGraduate_stopPicker").hide()
                        }, null, function()
                        {
                            $("div.jGraduate_LightBox").hide();
                            $("#" + b + "_jGraduate_stopPicker").hide()
                        })
                    });
                    $(g).find("stop").each(function()
                    {
                        var M = $(this);
                        if (+this.getAttribute("offset") > c)
                        {
                            if (!a)
                            {
                                var I = this.getAttribute("stop-color"),
                                    C = this.getAttribute("stop-opacity");
                                l.setAttribute("stop-color", I);
                                X.setAttribute("fill", I);
                                l.setAttribute("stop-opacity", C === null ? 1 : C);
                                X.setAttribute("fill-opacity", C === null ? 1 : C)
                            }
                            M.before(l);
                            return false
                        }
                    });
                    h && B(X);
                    return l
                }
                function B(c)
                {
                    F && F.setAttribute("stroke", "#000");
                    c.setAttribute("stroke", "blue");
                    F = c;
                    F.parentNode.appendChild(F)
                }
                function W()
                {
                    N.unbind("mousemove", la);
                    if (O.getAttribute("display") !== "none")
                    {
                        O.setAttribute("display", "none");
                        var c = $(F),
                            a = c.data("stop");
                        c = c.data("bg");
                        $([F, a, c]).remove()
                    }
                    R = null
                }
                function w()
                {
                    var c = T ? "rotate(" + T + "," + ha + "," + ia + ") " : "";
                    J === 1 && G === 1 ? g.removeAttribute("gradientTransform") : g.setAttribute("gradientTransform", c + "translate(" + -ha * (J - 1) + "," + -ia * (G - 1) + ") scale(" + J + "," + G + ")")
                }
                function la(c)
                {
                    var a = c.pageX - S.left;
                    c = c.pageY - S.top;
                    a = a < 10 ? 10 : a > j + 10 ? j + 10 : a;
                    var d = "translate(" + a + ", 26)";
                    if (c < -60 || c > 130)
                    {
                        O.setAttribute("display", "block");
                        O.setAttribute("transform", d)
                    }
                    else
                        O.setAttribute("display", "none");
                    R.setAttribute("transform", d);
                    $.data(R, "bg").setAttribute("transform", d);
                    $.data(R, "stop").setAttribute("offset", (a - 10) / j);
                    var h = 0;
                    $(g).find("stop").each(function()
                    {
                        var f = this.getAttribute("offset"),
                            l = $(this);
                        if (f < h)
                        {
                            l.prev().before(l);
                            D = $(g).find("stop")
                        }
                        h = f
                    })
                }
                var e = $(this),
                    o = $.extend(true, {}, jQuery.fn.jGraduateDefaults, i),
                    b = e.attr("id"),
                    s = "#" + e.attr("id") + " ";
                if (s)
                {
                    var ma = function()
                        {
                            switch (e.paint.type)
                            {
                                case"radialGradient":
                                    e.paint.linearGradient = null;
                                    break;
                                case"linearGradient":
                                    e.paint.radialGradient = null;
                                    break;
                                case"solidColor":
                                    e.paint.radialGradient = e.paint.linearGradient = null
                            }
                            $.isFunction(e.okCallback) && e.okCallback(e.paint);
                            e.hide()
                        },
                        na = function()
                        {
                            $.isFunction(e.cancelCallback) && e.cancelCallback();
                            e.hide()
                        };
                    $.extend(true, e, {
                        paint: new $.jGraduate.Paint({copy: o.paint}), okCallback: $.isFunction(z[1]) && z[1] || null, cancelCallback: $.isFunction(z[2]) && z[2] || null
                    });
                    e.position();
                    var u = null,
                        N = $(window);
                    if (e.paint.type == "none")
                        e.paint = $.jGraduate.Paint({solidColor: "ffffff"});
                    e.addClass("jGraduate_Picker");
                    e.html('<ul class="jGraduate_tabs"><li class="jGraduate_tab_color jGraduate_tab_current" data-type="col">Solid Color</li><li class="jGraduate_tab_lingrad" data-type="lg">Linear Gradient</li><li class="jGraduate_tab_radgrad" data-type="rg">Radial Gradient</li></ul><div class="jGraduate_colPick"></div><div class="jGraduate_gradPick"></div><div class="jGraduate_LightBox"></div><div id="' + b + '_jGraduate_stopPicker" class="jGraduate_stopPicker"></div>');
                    var Ca = $(s + "> .jGraduate_colPick"),
                        n = $(s + "> .jGraduate_gradPick");
                    n.html('<div id="' + b + '_jGraduate_Swatch" class="jGraduate_Swatch"><h2 class="jGraduate_Title">' + o.window.pickerTitle + '</h2><div id="' + b + '_jGraduate_GradContainer" class="jGraduate_GradContainer"></div><div id="' + b + '_jGraduate_StopSlider" class="jGraduate_StopSlider"></div></div><div class="jGraduate_Form jGraduate_Points jGraduate_lg_field"><div class="jGraduate_StopSection"><label class="jGraduate_Form_Heading">Begin Point</label><div class="jGraduate_Form_Section"><label>x:</label><input type="text" id="' + b + '_jGraduate_x1" size="3" title="Enter starting x value between 0.0 and 1.0"/><label> y:</label><input type="text" id="' + b + '_jGraduate_y1" size="3" title="Enter starting y value between 0.0 and 1.0"/></div></div><div class="jGraduate_StopSection"><label class="jGraduate_Form_Heading">End Point</label><div class="jGraduate_Form_Section"><label>x:</label><input type="text" id="' + b + '_jGraduate_x2" size="3" title="Enter ending x value between 0.0 and 1.0"/><label> y:</label><input type="text" id="' + b + '_jGraduate_y2" size="3" title="Enter ending y value between 0.0 and 1.0"/></div></div></div><div class="jGraduate_Form jGraduate_Points jGraduate_rg_field"><div class="jGraduate_StopSection"><label class="jGraduate_Form_Heading">Center Point</label><div class="jGraduate_Form_Section"><label>x:</label><input type="text" id="' + b + '_jGraduate_cx" size="3" title="Enter x value between 0.0 and 1.0"/><label> y:</label><input type="text" id="' + b + '_jGraduate_cy" size="3" title="Enter y value between 0.0 and 1.0"/></div></div><div class="jGraduate_StopSection"><label class="jGraduate_Form_Heading">Focal Point</label><div class="jGraduate_Form_Section"><label>Match center: <input type="checkbox" checked="checked" id="' + b + '_jGraduate_match_ctr"/></label><br/><label>x:</label><input type="text" id="' + b + '_jGraduate_fx" size="3" title="Enter x value between 0.0 and 1.0"/><label> y:</label><input type="text" id="' + b + '_jGraduate_fy" size="3" title="Enter y value between 0.0 and 1.0"/></div></div></div><div class="jGraduate_StopSection jGraduate_SpreadMethod"><label class="jGraduate_Form_Heading">Spread method</label><div class="jGraduate_Form_Section"><select class="jGraduate_spreadMethod"><option value=pad selected>Pad</option><option value=reflect>Reflect</option><option value=repeat>Repeat</option></select></div></div><div class="jGraduate_Form"><div class="jGraduate_Slider jGraduate_RadiusField jGraduate_rg_field"><label class="prelabel">Radius:</label><div id="' + b + '_jGraduate_Radius" class="jGraduate_SliderBar jGraduate_Radius" title="Click to set radius"><img id="' + b + '_jGraduate_RadiusArrows" class="jGraduate_RadiusArrows" src="' + o.images.clientPath + 'rangearrows2.gif"></div><label><input type="text" id="' + b + '_jGraduate_RadiusInput" size="3" value="100"/>%</label></div><div class="jGraduate_Slider jGraduate_EllipField jGraduate_rg_field"><label class="prelabel">Ellip:</label><div id="' + b + '_jGraduate_Ellip" class="jGraduate_SliderBar jGraduate_Ellip" title="Click to set Ellip"><img id="' + b + '_jGraduate_EllipArrows" class="jGraduate_EllipArrows" src="' + o.images.clientPath + 'rangearrows2.gif"></div><label><input type="text" id="' + b + '_jGraduate_EllipInput" size="3" value="0"/>%</label></div><div class="jGraduate_Slider jGraduate_AngleField jGraduate_rg_field"><label class="prelabel">Angle:</label><div id="' + b + '_jGraduate_Angle" class="jGraduate_SliderBar jGraduate_Angle" title="Click to set Angle"><img id="' + b + '_jGraduate_AngleArrows" class="jGraduate_AngleArrows" src="' + o.images.clientPath + 'rangearrows2.gif"></div><label><input type="text" id="' + b + '_jGraduate_AngleInput" size="3" value="0"/>deg</label></div><div class="jGraduate_Slider jGraduate_OpacField"><label class="prelabel">Opac:</label><div id="' + b + '_jGraduate_Opac" class="jGraduate_SliderBar jGraduate_Opac" title="Click to set Opac"><img id="' + b + '_jGraduate_OpacArrows" class="jGraduate_OpacArrows" src="' + o.images.clientPath + 'rangearrows2.gif"></div><label><input type="text" id="' + b + '_jGraduate_OpacInput" size="3" value="100"/>%</label></div></div><div class="jGraduate_OkCancel"><input type="button" id="' + b + '_jGraduate_Ok" class="jGraduate_Ok" value="OK"/><input type="button" id="' + b + '_jGraduate_Cancel" class="jGraduate_Cancel" value="Cancel"/></div>');
                    var j = 256,
                        oa = j - 0,
                        pa = j - 0,
                        p,
                        g,
                        aa,
                        q = {};
                    $(".jGraduate_SliderBar").width(145);
                    var x = $("#" + b + "_jGraduate_GradContainer")[0],
                        m = r("svg", {
                            id: b + "_jgraduate_svg", width: j, height: j, xmlns: A.svg
                        }, x);
                    p = p || e.paint.type;
                    var v = g = e.paint[p],
                        U = e.paint.alpha,
                        ba = p === "solidColor";
                    switch (p)
                    {
                        case"solidColor":
                        case"linearGradient":
                            if (!ba)
                            {
                                g.id = b + "_lg_jgraduate_grad";
                                v = g = m.appendChild(g)
                            }
                            r("radialGradient", {id: b + "_rg_jgraduate_grad"}, m);
                            if (p === "linearGradient")
                                break;
                        case"radialGradient":
                            if (!ba)
                            {
                                g.id = b + "_rg_jgraduate_grad";
                                v = g = m.appendChild(g)
                            }
                            r("linearGradient", {id: b + "_lg_jgraduate_grad"}, m)
                    }
                    if (ba)
                    {
                        v = g = $("#" + b + "_lg_jgraduate_grad")[0];
                        u = e.paint[p];
                        t(0, "#" + u, 1);
                        var K = typeof o.newstop;
                        if (K === "string")
                            switch (o.newstop)
                            {
                                case"same":
                                    t(1, "#" + u, 1);
                                    break;
                                case"inverse":
                                    K = "";
                                    for (var y = 0; y < 6; y += 2)
                                    {
                                        u.substr(y, 2);
                                        var P = (255 - parseInt(u.substr(y, 2), 16)).toString(16);
                                        if (P.length < 2)
                                            P = 0 + P;
                                        K += P
                                    }
                                    t(1, "#" + K, 1);
                                    break;
                                case"white":
                                    t(1, "#ffffff", 1);
                                    break;
                                case"black":
                                    t(1, "#000000", 1)
                            }
                        else if (K === "object")
                            t(1, o.newstop.color || "#" + u, "opac" in o.newstop ? o.newstop.opac : 1)
                    }
                    u = parseFloat(v.getAttribute("x1") || 0);
                    K = parseFloat(v.getAttribute("y1") || 0);
                    y = parseFloat(v.getAttribute("x2") || 1);
                    P = parseFloat(v.getAttribute("y2") || 0);
                    var ca = parseFloat(v.getAttribute("cx") || 0.5),
                        da = parseFloat(v.getAttribute("cy") || 0.5),
                        qa = parseFloat(v.getAttribute("fx") || ca),
                        ra = parseFloat(v.getAttribute("fy") || da);
                    aa = r("rect", {
                        id: b + "_jgraduate_rect", x: 0, y: 0, width: oa, height: pa, fill: "url(#" + b + "_jgraduate_grad)", "fill-opacity": U / 100
                    }, m);
                    var sa = $("<div/>").attr({
                            "class": "grad_coord jGraduate_lg_field", title: "Begin Stop"
                        }).text(1).css({
                            top: K * j, left: u * j
                        }).data("coord", "start").appendTo(x),
                        Da = sa.clone().text(2).css({
                            top: P * j, left: y * j
                        }).attr("title", "End stop").data("coord", "end").appendTo(x),
                        ta = $("<div/>").attr({
                            "class": "grad_coord jGraduate_rg_field", title: "Center stop"
                        }).text("C").css({
                            top: da * j, left: ca * j
                        }).data("coord", "center").appendTo(x),
                        V = ta.clone().text("F").css({
                            top: ra * j, left: qa * j, display: "none"
                        }).attr("title", "Focus point").data("coord", "focus").appendTo(x);
                    V[0].id = b + "_jGraduate_focusCoord";
                    $(s + " .grad_coord");
                    $.each(["x1", "y1", "x2", "y2", "cx", "cy", "fx", "fy"], function(c, a)
                    {
                        var d = g.getAttribute(a),
                            h = isNaN(a[1]);
                        d || (d = h ? "0.5" : a === "x2" ? "1.0" : "0.0");
                        q[a] = $("#" + b + "_jGraduate_" + a).val(d).change(function()
                        {
                            if (isNaN(parseFloat(this.value)) || this.value < 0)
                                this.value = 0;
                            else if (this.value > 1)
                                this.value = 1;
                            if (!(a[0] === "f" && !E))
                                if (h && p === "radialGradient" || !h && p === "linearGradient")
                                    g.setAttribute(a, this.value);
                            var f = h ? a[0] === "c" ? ta : V : a[1] === "1" ? sa : Da,
                                l = a.indexOf("x") >= 0 ? "left" : "top";
                            f.css(l, this.value * j)
                        }).change()
                    });
                    var D,
                        fa,
                        ga = $("#" + b + "_jGraduate_StopSlider"),
                        F,
                        H,
                        R,
                        O = r("path", {
                            d: "m9.75,-6l-19.5,19.5m0,-19.5l19.5,19.5", fill: "none", stroke: "#D00", "stroke-width": 5, display: "none"
                        }, H),
                        S,
                        J = 1,
                        G = 1,
                        T = 0,
                        ha = ca,
                        ia = da;
                    H = r("svg", {
                        width: "100%", height: 45
                    }, ga[0]);
                    x = r("pattern", {
                        width: 16, height: 16, patternUnits: "userSpaceOnUse", id: "jGraduate_trans"
                    }, H);
                    r("image", {
                        width: 16, height: 16
                    }, x).setAttributeNS(A.xlink, "xlink:href", o.images.clientPath + "map-opacity.png");
                    $(H).click(function(c)
                    {
                        S = ga.offset();
                        if (c.target.tagName !== "path")
                        {
                            var a = c.pageX - S.left - 8;
                            a = a < 10 ? 10 : a > j + 10 ? j + 10 : a;
                            t(a / j, 0, 0, true);
                            c.stopPropagation()
                        }
                    });
                    $(H).mouseover(function()
                    {
                        H.appendChild(O)
                    });
                    fa = r("g", {}, H);
                    r("line", {
                        x1: 10, y1: 15, x2: j + 10, y2: 15, "stroke-width": 2, stroke: "#000"
                    }, H);
                    var ua = n.find(".jGraduate_spreadMethod").change(function()
                        {
                            g.setAttribute("spreadMethod", $(this).val())
                        }),
                        Q = null,
                        va = function(c)
                        {
                            var a = c.pageX - ja.left,
                                d = c.pageY - ja.top;
                            a = a < 0 ? 0 : a > j ? j : a;
                            d = d < 0 ? 0 : d > j ? j : d;
                            Q.css("left", a).css("top", d);
                            a = a / oa;
                            d = d / pa;
                            var h = Q.data("coord"),
                                f = g;
                            switch (h)
                            {
                                case"start":
                                    q.x1.val(a);
                                    q.y1.val(d);
                                    f.setAttribute("x1", a);
                                    f.setAttribute("y1", d);
                                    break;
                                case"end":
                                    q.x2.val(a);
                                    q.y2.val(d);
                                    f.setAttribute("x2", a);
                                    f.setAttribute("y2", d);
                                    break;
                                case"center":
                                    q.cx.val(a);
                                    q.cy.val(d);
                                    f.setAttribute("cx", a);
                                    f.setAttribute("cy", d);
                                    ha = a;
                                    ia = d;
                                    w();
                                    break;
                                case"focus":
                                    q.fx.val(a);
                                    q.fy.val(d);
                                    f.setAttribute("fx", a);
                                    f.setAttribute("fy", d);
                                    w()
                            }
                            c.preventDefault()
                        },
                        wa = function()
                        {
                            Q = null;
                            N.unbind("mousemove", va).unbind("mouseup", wa)
                        };
                    D = g.getElementsByTagNameNS(A.svg, "stop");
                    if (k < 2)
                    {
                        for (; k < 2; )
                        {
                            g.appendChild(document.createElementNS(A.svg, "stop"));
                            ++k
                        }
                        D = g.getElementsByTagNameNS(A.svg, "stop")
                    }
                    var k = D.length;
                    for (y = 0; y < k; y++)
                        t(0, 0, 0, 0, D[y]);
                    ua.val(g.getAttribute("spreadMethod") || "pad");
                    var ja,
                        E = false;
                    aa.setAttribute("fill-opacity", U / 100);
                    $("#" + b + " div.grad_coord").mousedown(function(c)
                    {
                        c.preventDefault();
                        Q = $(this);
                        Q.offset();
                        ja = Q.parent().offset();
                        N.mousemove(va).mouseup(wa)
                    });
                    $("#" + b + "_jGraduate_Ok").bind("click", function()
                    {
                        e.paint.type = p;
                        e.paint[p] = g.cloneNode(true);
                        e.paint.solidColor = null;
                        ma()
                    });
                    $("#" + b + "_jGraduate_Cancel").bind("click", function()
                    {
                        na()
                    });
                    if (p === "radialGradient")
                        if (E)
                            V.show();
                        else
                        {
                            V.hide();
                            q.fx.val("");
                            q.fy.val("")
                        }
                    $("#" + b + "_jGraduate_match_ctr")[0].checked = !E;
                    var xa,
                        ya;
                    $("#" + b + "_jGraduate_match_ctr").change(function()
                    {
                        E = !this.checked;
                        V.toggle(E);
                        q.fx.val("");
                        q.fy.val("");
                        var c = g;
                        if (E)
                        {
                            var a = xa || 0.5,
                                d = ya || 0.5;
                            c.setAttribute("fx", a);
                            c.setAttribute("fy", d);
                            q.fx.val(a);
                            q.fy.val(d)
                        }
                        else
                        {
                            xa = c.getAttribute("fx");
                            ya = c.getAttribute("fy");
                            c.removeAttribute("fx");
                            c.removeAttribute("fy")
                        }
                    });
                    D = g.getElementsByTagNameNS(A.svg, "stop");
                    k = D.length;
                    if (k < 2)
                    {
                        for (; k < 2; )
                        {
                            g.appendChild(document.createElementNS(A.svg, "stop"));
                            ++k
                        }
                        D = g.getElementsByTagNameNS(A.svg, "stop")
                    }
                    var L;
                    U = n = 0;
                    if (p === "radialGradient")
                    {
                        m = g.gradientTransform.baseVal;
                        if (m.numberOfItems === 2)
                        {
                            k = m.getItem(0);
                            m = m.getItem(1);
                            if (k.type === 2 && m.type === 3)
                            {
                                k = m.matrix;
                                if (k.a !== 1)
                                    n = Math.round(-(1 - k.a) * 100);
                                else if (k.d !== 1)
                                    n = Math.round((1 - k.d) * 100)
                            }
                        }
                        else if (m.numberOfItems === 3)
                        {
                            x = m.getItem(0);
                            k = m.getItem(1);
                            m = m.getItem(2);
                            if (x.type === 4 && k.type === 2 && m.type === 3)
                            {
                                U = Math.round(x.angle);
                                k = m.matrix;
                                if (k.a !== 1)
                                    n = Math.round(-(1 - k.a) * 100);
                                else if (k.d !== 1)
                                    n = Math.round((1 - k.d) * 100)
                            }
                        }
                    }
                    n = {
                        radius: {
                            handle: "#" + b + "_jGraduate_RadiusArrows", input: "#" + b + "_jGraduate_RadiusInput", val: (g.getAttribute("r") || 0.5) * 100
                        }, opacity: {
                                handle: "#" + b + "_jGraduate_OpacArrows", input: "#" + b + "_jGraduate_OpacInput", val: e.paint.alpha || 100
                            }, ellip: {
                                handle: "#" + b + "_jGraduate_EllipArrows", input: "#" + b + "_jGraduate_EllipInput", val: n
                            }, angle: {
                                handle: "#" + b + "_jGraduate_AngleArrows", input: "#" + b + "_jGraduate_AngleInput", val: U
                            }
                    };
                    $.each(n, function(c, a)
                    {
                        var d = $(a.handle);
                        d.mousedown(function(h)
                        {
                            var f = d.parent();
                            L = {
                                type: c, elem: d, input: $(a.input), parent: f, offset: f.offset()
                            };
                            N.mousemove(za).mouseup(Aa);
                            h.preventDefault()
                        });
                        $(a.input).val(a.val).change(function()
                        {
                            var h = +this.value,
                                f = 0,
                                l = p === "radialGradient";
                            switch (c)
                            {
                                case"radius":
                                    l && g.setAttribute("r", h / 100);
                                    f = Math.pow(h / 100, 0.4) / 2 * 145;
                                    break;
                                case"opacity":
                                    e.paint.alpha = h;
                                    aa.setAttribute("fill-opacity", h / 100);
                                    f = h * 1.45;
                                    break;
                                case"ellip":
                                    J = G = 1;
                                    if (h === 0)
                                    {
                                        f = 72.5;
                                        break
                                    }
                                    if (h > 99.5)
                                        h = 99.5;
                                    if (h > 0)
                                        G = 1 - h / 100;
                                    else
                                        J = -(h / 100) - 1;
                                    f = 145 * ((h + 100) / 2) / 100;
                                    l && w();
                                    break;
                                case"angle":
                                    T = h;
                                    f = T / 180;
                                    f += 0.5;
                                    f *= 145;
                                    l && w()
                            }
                            if (f > 145)
                                f = 145;
                            else if (f < 0)
                                f = 0;
                            d.css({"margin-left": f - 5})
                        }).change()
                    });
                    var za = function(c)
                        {
                            var a = c.pageX - L.offset.left - parseInt(L.parent.css("border-left-width"));
                            if (a > 145)
                                a = 145;
                            if (a <= 0)
                                a = 0;
                            var d = a - 5;
                            a /= 145;
                            switch (L.type)
                            {
                                case"radius":
                                    a = Math.pow(a * 2, 2.5);
                                    if (a > 0.98 && a < 1.02)
                                        a = 1;
                                    if (a <= 0.01)
                                        a = 0.01;
                                    g.setAttribute("r", a);
                                    break;
                                case"opacity":
                                    e.paint.alpha = parseInt(a * 100);
                                    aa.setAttribute("fill-opacity", a);
                                    break;
                                case"ellip":
                                    G = J = 1;
                                    if (a < 0.5)
                                    {
                                        a /= 0.5;
                                        J = a <= 0 ? 0.01 : a
                                    }
                                    else if (a > 0.5)
                                    {
                                        a /= 0.5;
                                        a = 2 - a;
                                        G = a <= 0 ? 0.01 : a
                                    }
                                    w();
                                    a -= 1;
                                    if (G === a + 1)
                                        a = Math.abs(a);
                                    break;
                                case"angle":
                                    a -= 0.5;
                                    T = a *= 180;
                                    w();
                                    a /= 100
                            }
                            L.elem.css({"margin-left": d});
                            a = Math.round(a * 100);
                            L.input.val(a);
                            c.preventDefault()
                        },
                        Aa = function()
                        {
                            N.unbind("mousemove", za).unbind("mouseup", Aa);
                            L = null
                        };
                    for (n = (e.paint.alpha * 255 / 100).toString(16); n.length < 2; )
                        n = "0" + n;
                    n = n.split(".")[0];
                    u = e.paint.solidColor == "none" ? "" : e.paint.solidColor + n;
                    ba || (u = D[0].getAttribute("stop-color"));
                    $.extend($.fn.jPicker.defaults.window, {
                        alphaSupport: true, effects: {
                                type: "show", speed: 0
                            }
                    });
                    Ca.jPicker({
                        window: {title: o.window.pickerTitle}, images: {clientPath: o.images.clientPath}, color: {
                                active: u, alphaSupport: true
                            }
                    }, function(c)
                    {
                        e.paint.type = "solidColor";
                        e.paint.alpha = c.val("ahex") ? Math.round(c.val("a") / 255 * 100) : 100;
                        e.paint.solidColor = c.val("hex") ? c.val("hex") : "none";
                        e.paint.radialGradient = null;
                        ma()
                    }, null, function()
                    {
                        na()
                    });
                    var ka = $(s + " .jGraduate_tabs li");
                    ka.click(function()
                    {
                        ka.removeClass("jGraduate_tab_current");
                        $(this).addClass("jGraduate_tab_current");
                        $(s + " > div").hide();
                        var c = $(this).attr("data-type");
                        $(s + " .jGraduate_gradPick").show();
                        if (c === "rg" || c === "lg")
                        {
                            $(".jGraduate_" + c + "_field").show();
                            $(".jGraduate_" + (c === "lg" ? "rg" : "lg") + "_field").hide();
                            $("#" + b + "_jgraduate_rect")[0].setAttribute("fill", "url(#" + b + "_" + c + "_jgraduate_grad)");
                            p = c === "lg" ? "linearGradient" : "radialGradient";
                            $("#" + b + "_jGraduate_OpacInput").val(e.paint.alpha).change();
                            var a = $("#" + b + "_" + c + "_jgraduate_grad")[0];
                            if (g !== a)
                            {
                                var d = $(g).find("stop");
                                $(a).empty().append(d);
                                g = a;
                                a = ua.val();
                                g.setAttribute("spreadMethod", a)
                            }
                            E = c === "rg" && g.getAttribute("fx") != null && !(ca == qa && da == ra);
                            $("#" + b + "_jGraduate_focusCoord").toggle(E);
                            if (E)
                                $("#" + b + "_jGraduate_match_ctr")[0].checked = false
                        }
                        else
                        {
                            $(s + " .jGraduate_gradPick").hide();
                            $(s + " .jGraduate_colPick").show()
                        }
                    });
                    $(s + " > div").hide();
                    ka.removeClass("jGraduate_tab_current");
                    var ea;
                    switch (e.paint.type)
                    {
                        case"linearGradient":
                            ea = $(s + " .jGraduate_tab_lingrad");
                            break;
                        case"radialGradient":
                            ea = $(s + " .jGraduate_tab_radgrad");
                            break;
                        default:
                            ea = $(s + " .jGraduate_tab_color")
                    }
                    e.show();
                    setTimeout(function()
                    {
                        ea.addClass("jGraduate_tab_current").click()
                    }, 10)
                }
                else
                    alert("Container element must have an id attribute to maintain unique id strings for sub-elements.")
            })
    }
})();
$.fn.SpinButton = function(b)
{
    function f(a, c)
    {
        for (var e = a[c], d = document.body; (a = a.offsetParent) && a != d; )
            if (!$.browser.msie || a.currentStyle.position != "relative")
                e += a[c];
        return e
    }
    return this.each(function()
        {
            this.repeating = false;
            this.spinCfg = {
                min: b && !isNaN(parseFloat(b.min)) ? Number(b.min) : null, max: b && !isNaN(parseFloat(b.max)) ? Number(b.max) : null, step: b && b.step ? Number(b.step) : 1, stepfunc: b && b.stepfunc ? b.stepfunc : false, page: b && b.page ? Number(b.page) : 10, upClass: b && b.upClass ? b.upClass : "up", downClass: b && b.downClass ? b.downClass : "down", reset: b && b.reset ? b.reset : this.value, delay: b && b.delay ? Number(b.delay) : 500, interval: b && b.interval ? Number(b.interval) : 100, _btn_width: 20, _direction: null, _delay: null, _repeat: null, callback: b && b.callback ? b.callback : null
            };
            this.spinCfg.smallStep = b && b.smallStep ? b.smallStep : this.spinCfg.step / 2;
            this.adjustValue = function(a)
            {
                a = isNaN(this.value) ? this.spinCfg.reset : $.isFunction(this.spinCfg.stepfunc) ? this.spinCfg.stepfunc(this, a) : Number((Number(this.value) + Number(a)).toFixed(5));
                if (this.spinCfg.min !== null)
                    a = Math.max(a, this.spinCfg.min);
                if (this.spinCfg.max !== null)
                    a = Math.min(a, this.spinCfg.max);
                this.value = a;
                $.isFunction(this.spinCfg.callback) && this.spinCfg.callback(this)
            };
            $(this).addClass(b && b.spinClass ? b.spinClass : "spin-button").mousemove(function(a)
            {
                var c = a.pageX || a.x,
                    e = a.pageY || a.y;
                a = a.target || a.srcElement;
                var d = svgEditor.tool_scale || 1,
                    g = $(a).height() / 2;
                c = c > f(a, "offsetLeft") + a.offsetWidth * d - this.spinCfg._btn_width ? e < f(a, "offsetTop") + g * d ? 1 : -1 : 0;
                if (c !== this.spinCfg._direction)
                {
                    switch (c)
                    {
                        case 1:
                            $(this).removeClass(this.spinCfg.downClass).addClass(this.spinCfg.upClass);
                            break;
                        case-1:
                            $(this).removeClass(this.spinCfg.upClass).addClass(this.spinCfg.downClass);
                            break;
                        default:
                            $(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass)
                    }
                    this.spinCfg._direction = c
                }
            }).mouseout(function()
            {
                $(this).removeClass(this.spinCfg.upClass).removeClass(this.spinCfg.downClass);
                this.spinCfg._direction = null;
                window.clearInterval(this.spinCfg._repeat);
                window.clearTimeout(this.spinCfg._delay)
            }).mousedown(function(a)
            {
                if (a.button === 0 && this.spinCfg._direction != 0)
                {
                    var c = this,
                        e = a.shiftKey ? c.spinCfg.smallStep : c.spinCfg.step,
                        d = function()
                        {
                            c.adjustValue(c.spinCfg._direction * e)
                        };
                    d();
                    c.spinCfg._delay = window.setTimeout(function()
                    {
                        d();
                        c.spinCfg._repeat = window.setInterval(d, c.spinCfg.interval)
                    }, c.spinCfg.delay)
                }
            }).mouseup(function()
            {
                window.clearInterval(this.spinCfg._repeat);
                window.clearTimeout(this.spinCfg._delay)
            }).dblclick(function()
            {
                $.browser.msie && this.adjustValue(this.spinCfg._direction * this.spinCfg.step)
            }).keydown(function(a)
            {
                switch (a.keyCode)
                {
                    case 38:
                        this.adjustValue(this.spinCfg.step);
                        break;
                    case 40:
                        this.adjustValue(-this.spinCfg.step);
                        break;
                    case 33:
                        this.adjustValue(this.spinCfg.page);
                        break;
                    case 34:
                        this.adjustValue(-this.spinCfg.page)
                }
            }).keypress(function(a)
            {
                if (this.repeating)
                    switch (a.keyCode)
                    {
                        case 38:
                            this.adjustValue(this.spinCfg.step);
                            break;
                        case 40:
                            this.adjustValue(-this.spinCfg.step);
                            break;
                        case 33:
                            this.adjustValue(this.spinCfg.page);
                            break;
                        case 34:
                            this.adjustValue(-this.spinCfg.page)
                    }
                else
                    this.repeating = true
            }).keyup(function(a)
            {
                this.repeating = false;
                switch (a.keyCode)
                {
                    case 38:
                    case 40:
                    case 33:
                    case 34:
                    case 13:
                        this.adjustValue(0)
                }
            }).bind("mousewheel", function(a)
            {
                if (a.wheelDelta >= 120)
                    this.adjustValue(this.spinCfg.step);
                else
                    a.wheelDelta <= -120 && this.adjustValue(-this.spinCfg.step);
                a.preventDefault()
            }).change(function()
            {
                this.adjustValue(0)
            });
            this.addEventListener && this.addEventListener("DOMMouseScroll", function(a)
            {
                if (a.detail > 0)
                    this.adjustValue(-this.spinCfg.step);
                else
                    a.detail < 0 && this.adjustValue(this.spinCfg.step);
                a.preventDefault()
            }, false)
        })
};
/*!
 * jQuery UI 1.8.17
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI
 */
(function(a, b)
{
    function d(b)
    {
        return !a(b).parents().andSelf().filter(function()
            {
                return a.curCSS(this, "visibility") === "hidden" || a.expr.filters.hidden(this)
            }).length
    }
    function c(b, c)
    {
        var e = b.nodeName.toLowerCase();
        if ("area" === e)
        {
            var f = b.parentNode,
                g = f.name,
                h;
            if (!b.href || !g || f.nodeName.toLowerCase() !== "map")
                return !1;
            h = a("img[usemap=#" + g + "]")[0];
            return !!h && d(h)
        }
        return (/input|select|textarea|button|object/.test(e) ? !b.disabled : "a" == e ? b.href || c : c) && d(b)
    }
    a.ui = a.ui || {};
    a.ui.version || (a.extend(a.ui, {
        version: "1.8.17", keyCode: {
                ALT: 18, BACKSPACE: 8, CAPS_LOCK: 20, COMMA: 188, COMMAND: 91, COMMAND_LEFT: 91, COMMAND_RIGHT: 93, CONTROL: 17, DELETE: 46, DOWN: 40, END: 35, ENTER: 13, ESCAPE: 27, HOME: 36, INSERT: 45, LEFT: 37, MENU: 93, NUMPAD_ADD: 107, NUMPAD_DECIMAL: 110, NUMPAD_DIVIDE: 111, NUMPAD_ENTER: 108, NUMPAD_MULTIPLY: 106, NUMPAD_SUBTRACT: 109, PAGE_DOWN: 34, PAGE_UP: 33, PERIOD: 190, RIGHT: 39, SHIFT: 16, SPACE: 32, TAB: 9, UP: 38, WINDOWS: 91
            }
    }), a.fn.extend({
        propAttr: a.fn.prop || a.fn.attr, _focus: a.fn.focus, focus: function(b, c)
            {
                return typeof b == "number" ? this.each(function()
                    {
                        var d = this;
                        setTimeout(function()
                        {
                            a(d).focus(),
                            c && c.call(d)
                        }, b)
                    }) : this._focus.apply(this, arguments)
            }, scrollParent: function()
            {
                var b;
                a.browser.msie && /(static|relative)/.test(this.css("position")) || /absolute/.test(this.css("position")) ? b = this.parents().filter(function()
                {
                    return /(relative|absolute|fixed)/.test(a.curCSS(this, "position", 1)) && /(auto|scroll)/.test(a.curCSS(this, "overflow", 1) + a.curCSS(this, "overflow-y", 1) + a.curCSS(this, "overflow-x", 1))
                }).eq(0) : b = this.parents().filter(function()
                {
                    return /(auto|scroll)/.test(a.curCSS(this, "overflow", 1) + a.curCSS(this, "overflow-y", 1) + a.curCSS(this, "overflow-x", 1))
                }).eq(0);
                return /fixed/.test(this.css("position")) || !b.length ? a(document) : b
            }, zIndex: function(c)
            {
                if (c !== b)
                    return this.css("zIndex", c);
                if (this.length)
                {
                    var d = a(this[0]),
                        e,
                        f;
                    while (d.length && d[0] !== document)
                    {
                        e = d.css("position");
                        if (e === "absolute" || e === "relative" || e === "fixed")
                        {
                            f = parseInt(d.css("zIndex"), 10);
                            if (!isNaN(f) && f !== 0)
                                return f
                        }
                        d = d.parent()
                    }
                }
                return 0
            }, disableSelection: function()
            {
                return this.bind((a.support.selectstart ? "selectstart" : "mousedown") + ".ui-disableSelection", function(a)
                    {
                        a.preventDefault()
                    })
            }, enableSelection: function()
            {
                return this.unbind(".ui-disableSelection")
            }
    }), a.each(["Width", "Height"], function(c, d)
        {
            function h(b, c, d, f)
            {
                a.each(e, function()
                {
                    c -= parseFloat(a.curCSS(b, "padding" + this, !0)) || 0,
                    d && (c -= parseFloat(a.curCSS(b, "border" + this + "Width", !0)) || 0),
                    f && (c -= parseFloat(a.curCSS(b, "margin" + this, !0)) || 0)
                });
                return c
            }
            var e = d === "Width" ? ["Left", "Right"] : ["Top", "Bottom"],
                f = d.toLowerCase(),
                g = {
                    innerWidth: a.fn.innerWidth, innerHeight: a.fn.innerHeight, outerWidth: a.fn.outerWidth, outerHeight: a.fn.outerHeight
                };
            a.fn["inner" + d] = function(c)
            {
                if (c === b)
                    return g["inner" + d].call(this);
                return this.each(function()
                    {
                        a(this).css(f, h(this, c) + "px")
                    })
            },
            a.fn["outer" + d] = function(b, c)
            {
                if (typeof b != "number")
                    return g["outer" + d].call(this, b);
                return this.each(function()
                    {
                        a(this).css(f, h(this, b, !0, c) + "px")
                    })
            }
        }), a.extend(a.expr[":"], {
            data: function(b, c, d)
            {
                return !!a.data(b, d[3])
            }, focusable: function(b)
                {
                    return c(b, !isNaN(a.attr(b, "tabindex")))
                }, tabbable: function(b)
                {
                    var d = a.attr(b, "tabindex"),
                        e = isNaN(d);
                    return (e || d >= 0) && c(b, !e)
                }
        }), a(function()
        {
            var b = document.body,
                c = b.appendChild(c = document.createElement("div"));
            a.extend(c.style, {
                minHeight: "100px", height: "auto", padding: 0, borderWidth: 0
            }),
            a.support.minHeight = c.offsetHeight === 100,
            a.support.selectstart = "onselectstart" in c,
            b.removeChild(c).style.display = "none"
        }), a.extend(a.ui, {
            plugin: {
                add: function(b, c, d)
                {
                    var e = a.ui[b].prototype;
                    for (var f in d)
                        e.plugins[f] = e.plugins[f] || [],
                        e.plugins[f].push([c, d[f]])
                }, call: function(a, b, c)
                    {
                        var d = a.plugins[b];
                        if (!!d && !!a.element[0].parentNode)
                            for (var e = 0; e < d.length; e++)
                                a.options[d[e][0]] && d[e][1].apply(a.element, c)
                    }
            }, contains: function(a, b)
                {
                    return document.compareDocumentPosition ? a.compareDocumentPosition(b) & 16 : a !== b && a.contains(b)
                }, hasScroll: function(b, c)
                {
                    if (a(b).css("overflow") === "hidden")
                        return !1;
                    var d = c && c === "left" ? "scrollLeft" : "scrollTop",
                        e = !1;
                    if (b[d] > 0)
                        return !0;
                    b[d] = 1,
                    e = b[d] > 0,
                    b[d] = 0;
                    return e
                }, isOverAxis: function(a, b, c)
                {
                    return a > b && a < b + c
                }, isOver: function(b, c, d, e, f, g)
                {
                    return a.ui.isOverAxis(b, d, f) && a.ui.isOverAxis(c, e, g)
                }
        }))
})(jQuery);
/*!
 * jQuery UI Widget 1.8.17
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Widget
 */
(function(a, b)
{
    if (a.cleanData)
    {
        var c = a.cleanData;
        a.cleanData = function(b)
        {
            for (var d = 0, e; (e = b[d]) != null; d++)
                try
                {
                    a(e).triggerHandler("remove")
                }
                catch(f) {}
            c(b)
        }
    }
    else
    {
        var d = a.fn.remove;
        a.fn.remove = function(b, c)
        {
            return this.each(function()
                {
                    c || (!b || a.filter(b, [this]).length) && a("*", this).add([this]).each(function()
                    {
                        try
                        {
                            a(this).triggerHandler("remove")
                        }
                        catch(b) {}
                    });
                    return d.call(a(this), b, c)
                })
        }
    }
    a.widget = function(b, c, d)
    {
        var e = b.split(".")[0],
            f;
        b = b.split(".")[1],
        f = e + "-" + b,
        d || (d = c, c = a.Widget),
        a.expr[":"][f] = function(c)
        {
            return !!a.data(c, b)
        },
        a[e] = a[e] || {},
        a[e][b] = function(a, b)
        {
            arguments.length && this._createWidget(a, b)
        };
        var g = new c;
        g.options = a.extend(!0, {}, g.options),
        a[e][b].prototype = a.extend(!0, g, {
            namespace: e, widgetName: b, widgetEventPrefix: a[e][b].prototype.widgetEventPrefix || b, widgetBaseClass: f
        }, d),
        a.widget.bridge(b, a[e][b])
    },
    a.widget.bridge = function(c, d)
    {
        a.fn[c] = function(e)
        {
            var f = typeof e == "string",
                g = Array.prototype.slice.call(arguments, 1),
                h = this;
            e = !f && g.length ? a.extend.apply(null, [!0, e].concat(g)) : e;
            if (f && e.charAt(0) === "_")
                return h;
            f ? this.each(function()
            {
                var d = a.data(this, c),
                    f = d && a.isFunction(d[e]) ? d[e].apply(d, g) : d;
                if (f !== d && f !== b)
                {
                    h = f;
                    return !1
                }
            }) : this.each(function()
            {
                var b = a.data(this, c);
                b ? b.option(e || {})._init() : a.data(this, c, new d(e, this))
            });
            return h
        }
    },
    a.Widget = function(a, b)
    {
        arguments.length && this._createWidget(a, b)
    },
    a.Widget.prototype = {
        widgetName: "widget", widgetEventPrefix: "", options: {disabled: !1}, _createWidget: function(b, c)
            {
                a.data(c, this.widgetName, this),
                this.element = a(c),
                this.options = a.extend(!0, {}, this.options, this._getCreateOptions(), b);
                var d = this;
                this.element.bind("remove." + this.widgetName, function()
                {
                    d.destroy()
                }),
                this._create(),
                this._trigger("create"),
                this._init()
            }, _getCreateOptions: function()
            {
                return a.metadata && a.metadata.get(this.element[0])[this.widgetName]
            }, _create: function(){}, _init: function(){}, destroy: function()
            {
                this.element.unbind("." + this.widgetName).removeData(this.widgetName),
                this.widget().unbind("." + this.widgetName).removeAttr("aria-disabled").removeClass(this.widgetBaseClass + "-disabled " + "ui-state-disabled")
            }, widget: function()
            {
                return this.element
            }, option: function(c, d)
            {
                var e = c;
                if (arguments.length === 0)
                    return a.extend({}, this.options);
                if (typeof c == "string")
                {
                    if (d === b)
                        return this.options[c];
                    e = {},
                    e[c] = d
                }
                this._setOptions(e);
                return this
            }, _setOptions: function(b)
            {
                var c = this;
                a.each(b, function(a, b)
                {
                    c._setOption(a, b)
                });
                return this
            }, _setOption: function(a, b)
            {
                this.options[a] = b,
                a === "disabled" && this.widget()[b ? "addClass" : "removeClass"](this.widgetBaseClass + "-disabled" + " " + "ui-state-disabled").attr("aria-disabled", b);
                return this
            }, enable: function()
            {
                return this._setOption("disabled", !1)
            }, disable: function()
            {
                return this._setOption("disabled", !0)
            }, _trigger: function(b, c, d)
            {
                var e,
                    f,
                    g = this.options[b];
                d = d || {},
                c = a.Event(c),
                c.type = (b === this.widgetEventPrefix ? b : this.widgetEventPrefix + b).toLowerCase(),
                c.target = this.element[0],
                f = c.originalEvent;
                if (f)
                    for (e in f)
                        e in c || (c[e] = f[e]);
                this.element.trigger(c, d);
                return !(a.isFunction(g) && g.call(this.element[0], c, d) === !1 || c.isDefaultPrevented())
            }
    }
})(jQuery);
/*!
 * jQuery UI Mouse 1.8.17
 *
 * Copyright 2011, AUTHORS.txt (http://jqueryui.com/about)
 * Dual licensed under the MIT or GPL Version 2 licenses.
 * http://jquery.org/license
 *
 * http://docs.jquery.com/UI/Mouse
 *
 * Depends:
 *	jquery.ui.widget.js
 */
(function(a, b)
{
    var c = !1;
    a(document).mouseup(function(a)
    {
        c = !1
    }),
    a.widget("ui.mouse", {
        options: {
            cancel: ":input,option", distance: 1, delay: 0
        }, _mouseInit: function()
            {
                var b = this;
                this.element.bind("mousedown." + this.widgetName, function(a)
                {
                    return b._mouseDown(a)
                }).bind("click." + this.widgetName, function(c)
                {
                    if (!0 === a.data(c.target, b.widgetName + ".preventClickEvent"))
                    {
                        a.removeData(c.target, b.widgetName + ".preventClickEvent"),
                        c.stopImmediatePropagation();
                        return !1
                    }
                }),
                this.started = !1
            }, _mouseDestroy: function()
            {
                this.element.unbind("." + this.widgetName)
            }, _mouseDown: function(b)
            {
                if (!c)
                {
                    this._mouseStarted && this._mouseUp(b),
                    this._mouseDownEvent = b;
                    var d = this,
                        e = b.which == 1,
                        f = typeof this.options.cancel == "string" && b.target.nodeName ? a(b.target).closest(this.options.cancel).length : !1;
                    if (!e || f || !this._mouseCapture(b))
                        return !0;
                    this.mouseDelayMet = !this.options.delay,
                    this.mouseDelayMet || (this._mouseDelayTimer = setTimeout(function()
                    {
                        d.mouseDelayMet = !0
                    }, this.options.delay));
                    if (this._mouseDistanceMet(b) && this._mouseDelayMet(b))
                    {
                        this._mouseStarted = this._mouseStart(b) !== !1;
                        if (!this._mouseStarted)
                        {
                            b.preventDefault();
                            return !0
                        }
                    }
                    !0 === a.data(b.target, this.widgetName + ".preventClickEvent") && a.removeData(b.target, this.widgetName + ".preventClickEvent"),
                    this._mouseMoveDelegate = function(a)
                    {
                        return d._mouseMove(a)
                    },
                    this._mouseUpDelegate = function(a)
                    {
                        return d._mouseUp(a)
                    },
                    a(document).bind("mousemove." + this.widgetName, this._mouseMoveDelegate).bind("mouseup." + this.widgetName, this._mouseUpDelegate),
                    b.preventDefault(),
                    c = !0;
                    return !0
                }
            }, _mouseMove: function(b)
            {
                if (a.browser.msie && !(document.documentMode >= 9) && !b.button)
                    return this._mouseUp(b);
                if (this._mouseStarted)
                {
                    this._mouseDrag(b);
                    return b.preventDefault()
                }
                this._mouseDistanceMet(b) && this._mouseDelayMet(b) && (this._mouseStarted = this._mouseStart(this._mouseDownEvent, b) !== !1, this._mouseStarted ? this._mouseDrag(b) : this._mouseUp(b));
                return !this._mouseStarted
            }, _mouseUp: function(b)
            {
                a(document).unbind("mousemove." + this.widgetName, this._mouseMoveDelegate).unbind("mouseup." + this.widgetName, this._mouseUpDelegate),
                this._mouseStarted && (this._mouseStarted = !1, b.target == this._mouseDownEvent.target && a.data(b.target, this.widgetName + ".preventClickEvent", !0), this._mouseStop(b));
                return !1
            }, _mouseDistanceMet: function(a)
            {
                return Math.max(Math.abs(this._mouseDownEvent.pageX - a.pageX), Math.abs(this._mouseDownEvent.pageY - a.pageY)) >= this.options.distance
            }, _mouseDelayMet: function(a)
            {
                return this.mouseDelayMet
            }, _mouseStart: function(a){}, _mouseDrag: function(a){}, _mouseStop: function(a){}, _mouseCapture: function(a)
            {
                return !0
            }
    })
})(jQuery);
(function(a, b)
{
    a.widget("ui.draggable", a.ui.mouse, {
        widgetEventPrefix: "drag", options: {
                addClasses: !0, appendTo: "parent", axis: !1, connectToSortable: !1, containment: !1, cursor: "auto", cursorAt: !1, grid: !1, handle: !1, helper: "original", iframeFix: !1, opacity: !1, refreshPositions: !1, revert: !1, revertDuration: 500, scope: "default", scroll: !0, scrollSensitivity: 20, scrollSpeed: 20, snap: !1, snapMode: "both", snapTolerance: 20, stack: !1, zIndex: !1
            }, _create: function()
            {
                this.options.helper == "original" && !/^(?:r|a|f)/.test(this.element.css("position")) && (this.element[0].style.position = "relative"),
                this.options.addClasses && this.element.addClass("ui-draggable"),
                this.options.disabled && this.element.addClass("ui-draggable-disabled"),
                this._mouseInit()
            }, destroy: function()
            {
                if (!!this.element.data("draggable"))
                {
                    this.element.removeData("draggable").unbind(".draggable").removeClass("ui-draggable ui-draggable-dragging ui-draggable-disabled"),
                    this._mouseDestroy();
                    return this
                }
            }, _mouseCapture: function(b)
            {
                var c = this.options;
                if (this.helper || c.disabled || a(b.target).is(".ui-resizable-handle"))
                    return !1;
                this.handle = this._getHandle(b);
                if (!this.handle)
                    return !1;
                c.iframeFix && a(c.iframeFix === !0 ? "iframe" : c.iframeFix).each(function()
                {
                    a('<div class="ui-draggable-iframeFix" style="background: #fff;"></div>').css({
                        width: this.offsetWidth + "px", height: this.offsetHeight + "px", position: "absolute", opacity: "0.001", zIndex: 1e3
                    }).css(a(this).offset()).appendTo("body")
                });
                return !0
            }, _mouseStart: function(b)
            {
                var c = this.options;
                this.helper = this._createHelper(b),
                this._cacheHelperProportions(),
                a.ui.ddmanager && (a.ui.ddmanager.current = this),
                this._cacheMargins(),
                this.cssPosition = this.helper.css("position"),
                this.scrollParent = this.helper.scrollParent(),
                this.offset = this.positionAbs = this.element.offset(),
                this.offset = {
                    top: this.offset.top - this.margins.top, left: this.offset.left - this.margins.left
                },
                a.extend(this.offset, {
                    click: {
                        left: b.pageX - this.offset.left, top: b.pageY - this.offset.top
                    }, parent: this._getParentOffset(), relative: this._getRelativeOffset()
                }),
                this.originalPosition = this.position = this._generatePosition(b),
                this.originalPageX = b.pageX,
                this.originalPageY = b.pageY,
                c.cursorAt && this._adjustOffsetFromHelper(c.cursorAt),
                c.containment && this._setContainment();
                if (this._trigger("start", b) === !1)
                {
                    this._clear();
                    return !1
                }
                this._cacheHelperProportions(),
                a.ui.ddmanager && !c.dropBehaviour && a.ui.ddmanager.prepareOffsets(this, b),
                this.helper.addClass("ui-draggable-dragging"),
                this._mouseDrag(b, !0),
                a.ui.ddmanager && a.ui.ddmanager.dragStart(this, b);
                return !0
            }, _mouseDrag: function(b, c)
            {
                this.position = this._generatePosition(b),
                this.positionAbs = this._convertPositionTo("absolute");
                if (!c)
                {
                    var d = this._uiHash();
                    if (this._trigger("drag", b, d) === !1)
                    {
                        this._mouseUp({});
                        return !1
                    }
                    this.position = d.position
                }
                if (!this.options.axis || this.options.axis != "y")
                    this.helper[0].style.left = this.position.left + "px";
                if (!this.options.axis || this.options.axis != "x")
                    this.helper[0].style.top = this.position.top + "px";
                a.ui.ddmanager && a.ui.ddmanager.drag(this, b);
                return !1
            }, _mouseStop: function(b)
            {
                var c = !1;
                a.ui.ddmanager && !this.options.dropBehaviour && (c = a.ui.ddmanager.drop(this, b)),
                this.dropped && (c = this.dropped, this.dropped = !1);
                if ((!this.element[0] || !this.element[0].parentNode) && this.options.helper == "original")
                    return !1;
                if (this.options.revert == "invalid" && !c || this.options.revert == "valid" && c || this.options.revert === !0 || a.isFunction(this.options.revert) && this.options.revert.call(this.element, c))
                {
                    var d = this;
                    a(this.helper).animate(this.originalPosition, parseInt(this.options.revertDuration, 10), function()
                    {
                        d._trigger("stop", b) !== !1 && d._clear()
                    })
                }
                else
                    this._trigger("stop", b) !== !1 && this._clear();
                return !1
            }, _mouseUp: function(b)
            {
                this.options.iframeFix === !0 && a("div.ui-draggable-iframeFix").each(function()
                {
                    this.parentNode.removeChild(this)
                }),
                a.ui.ddmanager && a.ui.ddmanager.dragStop(this, b);
                return a.ui.mouse.prototype._mouseUp.call(this, b)
            }, cancel: function()
            {
                this.helper.is(".ui-draggable-dragging") ? this._mouseUp({}) : this._clear();
                return this
            }, _getHandle: function(b)
            {
                var c = !this.options.handle || !a(this.options.handle, this.element).length ? !0 : !1;
                a(this.options.handle, this.element).find("*").andSelf().each(function()
                {
                    this == b.target && (c = !0)
                });
                return c
            }, _createHelper: function(b)
            {
                var c = this.options,
                    d = a.isFunction(c.helper) ? a(c.helper.apply(this.element[0], [b])) : c.helper == "clone" ? this.element.clone().removeAttr("id") : this.element;
                d.parents("body").length || d.appendTo(c.appendTo == "parent" ? this.element[0].parentNode : c.appendTo),
                d[0] != this.element[0] && !/(fixed|absolute)/.test(d.css("position")) && d.css("position", "absolute");
                return d
            }, _adjustOffsetFromHelper: function(b)
            {
                typeof b == "string" && (b = b.split(" ")),
                a.isArray(b) && (b = {
                    left: +b[0], top: +b[1] || 0
                }),
                "left" in b && (this.offset.click.left = b.left + this.margins.left),
                "right" in b && (this.offset.click.left = this.helperProportions.width - b.right + this.margins.left),
                "top" in b && (this.offset.click.top = b.top + this.margins.top),
                "bottom" in b && (this.offset.click.top = this.helperProportions.height - b.bottom + this.margins.top)
            }, _getParentOffset: function()
            {
                this.offsetParent = this.helper.offsetParent();
                var b = this.offsetParent.offset();
                this.cssPosition == "absolute" && this.scrollParent[0] != document && a.ui.contains(this.scrollParent[0], this.offsetParent[0]) && (b.left += this.scrollParent.scrollLeft(), b.top += this.scrollParent.scrollTop());
                if (this.offsetParent[0] == document.body || this.offsetParent[0].tagName && this.offsetParent[0].tagName.toLowerCase() == "html" && a.browser.msie)
                    b = {
                        top: 0, left: 0
                    };
                return {
                        top: b.top + (parseInt(this.offsetParent.css("borderTopWidth"), 10) || 0), left: b.left + (parseInt(this.offsetParent.css("borderLeftWidth"), 10) || 0)
                    }
            }, _getRelativeOffset: function()
            {
                if (this.cssPosition == "relative")
                {
                    var a = this.element.position();
                    return {
                            top: a.top - (parseInt(this.helper.css("top"), 10) || 0) + this.scrollParent.scrollTop(), left: a.left - (parseInt(this.helper.css("left"), 10) || 0) + this.scrollParent.scrollLeft()
                        }
                }
                return {
                        top: 0, left: 0
                    }
            }, _cacheMargins: function()
            {
                this.margins = {
                    left: parseInt(this.element.css("marginLeft"), 10) || 0, top: parseInt(this.element.css("marginTop"), 10) || 0, right: parseInt(this.element.css("marginRight"), 10) || 0, bottom: parseInt(this.element.css("marginBottom"), 10) || 0
                }
            }, _cacheHelperProportions: function()
            {
                this.helperProportions = {
                    width: this.helper.outerWidth(), height: this.helper.outerHeight()
                }
            }, _setContainment: function()
            {
                var b = this.options;
                b.containment == "parent" && (b.containment = this.helper[0].parentNode);
                if (b.containment == "document" || b.containment == "window")
                    this.containment = [b.containment == "document" ? 0 : a(window).scrollLeft() - this.offset.relative.left - this.offset.parent.left, b.containment == "document" ? 0 : a(window).scrollTop() - this.offset.relative.top - this.offset.parent.top, (b.containment == "document" ? 0 : a(window).scrollLeft()) + a(b.containment == "document" ? document : window).width() - this.helperProportions.width - this.margins.left, (b.containment == "document" ? 0 : a(window).scrollTop()) + (a(b.containment == "document" ? document : window).height() || document.body.parentNode.scrollHeight) - this.helperProportions.height - this.margins.top];
                if (!/^(document|window|parent)$/.test(b.containment) && b.containment.constructor != Array)
                {
                    var c = a(b.containment),
                        d = c[0];
                    if (!d)
                        return;
                    var e = c.offset(),
                        f = a(d).css("overflow") != "hidden";
                    this.containment = [(parseInt(a(d).css("borderLeftWidth"), 10) || 0) + (parseInt(a(d).css("paddingLeft"), 10) || 0), (parseInt(a(d).css("borderTopWidth"), 10) || 0) + (parseInt(a(d).css("paddingTop"), 10) || 0), (f ? Math.max(d.scrollWidth, d.offsetWidth) : d.offsetWidth) - (parseInt(a(d).css("borderLeftWidth"), 10) || 0) - (parseInt(a(d).css("paddingRight"), 10) || 0) - this.helperProportions.width - this.margins.left - this.margins.right, (f ? Math.max(d.scrollHeight, d.offsetHeight) : d.offsetHeight) - (parseInt(a(d).css("borderTopWidth"), 10) || 0) - (parseInt(a(d).css("paddingBottom"), 10) || 0) - this.helperProportions.height - this.margins.top - this.margins.bottom],
                    this.relative_container = c
                }
                else
                    b.containment.constructor == Array && (this.containment = b.containment)
            }, _convertPositionTo: function(b, c)
            {
                c || (c = this.position);
                var d = b == "absolute" ? 1 : -1,
                    e = this.options,
                    f = this.cssPosition == "absolute" && (this.scrollParent[0] == document || !a.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                    g = /(html|body)/i.test(f[0].tagName);
                return {
                        top: c.top + this.offset.relative.top * d + this.offset.parent.top * d - (a.browser.safari && a.browser.version < 526 && this.cssPosition == "fixed" ? 0 : (this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : g ? 0 : f.scrollTop()) * d), left: c.left + this.offset.relative.left * d + this.offset.parent.left * d - (a.browser.safari && a.browser.version < 526 && this.cssPosition == "fixed" ? 0 : (this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : g ? 0 : f.scrollLeft()) * d)
                    }
            }, _generatePosition: function(b)
            {
                var c = this.options,
                    d = this.cssPosition == "absolute" && (this.scrollParent[0] == document || !a.ui.contains(this.scrollParent[0], this.offsetParent[0])) ? this.offsetParent : this.scrollParent,
                    e = /(html|body)/i.test(d[0].tagName),
                    f = b.pageX,
                    g = b.pageY;
                if (this.originalPosition)
                {
                    var h;
                    if (this.containment)
                    {
                        if (this.relative_container)
                        {
                            var i = this.relative_container.offset();
                            h = [this.containment[0] + i.left, this.containment[1] + i.top, this.containment[2] + i.left, this.containment[3] + i.top]
                        }
                        else
                            h = this.containment;
                        b.pageX - this.offset.click.left < h[0] && (f = h[0] + this.offset.click.left),
                        b.pageY - this.offset.click.top < h[1] && (g = h[1] + this.offset.click.top),
                        b.pageX - this.offset.click.left > h[2] && (f = h[2] + this.offset.click.left),
                        b.pageY - this.offset.click.top > h[3] && (g = h[3] + this.offset.click.top)
                    }
                    if (c.grid)
                    {
                        var j = c.grid[1] ? this.originalPageY + Math.round((g - this.originalPageY) / c.grid[1]) * c.grid[1] : this.originalPageY;
                        g = h ? j - this.offset.click.top < h[1] || j - this.offset.click.top > h[3] ? j - this.offset.click.top < h[1] ? j + c.grid[1] : j - c.grid[1] : j : j;
                        var k = c.grid[0] ? this.originalPageX + Math.round((f - this.originalPageX) / c.grid[0]) * c.grid[0] : this.originalPageX;
                        f = h ? k - this.offset.click.left < h[0] || k - this.offset.click.left > h[2] ? k - this.offset.click.left < h[0] ? k + c.grid[0] : k - c.grid[0] : k : k
                    }
                }
                return {
                        top: g - this.offset.click.top - this.offset.relative.top - this.offset.parent.top + (a.browser.safari && a.browser.version < 526 && this.cssPosition == "fixed" ? 0 : this.cssPosition == "fixed" ? -this.scrollParent.scrollTop() : e ? 0 : d.scrollTop()), left: f - this.offset.click.left - this.offset.relative.left - this.offset.parent.left + (a.browser.safari && a.browser.version < 526 && this.cssPosition == "fixed" ? 0 : this.cssPosition == "fixed" ? -this.scrollParent.scrollLeft() : e ? 0 : d.scrollLeft())
                    }
            }, _clear: function()
            {
                this.helper.removeClass("ui-draggable-dragging"),
                this.helper[0] != this.element[0] && !this.cancelHelperRemoval && this.helper.remove(),
                this.helper = null,
                this.cancelHelperRemoval = !1
            }, _trigger: function(b, c, d)
            {
                d = d || this._uiHash(),
                a.ui.plugin.call(this, b, [c, d]),
                b == "drag" && (this.positionAbs = this._convertPositionTo("absolute"));
                return a.Widget.prototype._trigger.call(this, b, c, d)
            }, plugins: {}, _uiHash: function(a)
            {
                return {
                        helper: this.helper, position: this.position, originalPosition: this.originalPosition, offset: this.positionAbs
                    }
            }
    }),
    a.extend(a.ui.draggable, {version: "1.8.17"}),
    a.ui.plugin.add("draggable", "connectToSortable", {
        start: function(b, c)
        {
            var d = a(this).data("draggable"),
                e = d.options,
                f = a.extend({}, c, {item: d.element});
            d.sortables = [],
            a(e.connectToSortable).each(function()
            {
                var c = a.data(this, "sortable");
                c && !c.options.disabled && (d.sortables.push({
                    instance: c, shouldRevert: c.options.revert
                }), c.refreshPositions(), c._trigger("activate", b, f))
            })
        }, stop: function(b, c)
            {
                var d = a(this).data("draggable"),
                    e = a.extend({}, c, {item: d.element});
                a.each(d.sortables, function()
                {
                    this.instance.isOver ? (this.instance.isOver = 0, d.cancelHelperRemoval = !0, this.instance.cancelHelperRemoval = !1, this.shouldRevert && (this.instance.options.revert = !0), this.instance._mouseStop(b), this.instance.options.helper = this.instance.options._helper, d.options.helper == "original" && this.instance.currentItem.css({
                            top: "auto", left: "auto"
                        })) : (this.instance.cancelHelperRemoval = !1, this.instance._trigger("deactivate", b, e))
                })
            }, drag: function(b, c)
            {
                var d = a(this).data("draggable"),
                    e = this,
                    f = function(b)
                    {
                        var c = this.offset.click.top,
                            d = this.offset.click.left,
                            e = this.positionAbs.top,
                            f = this.positionAbs.left,
                            g = b.height,
                            h = b.width,
                            i = b.top,
                            j = b.left;
                        return a.ui.isOver(e + c, f + d, i, j, g, h)
                    };
                a.each(d.sortables, function(f)
                {
                    this.instance.positionAbs = d.positionAbs,
                    this.instance.helperProportions = d.helperProportions,
                    this.instance.offset.click = d.offset.click,
                    this.instance._intersectsWith(this.instance.containerCache) ? (this.instance.isOver || (this.instance.isOver = 1, this.instance.currentItem = a(e).clone().removeAttr("id").appendTo(this.instance.element).data("sortable-item", !0), this.instance.options._helper = this.instance.options.helper, this.instance.options.helper = function()
                        {
                            return c.helper[0]
                        }, b.target = this.instance.currentItem[0], this.instance._mouseCapture(b, !0), this.instance._mouseStart(b, !0, !0), this.instance.offset.click.top = d.offset.click.top, this.instance.offset.click.left = d.offset.click.left, this.instance.offset.parent.left -= d.offset.parent.left - this.instance.offset.parent.left, this.instance.offset.parent.top -= d.offset.parent.top - this.instance.offset.parent.top, d._trigger("toSortable", b), d.dropped = this.instance.element, d.currentItem = d.element, this.instance.fromOutside = d), this.instance.currentItem && this.instance._mouseDrag(b)) : this.instance.isOver && (this.instance.isOver = 0, this.instance.cancelHelperRemoval = !0, this.instance.options.revert = !1, this.instance._trigger("out", b, this.instance._uiHash(this.instance)), this.instance._mouseStop(b, !0), this.instance.options.helper = this.instance.options._helper, this.instance.currentItem.remove(), this.instance.placeholder && this.instance.placeholder.remove(), d._trigger("fromSortable", b), d.dropped = !1)
                })
            }
    }),
    a.ui.plugin.add("draggable", "cursor", {
        start: function(b, c)
        {
            var d = a("body"),
                e = a(this).data("draggable").options;
            d.css("cursor") && (e._cursor = d.css("cursor")),
            d.css("cursor", e.cursor)
        }, stop: function(b, c)
            {
                var d = a(this).data("draggable").options;
                d._cursor && a("body").css("cursor", d._cursor)
            }
    }),
    a.ui.plugin.add("draggable", "opacity", {
        start: function(b, c)
        {
            var d = a(c.helper),
                e = a(this).data("draggable").options;
            d.css("opacity") && (e._opacity = d.css("opacity")),
            d.css("opacity", e.opacity)
        }, stop: function(b, c)
            {
                var d = a(this).data("draggable").options;
                d._opacity && a(c.helper).css("opacity", d._opacity)
            }
    }),
    a.ui.plugin.add("draggable", "scroll", {
        start: function(b, c)
        {
            var d = a(this).data("draggable");
            d.scrollParent[0] != document && d.scrollParent[0].tagName != "HTML" && (d.overflowOffset = d.scrollParent.offset())
        }, drag: function(b, c)
            {
                var d = a(this).data("draggable"),
                    e = d.options,
                    f = !1;
                if (d.scrollParent[0] != document && d.scrollParent[0].tagName != "HTML")
                {
                    if (!e.axis || e.axis != "x")
                        d.overflowOffset.top + d.scrollParent[0].offsetHeight - b.pageY < e.scrollSensitivity ? d.scrollParent[0].scrollTop = f = d.scrollParent[0].scrollTop + e.scrollSpeed : b.pageY - d.overflowOffset.top < e.scrollSensitivity && (d.scrollParent[0].scrollTop = f = d.scrollParent[0].scrollTop - e.scrollSpeed);
                    if (!e.axis || e.axis != "y")
                        d.overflowOffset.left + d.scrollParent[0].offsetWidth - b.pageX < e.scrollSensitivity ? d.scrollParent[0].scrollLeft = f = d.scrollParent[0].scrollLeft + e.scrollSpeed : b.pageX - d.overflowOffset.left < e.scrollSensitivity && (d.scrollParent[0].scrollLeft = f = d.scrollParent[0].scrollLeft - e.scrollSpeed)
                }
                else
                {
                    if (!e.axis || e.axis != "x")
                        b.pageY - a(document).scrollTop() < e.scrollSensitivity ? f = a(document).scrollTop(a(document).scrollTop() - e.scrollSpeed) : a(window).height() - (b.pageY - a(document).scrollTop()) < e.scrollSensitivity && (f = a(document).scrollTop(a(document).scrollTop() + e.scrollSpeed));
                    if (!e.axis || e.axis != "y")
                        b.pageX - a(document).scrollLeft() < e.scrollSensitivity ? f = a(document).scrollLeft(a(document).scrollLeft() - e.scrollSpeed) : a(window).width() - (b.pageX - a(document).scrollLeft()) < e.scrollSensitivity && (f = a(document).scrollLeft(a(document).scrollLeft() + e.scrollSpeed))
                }
                f !== !1 && a.ui.ddmanager && !e.dropBehaviour && a.ui.ddmanager.prepareOffsets(d, b)
            }
    }),
    a.ui.plugin.add("draggable", "snap", {
        start: function(b, c)
        {
            var d = a(this).data("draggable"),
                e = d.options;
            d.snapElements = [],
            a(e.snap.constructor != String ? e.snap.items || ":data(draggable)" : e.snap).each(function()
            {
                var b = a(this),
                    c = b.offset();
                this != d.element[0] && d.snapElements.push({
                    item: this, width: b.outerWidth(), height: b.outerHeight(), top: c.top, left: c.left
                })
            })
        }, drag: function(b, c)
            {
                var d = a(this).data("draggable"),
                    e = d.options,
                    f = e.snapTolerance,
                    g = c.offset.left,
                    h = g + d.helperProportions.width,
                    i = c.offset.top,
                    j = i + d.helperProportions.height;
                for (var k = d.snapElements.length - 1; k >= 0; k--)
                {
                    var l = d.snapElements[k].left,
                        m = l + d.snapElements[k].width,
                        n = d.snapElements[k].top,
                        o = n + d.snapElements[k].height;
                    if (!(l - f < g && g < m + f && n - f < i && i < o + f || l - f < g && g < m + f && n - f < j && j < o + f || l - f < h && h < m + f && n - f < i && i < o + f || l - f < h && h < m + f && n - f < j && j < o + f))
                    {
                        d.snapElements[k].snapping && d.options.snap.release && d.options.snap.release.call(d.element, b, a.extend(d._uiHash(), {snapItem: d.snapElements[k].item})),
                        d.snapElements[k].snapping = !1;
                        continue
                    }
                    if (e.snapMode != "inner")
                    {
                        var p = Math.abs(n - j) <= f,
                            q = Math.abs(o - i) <= f,
                            r = Math.abs(l - h) <= f,
                            s = Math.abs(m - g) <= f;
                        p && (c.position.top = d._convertPositionTo("relative", {
                            top: n - d.helperProportions.height, left: 0
                        }).top - d.margins.top),
                        q && (c.position.top = d._convertPositionTo("relative", {
                            top: o, left: 0
                        }).top - d.margins.top),
                        r && (c.position.left = d._convertPositionTo("relative", {
                            top: 0, left: l - d.helperProportions.width
                        }).left - d.margins.left),
                        s && (c.position.left = d._convertPositionTo("relative", {
                            top: 0, left: m
                        }).left - d.margins.left)
                    }
                    var t = p || q || r || s;
                    if (e.snapMode != "outer")
                    {
                        var p = Math.abs(n - i) <= f,
                            q = Math.abs(o - j) <= f,
                            r = Math.abs(l - g) <= f,
                            s = Math.abs(m - h) <= f;
                        p && (c.position.top = d._convertPositionTo("relative", {
                            top: n, left: 0
                        }).top - d.margins.top),
                        q && (c.position.top = d._convertPositionTo("relative", {
                            top: o - d.helperProportions.height, left: 0
                        }).top - d.margins.top),
                        r && (c.position.left = d._convertPositionTo("relative", {
                            top: 0, left: l
                        }).left - d.margins.left),
                        s && (c.position.left = d._convertPositionTo("relative", {
                            top: 0, left: m - d.helperProportions.width
                        }).left - d.margins.left)
                    }
                    !d.snapElements[k].snapping && (p || q || r || s || t) && d.options.snap.snap && d.options.snap.snap.call(d.element, b, a.extend(d._uiHash(), {snapItem: d.snapElements[k].item})),
                    d.snapElements[k].snapping = p || q || r || s || t
                }
            }
    }),
    a.ui.plugin.add("draggable", "stack", {start: function(b, c)
        {
            var d = a(this).data("draggable").options,
                e = a.makeArray(a(d.stack)).sort(function(b, c)
                {
                    return (parseInt(a(b).css("zIndex"), 10) || 0) - (parseInt(a(c).css("zIndex"), 10) || 0)
                });
            if (!!e.length)
            {
                var f = parseInt(e[0].style.zIndex) || 0;
                a(e).each(function(a)
                {
                    this.style.zIndex = f + a
                }),
                this[0].style.zIndex = f + e.length
            }
        }}),
    a.ui.plugin.add("draggable", "zIndex", {
        start: function(b, c)
        {
            var d = a(c.helper),
                e = a(this).data("draggable").options;
            d.css("zIndex") && (e._zIndex = d.css("zIndex")),
            d.css("zIndex", e.zIndex)
        }, stop: function(b, c)
            {
                var d = a(this).data("draggable").options;
                d._zIndex && a(c.helper).css("zIndex", d._zIndex)
            }
    })
})(jQuery);
(function(a, b)
{
    var c = 5;
    a.widget("ui.slider", a.ui.mouse, {
        widgetEventPrefix: "slide", options: {
                animate: !1, distance: 0, max: 100, min: 0, orientation: "horizontal", range: !1, step: 1, value: 0, values: null
            }, _create: function()
            {
                var b = this,
                    d = this.options,
                    e = this.element.find(".ui-slider-handle").addClass("ui-state-default ui-corner-all"),
                    f = "<a class='ui-slider-handle ui-state-default ui-corner-all' href='#'></a>",
                    g = d.values && d.values.length || 1,
                    h = [];
                this._keySliding = !1,
                this._mouseSliding = !1,
                this._animateOff = !0,
                this._handleIndex = null,
                this._detectOrientation(),
                this._mouseInit(),
                this.element.addClass("ui-slider ui-slider-" + this.orientation + " ui-widget" + " ui-widget-content" + " ui-corner-all" + (d.disabled ? " ui-slider-disabled ui-disabled" : "")),
                this.range = a([]),
                d.range && (d.range === !0 && (d.values || (d.values = [this._valueMin(), this._valueMin()]), d.values.length && d.values.length !== 2 && (d.values = [d.values[0], d.values[0]])), this.range = a("<div></div>").appendTo(this.element).addClass("ui-slider-range ui-widget-header" + (d.range === "min" || d.range === "max" ? " ui-slider-range-" + d.range : "")));
                for (var i = e.length; i < g; i += 1)
                    h.push(f);
                this.handles = e.add(a(h.join("")).appendTo(b.element)),
                this.handle = this.handles.eq(0),
                this.handles.add(this.range).filter("a").click(function(a)
                {
                    a.preventDefault()
                }).hover(function()
                {
                    d.disabled || a(this).addClass("ui-state-hover")
                }, function()
                {
                    a(this).removeClass("ui-state-hover")
                }).focus(function()
                {
                    d.disabled ? a(this).blur() : (a(".ui-slider .ui-state-focus").removeClass("ui-state-focus"), a(this).addClass("ui-state-focus"))
                }).blur(function()
                {
                    a(this).removeClass("ui-state-focus")
                }),
                this.handles.each(function(b)
                {
                    a(this).data("index.ui-slider-handle", b)
                }),
                this.handles.keydown(function(d)
                {
                    var e = !0,
                        f = a(this).data("index.ui-slider-handle"),
                        g,
                        h,
                        i,
                        j;
                    if (!b.options.disabled)
                    {
                        switch (d.keyCode)
                        {
                            case a.ui.keyCode.HOME:
                            case a.ui.keyCode.END:
                            case a.ui.keyCode.PAGE_UP:
                            case a.ui.keyCode.PAGE_DOWN:
                            case a.ui.keyCode.UP:
                            case a.ui.keyCode.RIGHT:
                            case a.ui.keyCode.DOWN:
                            case a.ui.keyCode.LEFT:
                                e = !1;
                                if (!b._keySliding)
                                {
                                    b._keySliding = !0,
                                    a(this).addClass("ui-state-active"),
                                    g = b._start(d, f);
                                    if (g === !1)
                                        return
                                }
                        }
                        j = b.options.step,
                        b.options.values && b.options.values.length ? h = i = b.values(f) : h = i = b.value();
                        switch (d.keyCode)
                        {
                            case a.ui.keyCode.HOME:
                                i = b._valueMin();
                                break;
                            case a.ui.keyCode.END:
                                i = b._valueMax();
                                break;
                            case a.ui.keyCode.PAGE_UP:
                                i = b._trimAlignValue(h + (b._valueMax() - b._valueMin()) / c);
                                break;
                            case a.ui.keyCode.PAGE_DOWN:
                                i = b._trimAlignValue(h - (b._valueMax() - b._valueMin()) / c);
                                break;
                            case a.ui.keyCode.UP:
                            case a.ui.keyCode.RIGHT:
                                if (h === b._valueMax())
                                    return;
                                i = b._trimAlignValue(h + j);
                                break;
                            case a.ui.keyCode.DOWN:
                            case a.ui.keyCode.LEFT:
                                if (h === b._valueMin())
                                    return;
                                i = b._trimAlignValue(h - j)
                        }
                        b._slide(d, f, i);
                        return e
                    }
                }).keyup(function(c)
                {
                    var d = a(this).data("index.ui-slider-handle");
                    b._keySliding && (b._keySliding = !1, b._stop(c, d), b._change(c, d), a(this).removeClass("ui-state-active"))
                }),
                this._refreshValue(),
                this._animateOff = !1
            }, destroy: function()
            {
                this.handles.remove(),
                this.range.remove(),
                this.element.removeClass("ui-slider ui-slider-horizontal ui-slider-vertical ui-slider-disabled ui-widget ui-widget-content ui-corner-all").removeData("slider").unbind(".slider"),
                this._mouseDestroy();
                return this
            }, _mouseCapture: function(b)
            {
                var c = this.options,
                    d,
                    e,
                    f,
                    g,
                    h,
                    i,
                    j,
                    k,
                    l;
                if (c.disabled)
                    return !1;
                this.elementSize = {
                    width: this.element.outerWidth(), height: this.element.outerHeight()
                },
                this.elementOffset = this.element.offset(),
                d = {
                    x: b.pageX, y: b.pageY
                },
                e = this._normValueFromMouse(d),
                f = this._valueMax() - this._valueMin() + 1,
                h = this,
                this.handles.each(function(b)
                {
                    var c = Math.abs(e - h.values(b));
                    f > c && (f = c, g = a(this), i = b)
                }),
                c.range === !0 && this.values(1) === c.min && (i += 1, g = a(this.handles[i])),
                j = this._start(b, i);
                if (j === !1)
                    return !1;
                this._mouseSliding = !0,
                h._handleIndex = i,
                g.addClass("ui-state-active").focus(),
                k = g.offset(),
                l = !a(b.target).parents().andSelf().is(".ui-slider-handle"),
                this._clickOffset = l ? {
                    left: 0, top: 0
                } : {
                    left: b.pageX - k.left - g.width() / 2, top: b.pageY - k.top - g.height() / 2 - (parseInt(g.css("borderTopWidth"), 10) || 0) - (parseInt(g.css("borderBottomWidth"), 10) || 0) + (parseInt(g.css("marginTop"), 10) || 0)
                },
                this.handles.hasClass("ui-state-hover") || this._slide(b, i, e),
                this._animateOff = !0;
                return !0
            }, _mouseStart: function(a)
            {
                return !0
            }, _mouseDrag: function(a)
            {
                var b = {
                        x: a.pageX, y: a.pageY
                    },
                    c = this._normValueFromMouse(b);
                this._slide(a, this._handleIndex, c);
                return !1
            }, _mouseStop: function(a)
            {
                this.handles.removeClass("ui-state-active"),
                this._mouseSliding = !1,
                this._stop(a, this._handleIndex),
                this._change(a, this._handleIndex),
                this._handleIndex = null,
                this._clickOffset = null,
                this._animateOff = !1;
                return !1
            }, _detectOrientation: function()
            {
                this.orientation = this.options.orientation === "vertical" ? "vertical" : "horizontal"
            }, _normValueFromMouse: function(a)
            {
                var b,
                    c,
                    d,
                    e,
                    f;
                this.orientation === "horizontal" ? (b = this.elementSize.width, c = a.x - this.elementOffset.left - (this._clickOffset ? this._clickOffset.left : 0)) : (b = this.elementSize.height, c = a.y - this.elementOffset.top - (this._clickOffset ? this._clickOffset.top : 0)),
                d = c / b,
                d > 1 && (d = 1),
                d < 0 && (d = 0),
                this.orientation === "vertical" && (d = 1 - d),
                e = this._valueMax() - this._valueMin(),
                f = this._valueMin() + d * e;
                return this._trimAlignValue(f)
            }, _start: function(a, b)
            {
                var c = {
                        handle: this.handles[b], value: this.value()
                    };
                this.options.values && this.options.values.length && (c.value = this.values(b), c.values = this.values());
                return this._trigger("start", a, c)
            }, _slide: function(a, b, c)
            {
                var d,
                    e,
                    f;
                this.options.values && this.options.values.length ? (d = this.values(b ? 0 : 1), this.options.values.length === 2 && this.options.range === !0 && (b === 0 && c > d || b === 1 && c < d) && (c = d), c !== this.values(b) && (e = this.values(), e[b] = c, f = this._trigger("slide", a, {
                            handle: this.handles[b], value: c, values: e
                        }), d = this.values(b ? 0 : 1), f !== !1 && this.values(b, c, !0))) : c !== this.value() && (f = this._trigger("slide", a, {
                    handle: this.handles[b], value: c
                }), f !== !1 && this.value(c))
            }, _stop: function(a, b)
            {
                var c = {
                        handle: this.handles[b], value: this.value()
                    };
                this.options.values && this.options.values.length && (c.value = this.values(b), c.values = this.values()),
                this._trigger("stop", a, c)
            }, _change: function(a, b)
            {
                if (!this._keySliding && !this._mouseSliding)
                {
                    var c = {
                            handle: this.handles[b], value: this.value()
                        };
                    this.options.values && this.options.values.length && (c.value = this.values(b), c.values = this.values()),
                    this._trigger("change", a, c)
                }
            }, value: function(a)
            {
                if (arguments.length)
                    this.options.value = this._trimAlignValue(a),
                    this._refreshValue(),
                    this._change(null, 0);
                else
                    return this._value()
            }, values: function(b, c)
            {
                var d,
                    e,
                    f;
                if (arguments.length > 1)
                    this.options.values[b] = this._trimAlignValue(c),
                    this._refreshValue(),
                    this._change(null, b);
                else
                {
                    if (!arguments.length)
                        return this._values();
                    if (!a.isArray(arguments[0]))
                        return this.options.values && this.options.values.length ? this._values(b) : this.value();
                    d = this.options.values,
                    e = arguments[0];
                    for (f = 0; f < d.length; f += 1)
                        d[f] = this._trimAlignValue(e[f]),
                        this._change(null, f);
                    this._refreshValue()
                }
            }, _setOption: function(b, c)
            {
                var d,
                    e = 0;
                a.isArray(this.options.values) && (e = this.options.values.length),
                a.Widget.prototype._setOption.apply(this, arguments);
                switch (b)
                {
                    case"disabled":
                        c ? (this.handles.filter(".ui-state-focus").blur(), this.handles.removeClass("ui-state-hover"), this.handles.propAttr("disabled", !0), this.element.addClass("ui-disabled")) : (this.handles.propAttr("disabled", !1), this.element.removeClass("ui-disabled"));
                        break;
                    case"orientation":
                        this._detectOrientation(),
                        this.element.removeClass("ui-slider-horizontal ui-slider-vertical").addClass("ui-slider-" + this.orientation),
                        this._refreshValue();
                        break;
                    case"value":
                        this._animateOff = !0,
                        this._refreshValue(),
                        this._change(null, 0),
                        this._animateOff = !1;
                        break;
                    case"values":
                        this._animateOff = !0,
                        this._refreshValue();
                        for (d = 0; d < e; d += 1)
                            this._change(null, d);
                        this._animateOff = !1
                }
            }, _value: function()
            {
                var a = this.options.value;
                a = this._trimAlignValue(a);
                return a
            }, _values: function(a)
            {
                var b,
                    c,
                    d;
                if (arguments.length)
                {
                    b = this.options.values[a],
                    b = this._trimAlignValue(b);
                    return b
                }
                c = this.options.values.slice();
                for (d = 0; d < c.length; d += 1)
                    c[d] = this._trimAlignValue(c[d]);
                return c
            }, _trimAlignValue: function(a)
            {
                if (a <= this._valueMin())
                    return this._valueMin();
                if (a >= this._valueMax())
                    return this._valueMax();
                var b = this.options.step > 0 ? this.options.step : 1,
                    c = (a - this._valueMin()) % b,
                    d = a - c;
                Math.abs(c) * 2 >= b && (d += c > 0 ? b : -b);
                return parseFloat(d.toFixed(5))
            }, _valueMin: function()
            {
                return this.options.min
            }, _valueMax: function()
            {
                return this.options.max
            }, _refreshValue: function()
            {
                var b = this.options.range,
                    c = this.options,
                    d = this,
                    e = this._animateOff ? !1 : c.animate,
                    f,
                    g = {},
                    h,
                    i,
                    j,
                    k;
                this.options.values && this.options.values.length ? this.handles.each(function(b, i)
                {
                    f = (d.values(b) - d._valueMin()) / (d._valueMax() - d._valueMin()) * 100,
                    g[d.orientation === "horizontal" ? "left" : "bottom"] = f + "%",
                    a(this).stop(1, 1)[e ? "animate" : "css"](g, c.animate),
                    d.options.range === !0 && (d.orientation === "horizontal" ? (b === 0 && d.range.stop(1, 1)[e ? "animate" : "css"]({left: f + "%"}, c.animate), b === 1 && d.range[e ? "animate" : "css"]({width: f - h + "%"}, {
                        queue: !1, duration: c.animate
                    })) : (b === 0 && d.range.stop(1, 1)[e ? "animate" : "css"]({bottom: f + "%"}, c.animate), b === 1 && d.range[e ? "animate" : "css"]({height: f - h + "%"}, {
                        queue: !1, duration: c.animate
                    }))),
                    h = f
                }) : (i = this.value(), j = this._valueMin(), k = this._valueMax(), f = k !== j ? (i - j) / (k - j) * 100 : 0, g[d.orientation === "horizontal" ? "left" : "bottom"] = f + "%", this.handle.stop(1, 1)[e ? "animate" : "css"](g, c.animate), b === "min" && this.orientation === "horizontal" && this.range.stop(1, 1)[e ? "animate" : "css"]({width: f + "%"}, c.animate), b === "max" && this.orientation === "horizontal" && this.range[e ? "animate" : "css"]({width: 100 - f + "%"}, {
                        queue: !1, duration: c.animate
                    }), b === "min" && this.orientation === "vertical" && this.range.stop(1, 1)[e ? "animate" : "css"]({height: f + "%"}, c.animate), b === "max" && this.orientation === "vertical" && this.range[e ? "animate" : "css"]({height: 100 - f + "%"}, {
                        queue: !1, duration: c.animate
                    }))
            }
    }),
    a.extend(a.ui.slider, {version: "1.8.17"})
})(jQuery);
(function($, version)
{
    Math.precision = function(value, precision)
    {
        if (precision === undefined)
            precision = 0;
        return Math.round(value * Math.pow(10, precision)) / Math.pow(10, precision)
    };
    var Slider = function(bar, options)
        {
            var $this = this,
                arrow = bar.find('img:first'),
                minX = 0,
                maxX = 100,
                rangeX = 100,
                minY = 0,
                maxY = 100,
                rangeY = 100,
                x = 0,
                y = 0,
                offset,
                timeout,
                changeEvents = new Array,
                fireChangeEvents = function(context)
                {
                    for (var i = 0; i < changeEvents.length; i++)
                        changeEvents[i].call($this, $this, context)
                },
                mouseDown = function(e)
                {
                    var off = bar.offset();
                    offset = {
                        l: off.left | 0, t: off.top | 0
                    };
                    clearTimeout(timeout);
                    timeout = setTimeout(function()
                    {
                        setValuesFromMousePosition.call($this, e)
                    }, 0);
                    $(document).bind('mousemove', mouseMove).bind('mouseup', mouseUp);
                    e.preventDefault()
                },
                mouseMove = function(e)
                {
                    clearTimeout(timeout);
                    timeout = setTimeout(function()
                    {
                        setValuesFromMousePosition.call($this, e)
                    }, 0);
                    e.stopPropagation();
                    e.preventDefault();
                    return false
                },
                mouseUp = function(e)
                {
                    $(document).unbind('mouseup', mouseUp).unbind('mousemove', mouseMove);
                    e.stopPropagation();
                    e.preventDefault();
                    return false
                },
                setValuesFromMousePosition = function(e)
                {
                    var locX = e.pageX - offset.l,
                        locY = e.pageY - offset.t,
                        barW = bar.w,
                        barH = bar.h;
                    if (locX < 0)
                        locX = 0;
                    else if (locX > barW)
                        locX = barW;
                    if (locY < 0)
                        locY = 0;
                    else if (locY > barH)
                        locY = barH;
                    val.call($this, 'xy', {
                        x: ((locX / barW) * rangeX) + minX, y: ((locY / barH) * rangeY) + minY
                    })
                },
                draw = function()
                {
                    var arrowOffsetX = 0,
                        arrowOffsetY = 0,
                        barW = bar.w,
                        barH = bar.h,
                        arrowW = arrow.w,
                        arrowH = arrow.h;
                    setTimeout(function()
                    {
                        if (rangeX > 0)
                        {
                            if (x == maxX)
                                arrowOffsetX = barW;
                            else
                                arrowOffsetX = ((x / rangeX) * barW) | 0
                        }
                        if (rangeY > 0)
                        {
                            if (y == maxY)
                                arrowOffsetY = barH;
                            else
                                arrowOffsetY = ((y / rangeY) * barH) | 0
                        }
                        if (arrowW >= barW)
                            arrowOffsetX = (barW >> 1) - (arrowW >> 1);
                        else
                            arrowOffsetX -= arrowW >> 1;
                        if (arrowH >= barH)
                            arrowOffsetY = (barH >> 1) - (arrowH >> 1);
                        else
                            arrowOffsetY -= arrowH >> 1;
                        arrow.css({
                            left: arrowOffsetX + 'px', top: arrowOffsetY + 'px'
                        })
                    }, 0)
                },
                val = function(name, value, context)
                {
                    var set = value !== undefined;
                    if (!set)
                    {
                        if (name === undefined || name == null)
                            name = 'xy';
                        switch (name.toLowerCase())
                        {
                            case'x':
                                return x;
                            case'y':
                                return y;
                            case'xy':
                            default:
                                return {
                                        x: x, y: y
                                    }
                        }
                    }
                    if (context != null && context == $this)
                        return;
                    var changed = false,
                        newX,
                        newY;
                    if (name == null)
                        name = 'xy';
                    switch (name.toLowerCase())
                    {
                        case'x':
                            newX = value && (value.x && value.x | 0 || value | 0) || 0;
                            break;
                        case'y':
                            newY = value && (value.y && value.y | 0 || value | 0) || 0;
                            break;
                        case'xy':
                        default:
                            newX = value && value.x && value.x | 0 || 0;
                            newY = value && value.y && value.y | 0 || 0;
                            break
                    }
                    if (newX != null)
                    {
                        if (newX < minX)
                            newX = minX;
                        else if (newX > maxX)
                            newX = maxX;
                        if (x != newX)
                        {
                            x = newX;
                            changed = true
                        }
                    }
                    if (newY != null)
                    {
                        if (newY < minY)
                            newY = minY;
                        else if (newY > maxY)
                            newY = maxY;
                        if (y != newY)
                        {
                            y = newY;
                            changed = true
                        }
                    }
                    changed && fireChangeEvents.call($this, context || $this)
                },
                range = function(name, value)
                {
                    var set = value !== undefined;
                    if (!set)
                    {
                        if (name === undefined || name == null)
                            name = 'all';
                        switch (name.toLowerCase())
                        {
                            case'minx':
                                return minX;
                            case'maxx':
                                return maxX;
                            case'rangex':
                                return {
                                        minX: minX, maxX: maxX, rangeX: rangeX
                                    };
                            case'miny':
                                return minY;
                            case'maxy':
                                return maxY;
                            case'rangey':
                                return {
                                        minY: minY, maxY: maxY, rangeY: rangeY
                                    };
                            case'all':
                            default:
                                return {
                                        minX: minX, maxX: maxX, rangeX: rangeX, minY: minY, maxY: maxY, rangeY: rangeY
                                    }
                        }
                    }
                    var changed = false,
                        newMinX,
                        newMaxX,
                        newMinY,
                        newMaxY;
                    if (name == null)
                        name = 'all';
                    switch (name.toLowerCase())
                    {
                        case'minx':
                            newMinX = value && (value.minX && value.minX | 0 || value | 0) || 0;
                            break;
                        case'maxx':
                            newMaxX = value && (value.maxX && value.maxX | 0 || value | 0) || 0;
                            break;
                        case'rangex':
                            newMinX = value && value.minX && value.minX | 0 || 0;
                            newMaxX = value && value.maxX && value.maxX | 0 || 0;
                            break;
                        case'miny':
                            newMinY = value && (value.minY && value.minY | 0 || value | 0) || 0;
                            break;
                        case'maxy':
                            newMaxY = value && (value.maxY && value.maxY | 0 || value | 0) || 0;
                            break;
                        case'rangey':
                            newMinY = value && value.minY && value.minY | 0 || 0;
                            newMaxY = value && value.maxY && value.maxY | 0 || 0;
                            break;
                        case'all':
                        default:
                            newMinX = value && value.minX && value.minX | 0 || 0;
                            newMaxX = value && value.maxX && value.maxX | 0 || 0;
                            newMinY = value && value.minY && value.minY | 0 || 0;
                            newMaxY = value && value.maxY && value.maxY | 0 || 0;
                            break
                    }
                    if (newMinX != null && minX != newMinX)
                    {
                        minX = newMinX;
                        rangeX = maxX - minX
                    }
                    if (newMaxX != null && maxX != newMaxX)
                    {
                        maxX = newMaxX;
                        rangeX = maxX - minX
                    }
                    if (newMinY != null && minY != newMinY)
                    {
                        minY = newMinY;
                        rangeY = maxY - minY
                    }
                    if (newMaxY != null && maxY != newMaxY)
                    {
                        maxY = newMaxY;
                        rangeY = maxY - minY
                    }
                },
                bind = function(callback)
                {
                    if ($.isFunction(callback))
                        changeEvents.push(callback)
                },
                unbind = function(callback)
                {
                    if (!$.isFunction(callback))
                        return;
                    var i;
                    while ((i = $.inArray(callback, changeEvents)) != -1)
                        changeEvents.splice(i, 1)
                },
                destroy = function()
                {
                    $(document).unbind('mouseup', mouseUp).unbind('mousemove', mouseMove);
                    bar.unbind('mousedown', mouseDown);
                    bar = null;
                    arrow = null;
                    changeEvents = null
                };
            $.extend(true, $this, {
                val: val, range: range, bind: bind, unbind: unbind, destroy: destroy
            });
            arrow.src = options.arrow && options.arrow.image;
            arrow.w = options.arrow && options.arrow.width || arrow.width();
            arrow.h = options.arrow && options.arrow.height || arrow.height();
            bar.w = options.map && options.map.width || bar.width();
            bar.h = options.map && options.map.height || bar.height();
            bar.bind('mousedown', mouseDown);
            bind.call($this, draw)
        },
        ColorValuePicker = function(picker, color, bindedHex, alphaPrecision)
        {
            var $this = this,
                inputs = picker.find('td.Text input'),
                red = inputs.eq(3),
                green = inputs.eq(4),
                blue = inputs.eq(5),
                alpha = inputs.length > 7 ? inputs.eq(6) : null,
                hue = inputs.eq(0),
                saturation = inputs.eq(1),
                value = inputs.eq(2),
                hex = inputs.eq(inputs.length > 7 ? 7 : 6),
                ahex = inputs.length > 7 ? inputs.eq(8) : null,
                keyDown = function(e)
                {
                    if (e.target.value == '' && e.target != hex.get(0) && (bindedHex != null && e.target != bindedHex.get(0) || bindedHex == null))
                        return;
                    if (!validateKey(e))
                        return e;
                    switch (e.target)
                    {
                        case red.get(0):
                            switch (e.keyCode)
                            {
                                case 38:
                                    red.val(setValueInRange.call($this, (red.val() << 0) + 1, 0, 255));
                                    color.val('r', red.val(), e.target);
                                    return false;
                                case 40:
                                    red.val(setValueInRange.call($this, (red.val() << 0) - 1, 0, 255));
                                    color.val('r', red.val(), e.target);
                                    return false
                            }
                            break;
                        case green.get(0):
                            switch (e.keyCode)
                            {
                                case 38:
                                    green.val(setValueInRange.call($this, (green.val() << 0) + 1, 0, 255));
                                    color.val('g', green.val(), e.target);
                                    return false;
                                case 40:
                                    green.val(setValueInRange.call($this, (green.val() << 0) - 1, 0, 255));
                                    color.val('g', green.val(), e.target);
                                    return false
                            }
                            break;
                        case blue.get(0):
                            switch (e.keyCode)
                            {
                                case 38:
                                    blue.val(setValueInRange.call($this, (blue.val() << 0) + 1, 0, 255));
                                    color.val('b', blue.val(), e.target);
                                    return false;
                                case 40:
                                    blue.val(setValueInRange.call($this, (blue.val() << 0) - 1, 0, 255));
                                    color.val('b', blue.val(), e.target);
                                    return false
                            }
                            break;
                        case alpha && alpha.get(0):
                            switch (e.keyCode)
                            {
                                case 38:
                                    alpha.val(setValueInRange.call($this, parseFloat(alpha.val()) + 1, 0, 100));
                                    color.val('a', Math.precision((alpha.val() * 255) / 100, alphaPrecision), e.target);
                                    return false;
                                case 40:
                                    alpha.val(setValueInRange.call($this, parseFloat(alpha.val()) - 1, 0, 100));
                                    color.val('a', Math.precision((alpha.val() * 255) / 100, alphaPrecision), e.target);
                                    return false
                            }
                            break;
                        case hue.get(0):
                            switch (e.keyCode)
                            {
                                case 38:
                                    hue.val(setValueInRange.call($this, (hue.val() << 0) + 1, 0, 360));
                                    color.val('h', hue.val(), e.target);
                                    return false;
                                case 40:
                                    hue.val(setValueInRange.call($this, (hue.val() << 0) - 1, 0, 360));
                                    color.val('h', hue.val(), e.target);
                                    return false
                            }
                            break;
                        case saturation.get(0):
                            switch (e.keyCode)
                            {
                                case 38:
                                    saturation.val(setValueInRange.call($this, (saturation.val() << 0) + 1, 0, 100));
                                    color.val('s', saturation.val(), e.target);
                                    return false;
                                case 40:
                                    saturation.val(setValueInRange.call($this, (saturation.val() << 0) - 1, 0, 100));
                                    color.val('s', saturation.val(), e.target);
                                    return false
                            }
                            break;
                        case value.get(0):
                            switch (e.keyCode)
                            {
                                case 38:
                                    value.val(setValueInRange.call($this, (value.val() << 0) + 1, 0, 100));
                                    color.val('v', value.val(), e.target);
                                    return false;
                                case 40:
                                    value.val(setValueInRange.call($this, (value.val() << 0) - 1, 0, 100));
                                    color.val('v', value.val(), e.target);
                                    return false
                            }
                            break
                    }
                },
                keyUp = function(e)
                {
                    if (e.target.value == '' && e.target != hex.get(0) && (bindedHex != null && e.target != bindedHex.get(0) || bindedHex == null))
                        return;
                    if (!validateKey(e))
                        return e;
                    switch (e.target)
                    {
                        case red.get(0):
                            red.val(setValueInRange.call($this, red.val(), 0, 255));
                            color.val('r', red.val(), e.target);
                            break;
                        case green.get(0):
                            green.val(setValueInRange.call($this, green.val(), 0, 255));
                            color.val('g', green.val(), e.target);
                            break;
                        case blue.get(0):
                            blue.val(setValueInRange.call($this, blue.val(), 0, 255));
                            color.val('b', blue.val(), e.target);
                            break;
                        case alpha && alpha.get(0):
                            alpha.val(setValueInRange.call($this, alpha.val(), 0, 100));
                            color.val('a', Math.precision((alpha.val() * 255) / 100, alphaPrecision), e.target);
                            break;
                        case hue.get(0):
                            hue.val(setValueInRange.call($this, hue.val(), 0, 360));
                            color.val('h', hue.val(), e.target);
                            break;
                        case saturation.get(0):
                            saturation.val(setValueInRange.call($this, saturation.val(), 0, 100));
                            color.val('s', saturation.val(), e.target);
                            break;
                        case value.get(0):
                            value.val(setValueInRange.call($this, value.val(), 0, 100));
                            color.val('v', value.val(), e.target);
                            break;
                        case hex.get(0):
                            hex.val(hex.val().replace(/[^a-fA-F0-9]/g, '').toLowerCase().substring(0, 6));
                            bindedHex && bindedHex.val(hex.val());
                            color.val('hex', hex.val() != '' ? hex.val() : null, e.target);
                            break;
                        case bindedHex && bindedHex.get(0):
                            bindedHex.val(bindedHex.val().replace(/[^a-fA-F0-9]/g, '').toLowerCase().substring(0, 6));
                            hex.val(bindedHex.val());
                            color.val('hex', bindedHex.val() != '' ? bindedHex.val() : null, e.target);
                            break;
                        case ahex && ahex.get(0):
                            ahex.val(ahex.val().replace(/[^a-fA-F0-9]/g, '').toLowerCase().substring(0, 2));
                            color.val('a', ahex.val() != null ? parseInt(ahex.val(), 16) : null, e.target);
                            break
                    }
                },
                blur = function(e)
                {
                    if (color.val() != null)
                    {
                        switch (e.target)
                        {
                            case red.get(0):
                                red.val(color.val('r'));
                                break;
                            case green.get(0):
                                green.val(color.val('g'));
                                break;
                            case blue.get(0):
                                blue.val(color.val('b'));
                                break;
                            case alpha && alpha.get(0):
                                alpha.val(Math.precision((color.val('a') * 100) / 255, alphaPrecision));
                                break;
                            case hue.get(0):
                                hue.val(color.val('h'));
                                break;
                            case saturation.get(0):
                                saturation.val(color.val('s'));
                                break;
                            case value.get(0):
                                value.val(color.val('v'));
                                break;
                            case hex.get(0):
                            case bindedHex && bindedHex.get(0):
                                hex.val(color.val('hex'));
                                bindedHex && bindedHex.val(color.val('hex'));
                                break;
                            case ahex && ahex.get(0):
                                ahex.val(color.val('ahex').substring(6));
                                break
                        }
                    }
                },
                validateKey = function(e)
                {
                    switch (e.keyCode)
                    {
                        case 9:
                        case 16:
                        case 29:
                        case 37:
                        case 39:
                            return false;
                        case'c'.charCodeAt():
                        case'v'.charCodeAt():
                            if (e.ctrlKey)
                                return false
                    }
                    return true
                },
                setValueInRange = function(value, min, max)
                {
                    if (value == '' || isNaN(value))
                        return min;
                    if (value > max)
                        return max;
                    if (value < min)
                        return min;
                    return value
                },
                colorChanged = function(ui, context)
                {
                    var all = ui.val('all');
                    if (context != red.get(0))
                        red.val(all != null ? all.r : '');
                    if (context != green.get(0))
                        green.val(all != null ? all.g : '');
                    if (context != blue.get(0))
                        blue.val(all != null ? all.b : '');
                    if (alpha && context != alpha.get(0))
                        alpha.val(all != null ? Math.precision((all.a * 100) / 255, alphaPrecision) : '');
                    if (context != hue.get(0))
                        hue.val(all != null ? all.h : '');
                    if (context != saturation.get(0))
                        saturation.val(all != null ? all.s : '');
                    if (context != value.get(0))
                        value.val(all != null ? all.v : '');
                    if (context != hex.get(0) && (bindedHex && context != bindedHex.get(0) || !bindedHex))
                        hex.val(all != null ? all.hex : '');
                    if (bindedHex && context != bindedHex.get(0) && context != hex.get(0))
                        bindedHex.val(all != null ? all.hex : '');
                    if (ahex && context != ahex.get(0))
                        ahex.val(all != null ? all.ahex.substring(6) : '')
                },
                destroy = function()
                {
                    red.add(green).add(blue).add(alpha).add(hue).add(saturation).add(value).add(hex).add(bindedHex).add(ahex).unbind('keyup', keyUp).unbind('blur', blur);
                    red.add(green).add(blue).add(alpha).add(hue).add(saturation).add(value).unbind('keydown', keyDown);
                    color.unbind(colorChanged);
                    red = null;
                    green = null;
                    blue = null;
                    alpha = null;
                    hue = null;
                    saturation = null;
                    value = null;
                    hex = null;
                    ahex = null
                };
            $.extend(true, $this, {destroy: destroy});
            red.add(green).add(blue).add(alpha).add(hue).add(saturation).add(value).add(hex).add(bindedHex).add(ahex).bind('keyup', keyUp).bind('blur', blur);
            red.add(green).add(blue).add(alpha).add(hue).add(saturation).add(value).bind('keydown', keyDown);
            color.bind(colorChanged)
        };
    $.jPicker = {
        List: [], Color: function(init)
            {
                var $this = this,
                    r,
                    g,
                    b,
                    a,
                    h,
                    s,
                    v,
                    changeEvents = new Array,
                    fireChangeEvents = function(context)
                    {
                        for (var i = 0; i < changeEvents.length; i++)
                            changeEvents[i].call($this, $this, context)
                    },
                    val = function(name, value, context)
                    {
                        var set = Boolean(value);
                        if (set && value.ahex === "")
                            value.ahex = "00000000";
                        if (!set)
                        {
                            if (name === undefined || name == null || name == '')
                                name = 'all';
                            if (r == null)
                                return null;
                            switch (name.toLowerCase())
                            {
                                case'ahex':
                                    return ColorMethods.rgbaToHex({
                                            r: r, g: g, b: b, a: a
                                        });
                                case'hex':
                                    return val('ahex').substring(0, 6);
                                case'all':
                                    return {
                                            r: r, g: g, b: b, a: a, h: h, s: s, v: v, hex: val.call($this, 'hex'), ahex: val.call($this, 'ahex')
                                        };
                                default:
                                    var ret = {};
                                    for (var i = 0; i < name.length; i++)
                                    {
                                        switch (name.charAt(i))
                                        {
                                            case'r':
                                                if (name.length == 1)
                                                    ret = r;
                                                else
                                                    ret.r = r;
                                                break;
                                            case'g':
                                                if (name.length == 1)
                                                    ret = g;
                                                else
                                                    ret.g = g;
                                                break;
                                            case'b':
                                                if (name.length == 1)
                                                    ret = b;
                                                else
                                                    ret.b = b;
                                                break;
                                            case'a':
                                                if (name.length == 1)
                                                    ret = a;
                                                else
                                                    ret.a = a;
                                                break;
                                            case'h':
                                                if (name.length == 1)
                                                    ret = h;
                                                else
                                                    ret.h = h;
                                                break;
                                            case's':
                                                if (name.length == 1)
                                                    ret = s;
                                                else
                                                    ret.s = s;
                                                break;
                                            case'v':
                                                if (name.length == 1)
                                                    ret = v;
                                                else
                                                    ret.v = v;
                                                break
                                        }
                                    }
                                    return ret == {} ? val.call($this, 'all') : ret;
                                    break
                            }
                        }
                        if (context != null && context == $this)
                            return;
                        var changed = false;
                        if (name == null)
                            name = '';
                        if (value == null)
                        {
                            if (r != null)
                            {
                                r = null;
                                changed = true
                            }
                            if (g != null)
                            {
                                g = null;
                                changed = true
                            }
                            if (b != null)
                            {
                                b = null;
                                changed = true
                            }
                            if (a != null)
                            {
                                a = null;
                                changed = true
                            }
                            if (h != null)
                            {
                                h = null;
                                changed = true
                            }
                            if (s != null)
                            {
                                s = null;
                                changed = true
                            }
                            if (v != null)
                            {
                                v = null;
                                changed = true
                            }
                            changed && fireChangeEvents.call($this, context || $this);
                            return
                        }
                        switch (name.toLowerCase())
                        {
                            case'ahex':
                            case'hex':
                                var ret = ColorMethods.hexToRgba(value && (value.ahex || value.hex) || value || 'none');
                                val.call($this, 'rgba', {
                                    r: ret.r, g: ret.g, b: ret.b, a: name == 'ahex' ? ret.a : a != null ? a : 255
                                }, context);
                                break;
                            default:
                                if (value && (value.ahex != null || value.hex != null))
                                {
                                    val.call($this, 'ahex', value.ahex || value.hex || '00000000', context);
                                    return
                                }
                                var newV = {},
                                    rgb = false,
                                    hsv = false;
                                if (value.r !== undefined && !name.indexOf('r') == -1)
                                    name += 'r';
                                if (value.g !== undefined && !name.indexOf('g') == -1)
                                    name += 'g';
                                if (value.b !== undefined && !name.indexOf('b') == -1)
                                    name += 'b';
                                if (value.a !== undefined && !name.indexOf('a') == -1)
                                    name += 'a';
                                if (value.h !== undefined && !name.indexOf('h') == -1)
                                    name += 'h';
                                if (value.s !== undefined && !name.indexOf('s') == -1)
                                    name += 's';
                                if (value.v !== undefined && !name.indexOf('v') == -1)
                                    name += 'v';
                                for (var i = 0; i < name.length; i++)
                                {
                                    switch (name.charAt(i))
                                    {
                                        case'r':
                                            if (hsv)
                                                continue;
                                            rgb = true;
                                            newV.r = value && value.r && value.r | 0 || value && value | 0 || 0;
                                            if (newV.r < 0)
                                                newV.r = 0;
                                            else if (newV.r > 255)
                                                newV.r = 255;
                                            if (r != newV.r)
                                            {
                                                r = newV.r;
                                                changed = true
                                            }
                                            break;
                                        case'g':
                                            if (hsv)
                                                continue;
                                            rgb = true;
                                            newV.g = value && value.g && value.g | 0 || value && value | 0 || 0;
                                            if (newV.g < 0)
                                                newV.g = 0;
                                            else if (newV.g > 255)
                                                newV.g = 255;
                                            if (g != newV.g)
                                            {
                                                g = newV.g;
                                                changed = true
                                            }
                                            break;
                                        case'b':
                                            if (hsv)
                                                continue;
                                            rgb = true;
                                            newV.b = value && value.b && value.b | 0 || value && value | 0 || 0;
                                            if (newV.b < 0)
                                                newV.b = 0;
                                            else if (newV.b > 255)
                                                newV.b = 255;
                                            if (b != newV.b)
                                            {
                                                b = newV.b;
                                                changed = true
                                            }
                                            break;
                                        case'a':
                                            newV.a = value && value.a != null ? value.a | 0 : value != null ? value | 0 : 255;
                                            if (newV.a < 0)
                                                newV.a = 0;
                                            else if (newV.a > 255)
                                                newV.a = 255;
                                            if (a != newV.a)
                                            {
                                                a = newV.a;
                                                changed = true
                                            }
                                            break;
                                        case'h':
                                            if (rgb)
                                                continue;
                                            hsv = true;
                                            newV.h = value && value.h && value.h | 0 || value && value | 0 || 0;
                                            if (newV.h < 0)
                                                newV.h = 0;
                                            else if (newV.h > 360)
                                                newV.h = 360;
                                            if (h != newV.h)
                                            {
                                                h = newV.h;
                                                changed = true
                                            }
                                            break;
                                        case's':
                                            if (rgb)
                                                continue;
                                            hsv = true;
                                            newV.s = value && value.s != null ? value.s | 0 : value != null ? value | 0 : 100;
                                            if (newV.s < 0)
                                                newV.s = 0;
                                            else if (newV.s > 100)
                                                newV.s = 100;
                                            if (s != newV.s)
                                            {
                                                s = newV.s;
                                                changed = true
                                            }
                                            break;
                                        case'v':
                                            if (rgb)
                                                continue;
                                            hsv = true;
                                            newV.v = value && value.v != null ? value.v | 0 : value != null ? value | 0 : 100;
                                            if (newV.v < 0)
                                                newV.v = 0;
                                            else if (newV.v > 100)
                                                newV.v = 100;
                                            if (v != newV.v)
                                            {
                                                v = newV.v;
                                                changed = true
                                            }
                                            break
                                    }
                                }
                                if (changed)
                                {
                                    if (rgb)
                                    {
                                        r = r || 0;
                                        g = g || 0;
                                        b = b || 0;
                                        var ret = ColorMethods.rgbToHsv({
                                                r: r, g: g, b: b
                                            });
                                        h = ret.h;
                                        s = ret.s;
                                        v = ret.v
                                    }
                                    else if (hsv)
                                    {
                                        h = h || 0;
                                        s = s != null ? s : 100;
                                        v = v != null ? v : 100;
                                        var ret = ColorMethods.hsvToRgb({
                                                h: h, s: s, v: v
                                            });
                                        r = ret.r;
                                        g = ret.g;
                                        b = ret.b
                                    }
                                    a = a != null ? a : 255;
                                    fireChangeEvents.call($this, context || $this)
                                }
                                break
                        }
                    },
                    bind = function(callback)
                    {
                        if ($.isFunction(callback))
                            changeEvents.push(callback)
                    },
                    unbind = function(callback)
                    {
                        if (!$.isFunction(callback))
                            return;
                        var i;
                        while ((i = $.inArray(callback, changeEvents)) != -1)
                            changeEvents.splice(i, 1)
                    },
                    destroy = function()
                    {
                        changeEvents = null
                    };
                $.extend(true, $this, {
                    val: val, bind: bind, unbind: unbind, destroy: destroy
                });
                if (init)
                {
                    if (init.ahex != null)
                        val('ahex', init);
                    else if (init.hex != null)
                        val((init.a != null ? 'a' : '') + 'hex', init.a != null ? {ahex: init.hex + ColorMethods.intToHex(init.a)} : init);
                    else if (init.r != null && init.g != null && init.b != null)
                        val('rgb' + (init.a != null ? 'a' : ''), init);
                    else if (init.h != null && init.s != null && init.v != null)
                        val('hsv' + (init.a != null ? 'a' : ''), init)
                }
            }, ColorMethods: {
                hexToRgba: function(hex)
                {
                    if (hex === '' || hex === 'none')
                        return {
                                r: null, g: null, b: null, a: null
                            };
                    hex = this.validateHex(hex);
                    var r = '00',
                        g = '00',
                        b = '00',
                        a = '255';
                    if (hex.length == 6)
                        hex += 'ff';
                    if (hex.length > 6)
                    {
                        r = hex.substring(0, 2);
                        g = hex.substring(2, 4);
                        b = hex.substring(4, 6);
                        a = hex.substring(6, hex.length)
                    }
                    else
                    {
                        if (hex.length > 4)
                        {
                            r = hex.substring(4, hex.length);
                            hex = hex.substring(0, 4)
                        }
                        if (hex.length > 2)
                        {
                            g = hex.substring(2, hex.length);
                            hex = hex.substring(0, 2)
                        }
                        if (hex.length > 0)
                            b = hex.substring(0, hex.length)
                    }
                    return {
                            r: this.hexToInt(r), g: this.hexToInt(g), b: this.hexToInt(b), a: this.hexToInt(a)
                        }
                }, validateHex: function(hex)
                    {
                        hex = hex.toLowerCase().replace(/[^a-f0-9]/g, '');
                        if (hex.length > 8)
                            hex = hex.substring(0, 8);
                        return hex
                    }, rgbaToHex: function(rgba)
                    {
                        return this.intToHex(rgba.r) + this.intToHex(rgba.g) + this.intToHex(rgba.b) + this.intToHex(rgba.a)
                    }, intToHex: function(dec)
                    {
                        var result = (dec | 0).toString(16);
                        if (result.length == 1)
                            result = ('0' + result);
                        return result.toLowerCase()
                    }, hexToInt: function(hex)
                    {
                        return parseInt(hex, 16)
                    }, rgbToHsv: function(rgb)
                    {
                        var r = rgb.r / 255,
                            g = rgb.g / 255,
                            b = rgb.b / 255,
                            hsv = {
                                h: 0, s: 0, v: 0
                            },
                            min = 0,
                            max = 0,
                            delta;
                        if (r >= g && r >= b)
                        {
                            max = r;
                            min = g > b ? b : g
                        }
                        else if (g >= b && g >= r)
                        {
                            max = g;
                            min = r > b ? b : r
                        }
                        else
                        {
                            max = b;
                            min = g > r ? r : g
                        }
                        hsv.v = max;
                        hsv.s = max ? (max - min) / max : 0;
                        if (!hsv.s)
                            hsv.h = 0;
                        else
                        {
                            delta = max - min;
                            if (r == max)
                                hsv.h = (g - b) / delta;
                            else if (g == max)
                                hsv.h = 2 + (b - r) / delta;
                            else
                                hsv.h = 4 + (r - g) / delta;
                            hsv.h = parseInt(hsv.h * 60);
                            if (hsv.h < 0)
                                hsv.h += 360
                        }
                        hsv.s = (hsv.s * 100) | 0;
                        hsv.v = (hsv.v * 100) | 0;
                        return hsv
                    }, hsvToRgb: function(hsv)
                    {
                        var rgb = {
                                r: 0, g: 0, b: 0, a: 100
                            },
                            h = hsv.h,
                            s = hsv.s,
                            v = hsv.v;
                        if (s == 0)
                        {
                            if (v == 0)
                                rgb.r = rgb.g = rgb.b = 0;
                            else
                                rgb.r = rgb.g = rgb.b = (v * 255 / 100) | 0
                        }
                        else
                        {
                            if (h == 360)
                                h = 0;
                            h /= 60;
                            s = s / 100;
                            v = v / 100;
                            var i = h | 0,
                                f = h - i,
                                p = v * (1 - s),
                                q = v * (1 - (s * f)),
                                t = v * (1 - (s * (1 - f)));
                            switch (i)
                            {
                                case 0:
                                    rgb.r = v;
                                    rgb.g = t;
                                    rgb.b = p;
                                    break;
                                case 1:
                                    rgb.r = q;
                                    rgb.g = v;
                                    rgb.b = p;
                                    break;
                                case 2:
                                    rgb.r = p;
                                    rgb.g = v;
                                    rgb.b = t;
                                    break;
                                case 3:
                                    rgb.r = p;
                                    rgb.g = q;
                                    rgb.b = v;
                                    break;
                                case 4:
                                    rgb.r = t;
                                    rgb.g = p;
                                    rgb.b = v;
                                    break;
                                case 5:
                                    rgb.r = v;
                                    rgb.g = p;
                                    rgb.b = q;
                                    break
                            }
                            rgb.r = (rgb.r * 255) | 0;
                            rgb.g = (rgb.g * 255) | 0;
                            rgb.b = (rgb.b * 255) | 0
                        }
                        return rgb
                    }
            }
    };
    var Color = $.jPicker.Color,
        List = $.jPicker.List,
        ColorMethods = $.jPicker.ColorMethods;
    $.fn.jPicker = function(options)
    {
        var $arguments = arguments;
        return this.each(function()
            {
                var $this = this,
                    settings = $.extend(true, {}, $.fn.jPicker.defaults, options);
                if ($($this).get(0).nodeName.toLowerCase() == 'input')
                {
                    $.extend(true, settings, {window: {
                            bindToInput: true, expandable: true, input: $($this)
                        }});
                    if ($($this).val() == '')
                    {
                        settings.color.active = new Color({hex: null});
                        settings.color.current = new Color({hex: null})
                    }
                    else if (ColorMethods.validateHex($($this).val()))
                    {
                        settings.color.active = new Color({
                            hex: $($this).val(), a: settings.color.active.val('a')
                        });
                        settings.color.current = new Color({
                            hex: $($this).val(), a: settings.color.active.val('a')
                        })
                    }
                }
                if (settings.window.expandable)
                    $($this).after('<span class="jPicker"><span class="Icon"><span class="Color">&nbsp;</span><span class="Alpha">&nbsp;</span><span class="Image" title="Click To Open Color Picker">&nbsp;</span><span class="Container">&nbsp;</span></span></span>');
                else
                    settings.window.liveUpdate = false;
                var isLessThanIE7 = parseFloat(navigator.appVersion.split('MSIE')[1]) < 7 && document.body.filters,
                    container = null,
                    colorMapDiv = null,
                    colorBarDiv = null,
                    colorMapL1 = null,
                    colorMapL2 = null,
                    colorMapL3 = null,
                    colorBarL1 = null,
                    colorBarL2 = null,
                    colorBarL3 = null,
                    colorBarL4 = null,
                    colorBarL5 = null,
                    colorBarL6 = null,
                    colorMap = null,
                    colorBar = null,
                    colorPicker = null,
                    elementStartX = null,
                    elementStartY = null,
                    pageStartX = null,
                    pageStartY = null,
                    activePreview = null,
                    currentPreview = null,
                    okButton = null,
                    cancelButton = null,
                    grid = null,
                    iconColor = null,
                    iconAlpha = null,
                    iconImage = null,
                    moveBar = null,
                    setColorMode = function(colorMode)
                    {
                        var active = color.active,
                            clientPath = images.clientPath,
                            hex = active.val('hex'),
                            rgbMap,
                            rgbBar;
                        settings.color.mode = colorMode;
                        switch (colorMode)
                        {
                            case'h':
                                setTimeout(function()
                                {
                                    setBG.call($this, colorMapDiv, 'transparent');
                                    setImgLoc.call($this, colorMapL1, 0);
                                    setAlpha.call($this, colorMapL1, 100);
                                    setImgLoc.call($this, colorMapL2, 260);
                                    setAlpha.call($this, colorMapL2, 100);
                                    setBG.call($this, colorBarDiv, 'transparent');
                                    setImgLoc.call($this, colorBarL1, 0);
                                    setAlpha.call($this, colorBarL1, 100);
                                    setImgLoc.call($this, colorBarL2, 260);
                                    setAlpha.call($this, colorBarL2, 100);
                                    setImgLoc.call($this, colorBarL3, 260);
                                    setAlpha.call($this, colorBarL3, 100);
                                    setImgLoc.call($this, colorBarL4, 260);
                                    setAlpha.call($this, colorBarL4, 100);
                                    setImgLoc.call($this, colorBarL6, 260);
                                    setAlpha.call($this, colorBarL6, 100)
                                }, 0);
                                colorMap.range('all', {
                                    minX: 0, maxX: 100, minY: 0, maxY: 100
                                });
                                colorBar.range('rangeY', {
                                    minY: 0, maxY: 360
                                });
                                if (active.val('ahex') == null)
                                    break;
                                colorMap.val('xy', {
                                    x: active.val('s'), y: 100 - active.val('v')
                                }, colorMap);
                                colorBar.val('y', 360 - active.val('h'), colorBar);
                                break;
                            case's':
                                setTimeout(function()
                                {
                                    setBG.call($this, colorMapDiv, 'transparent');
                                    setImgLoc.call($this, colorMapL1, -260);
                                    setImgLoc.call($this, colorMapL2, -520);
                                    setImgLoc.call($this, colorBarL1, -260);
                                    setImgLoc.call($this, colorBarL2, -520);
                                    setImgLoc.call($this, colorBarL6, 260);
                                    setAlpha.call($this, colorBarL6, 100)
                                }, 0);
                                colorMap.range('all', {
                                    minX: 0, maxX: 360, minY: 0, maxY: 100
                                });
                                colorBar.range('rangeY', {
                                    minY: 0, maxY: 100
                                });
                                if (active.val('ahex') == null)
                                    break;
                                colorMap.val('xy', {
                                    x: active.val('h'), y: 100 - active.val('v')
                                }, colorMap);
                                colorBar.val('y', 100 - active.val('s'), colorBar);
                                break;
                            case'v':
                                setTimeout(function()
                                {
                                    setBG.call($this, colorMapDiv, '000000');
                                    setImgLoc.call($this, colorMapL1, -780);
                                    setImgLoc.call($this, colorMapL2, 260);
                                    setBG.call($this, colorBarDiv, hex);
                                    setImgLoc.call($this, colorBarL1, -520);
                                    setImgLoc.call($this, colorBarL2, 260);
                                    setAlpha.call($this, colorBarL2, 100);
                                    setImgLoc.call($this, colorBarL6, 260);
                                    setAlpha.call($this, colorBarL6, 100)
                                }, 0);
                                colorMap.range('all', {
                                    minX: 0, maxX: 360, minY: 0, maxY: 100
                                });
                                colorBar.range('rangeY', {
                                    minY: 0, maxY: 100
                                });
                                if (active.val('ahex') == null)
                                    break;
                                colorMap.val('xy', {
                                    x: active.val('h'), y: 100 - active.val('s')
                                }, colorMap);
                                colorBar.val('y', 100 - active.val('v'), colorBar);
                                break;
                            case'r':
                                rgbMap = -1040;
                                rgbBar = -780;
                                colorMap.range('all', {
                                    minX: 0, maxX: 255, minY: 0, maxY: 255
                                });
                                colorBar.range('rangeY', {
                                    minY: 0, maxY: 255
                                });
                                if (active.val('ahex') == null)
                                    break;
                                colorMap.val('xy', {
                                    x: active.val('b'), y: 255 - active.val('g')
                                }, colorMap);
                                colorBar.val('y', 255 - active.val('r'), colorBar);
                                break;
                            case'g':
                                rgbMap = -1560;
                                rgbBar = -1820;
                                colorMap.range('all', {
                                    minX: 0, maxX: 255, minY: 0, maxY: 255
                                });
                                colorBar.range('rangeY', {
                                    minY: 0, maxY: 255
                                });
                                if (active.val('ahex') == null)
                                    break;
                                colorMap.val('xy', {
                                    x: active.val('b'), y: 255 - active.val('r')
                                }, colorMap);
                                colorBar.val('y', 255 - active.val('g'), colorBar);
                                break;
                            case'b':
                                rgbMap = -2080;
                                rgbBar = -2860;
                                colorMap.range('all', {
                                    minX: 0, maxX: 255, minY: 0, maxY: 255
                                });
                                colorBar.range('rangeY', {
                                    minY: 0, maxY: 255
                                });
                                if (active.val('ahex') == null)
                                    break;
                                colorMap.val('xy', {
                                    x: active.val('r'), y: 255 - active.val('g')
                                }, colorMap);
                                colorBar.val('y', 255 - active.val('b'), colorBar);
                                break;
                            case'a':
                                setTimeout(function()
                                {
                                    setBG.call($this, colorMapDiv, 'transparent');
                                    setImgLoc.call($this, colorMapL1, -260);
                                    setImgLoc.call($this, colorMapL2, -520);
                                    setImgLoc.call($this, colorBarL1, 260);
                                    setImgLoc.call($this, colorBarL2, 260);
                                    setAlpha.call($this, colorBarL2, 100);
                                    setImgLoc.call($this, colorBarL6, 0);
                                    setAlpha.call($this, colorBarL6, 100)
                                }, 0);
                                colorMap.range('all', {
                                    minX: 0, maxX: 360, minY: 0, maxY: 100
                                });
                                colorBar.range('rangeY', {
                                    minY: 0, maxY: 255
                                });
                                if (active.val('ahex') == null)
                                    break;
                                colorMap.val('xy', {
                                    x: active.val('h'), y: 100 - active.val('v')
                                }, colorMap);
                                colorBar.val('y', 255 - active.val('a'), colorBar);
                                break;
                            default:
                                throw('Invalid Mode');
                                break
                        }
                        switch (colorMode)
                        {
                            case'h':
                                break;
                            case's':
                            case'v':
                            case'a':
                                setTimeout(function()
                                {
                                    setAlpha.call($this, colorMapL1, 100);
                                    setAlpha.call($this, colorBarL1, 100);
                                    setImgLoc.call($this, colorBarL3, 260);
                                    setAlpha.call($this, colorBarL3, 100);
                                    setImgLoc.call($this, colorBarL4, 260);
                                    setAlpha.call($this, colorBarL4, 100)
                                }, 0);
                                break;
                            case'r':
                            case'g':
                            case'b':
                                setTimeout(function()
                                {
                                    setBG.call($this, colorMapDiv, 'transparent');
                                    setBG.call($this, colorBarDiv, 'transparent');
                                    setAlpha.call($this, colorBarL1, 100);
                                    setAlpha.call($this, colorMapL1, 100);
                                    setImgLoc.call($this, colorMapL1, rgbMap);
                                    setImgLoc.call($this, colorMapL2, rgbMap - 260);
                                    setImgLoc.call($this, colorBarL1, rgbBar - 780);
                                    setImgLoc.call($this, colorBarL2, rgbBar - 520);
                                    setImgLoc.call($this, colorBarL3, rgbBar);
                                    setImgLoc.call($this, colorBarL4, rgbBar - 260);
                                    setImgLoc.call($this, colorBarL6, 260);
                                    setAlpha.call($this, colorBarL6, 100)
                                }, 0);
                                break
                        }
                        if (active.val('ahex') == null)
                            return;
                        activeColorChanged.call($this, active)
                    },
                    activeColorChanged = function(ui, context)
                    {
                        if (context == null || (context != colorBar && context != colorMap))
                            positionMapAndBarArrows.call($this, ui, context);
                        setTimeout(function()
                        {
                            updatePreview.call($this, ui);
                            updateMapVisuals.call($this, ui);
                            updateBarVisuals.call($this, ui)
                        }, 0)
                    },
                    mapValueChanged = function(ui, context)
                    {
                        var active = color.active;
                        if (context != colorMap && active.val() == null)
                            return;
                        var xy = ui.val('all');
                        switch (settings.color.mode)
                        {
                            case'h':
                                active.val('sv', {
                                    s: xy.x, v: 100 - xy.y
                                }, context);
                                break;
                            case's':
                            case'a':
                                active.val('hv', {
                                    h: xy.x, v: 100 - xy.y
                                }, context);
                                break;
                            case'v':
                                active.val('hs', {
                                    h: xy.x, s: 100 - xy.y
                                }, context);
                                break;
                            case'r':
                                active.val('gb', {
                                    g: 255 - xy.y, b: xy.x
                                }, context);
                                break;
                            case'g':
                                active.val('rb', {
                                    r: 255 - xy.y, b: xy.x
                                }, context);
                                break;
                            case'b':
                                active.val('rg', {
                                    r: xy.x, g: 255 - xy.y
                                }, context);
                                break
                        }
                    },
                    colorBarValueChanged = function(ui, context)
                    {
                        var active = color.active;
                        if (context != colorBar && active.val() == null)
                            return;
                        switch (settings.color.mode)
                        {
                            case'h':
                                active.val('h', {h: 360 - ui.val('y')}, context);
                                break;
                            case's':
                                active.val('s', {s: 100 - ui.val('y')}, context);
                                break;
                            case'v':
                                active.val('v', {v: 100 - ui.val('y')}, context);
                                break;
                            case'r':
                                active.val('r', {r: 255 - ui.val('y')}, context);
                                break;
                            case'g':
                                active.val('g', {g: 255 - ui.val('y')}, context);
                                break;
                            case'b':
                                active.val('b', {b: 255 - ui.val('y')}, context);
                                break;
                            case'a':
                                active.val('a', 255 - ui.val('y'), context);
                                break
                        }
                    },
                    positionMapAndBarArrows = function(ui, context)
                    {
                        if (context != colorMap)
                        {
                            switch (settings.color.mode)
                            {
                                case'h':
                                    var sv = ui.val('sv');
                                    colorMap.val('xy', {
                                        x: sv != null ? sv.s : 100, y: 100 - (sv != null ? sv.v : 100)
                                    }, context);
                                    break;
                                case's':
                                case'a':
                                    var hv = ui.val('hv');
                                    colorMap.val('xy', {
                                        x: hv && hv.h || 0, y: 100 - (hv != null ? hv.v : 100)
                                    }, context);
                                    break;
                                case'v':
                                    var hs = ui.val('hs');
                                    colorMap.val('xy', {
                                        x: hs && hs.h || 0, y: 100 - (hs != null ? hs.s : 100)
                                    }, context);
                                    break;
                                case'r':
                                    var bg = ui.val('bg');
                                    colorMap.val('xy', {
                                        x: bg && bg.b || 0, y: 255 - (bg && bg.g || 0)
                                    }, context);
                                    break;
                                case'g':
                                    var br = ui.val('br');
                                    colorMap.val('xy', {
                                        x: br && br.b || 0, y: 255 - (br && br.r || 0)
                                    }, context);
                                    break;
                                case'b':
                                    var rg = ui.val('rg');
                                    colorMap.val('xy', {
                                        x: rg && rg.r || 0, y: 255 - (rg && rg.g || 0)
                                    }, context);
                                    break
                            }
                        }
                        if (context != colorBar)
                        {
                            switch (settings.color.mode)
                            {
                                case'h':
                                    colorBar.val('y', 360 - (ui.val('h') || 0), context);
                                    break;
                                case's':
                                    var s = ui.val('s');
                                    colorBar.val('y', 100 - (s != null ? s : 100), context);
                                    break;
                                case'v':
                                    var v = ui.val('v');
                                    colorBar.val('y', 100 - (v != null ? v : 100), context);
                                    break;
                                case'r':
                                    colorBar.val('y', 255 - (ui.val('r') || 0), context);
                                    break;
                                case'g':
                                    colorBar.val('y', 255 - (ui.val('g') || 0), context);
                                    break;
                                case'b':
                                    colorBar.val('y', 255 - (ui.val('b') || 0), context);
                                    break;
                                case'a':
                                    var a = ui.val('a');
                                    colorBar.val('y', 255 - (a != null ? a : 255), context);
                                    break
                            }
                        }
                    },
                    updatePreview = function(ui)
                    {
                        try
                        {
                            var all = ui.val('all');
                            activePreview.css({backgroundColor: all && '#' + all.hex || 'transparent'});
                            setAlpha.call($this, activePreview, all && Math.precision((all.a * 100) / 255, 4) || 0)
                        }
                        catch(e) {}
                    },
                    updateMapVisuals = function(ui)
                    {
                        switch (settings.color.mode)
                        {
                            case'h':
                                setBG.call($this, colorMapDiv, new Color({
                                    h: ui.val('h') || 0, s: 100, v: 100
                                }).val('hex'));
                                break;
                            case's':
                            case'a':
                                var s = ui.val('s');
                                setAlpha.call($this, colorMapL2, 100 - (s != null ? s : 100));
                                break;
                            case'v':
                                var v = ui.val('v');
                                setAlpha.call($this, colorMapL1, v != null ? v : 100);
                                break;
                            case'r':
                                setAlpha.call($this, colorMapL2, Math.precision((ui.val('r') || 0) / 255 * 100, 4));
                                break;
                            case'g':
                                setAlpha.call($this, colorMapL2, Math.precision((ui.val('g') || 0) / 255 * 100, 4));
                                break;
                            case'b':
                                setAlpha.call($this, colorMapL2, Math.precision((ui.val('b') || 0) / 255 * 100));
                                break
                        }
                        var a = ui.val('a');
                        setAlpha.call($this, colorMapL3, Math.precision(((255 - (a || 0)) * 100) / 255, 4))
                    },
                    updateBarVisuals = function(ui)
                    {
                        switch (settings.color.mode)
                        {
                            case'h':
                                var a = ui.val('a');
                                setAlpha.call($this, colorBarL5, Math.precision(((255 - (a || 0)) * 100) / 255, 4));
                                break;
                            case's':
                                var hva = ui.val('hva'),
                                    saturatedColor = new Color({
                                        h: hva && hva.h || 0, s: 100, v: hva != null ? hva.v : 100
                                    });
                                setBG.call($this, colorBarDiv, saturatedColor.val('hex'));
                                setAlpha.call($this, colorBarL2, 100 - (hva != null ? hva.v : 100));
                                setAlpha.call($this, colorBarL5, Math.precision(((255 - (hva && hva.a || 0)) * 100) / 255, 4));
                                break;
                            case'v':
                                var hsa = ui.val('hsa'),
                                    valueColor = new Color({
                                        h: hsa && hsa.h || 0, s: hsa != null ? hsa.s : 100, v: 100
                                    });
                                setBG.call($this, colorBarDiv, valueColor.val('hex'));
                                setAlpha.call($this, colorBarL5, Math.precision(((255 - (hsa && hsa.a || 0)) * 100) / 255, 4));
                                break;
                            case'r':
                            case'g':
                            case'b':
                                var hValue = 0,
                                    vValue = 0,
                                    rgba = ui.val('rgba');
                                if (settings.color.mode == 'r')
                                {
                                    hValue = rgba && rgba.b || 0;
                                    vValue = rgba && rgba.g || 0
                                }
                                else if (settings.color.mode == 'g')
                                {
                                    hValue = rgba && rgba.b || 0;
                                    vValue = rgba && rgba.r || 0
                                }
                                else if (settings.color.mode == 'b')
                                {
                                    hValue = rgba && rgba.r || 0;
                                    vValue = rgba && rgba.g || 0
                                }
                                var middle = vValue > hValue ? hValue : vValue;
                                setAlpha.call($this, colorBarL2, hValue > vValue ? Math.precision(((hValue - vValue) / (255 - vValue)) * 100, 4) : 0);
                                setAlpha.call($this, colorBarL3, vValue > hValue ? Math.precision(((vValue - hValue) / (255 - hValue)) * 100, 4) : 0);
                                setAlpha.call($this, colorBarL4, Math.precision((middle / 255) * 100, 4));
                                setAlpha.call($this, colorBarL5, Math.precision(((255 - (rgba && rgba.a || 0)) * 100) / 255, 4));
                                break;
                            case'a':
                                var a = ui.val('a');
                                setBG.call($this, colorBarDiv, ui.val('hex') || '000000');
                                setAlpha.call($this, colorBarL5, a != null ? 0 : 100);
                                setAlpha.call($this, colorBarL6, a != null ? 100 : 0);
                                break
                        }
                    },
                    setBG = function(el, c)
                    {
                        el.css({backgroundColor: c && c.length == 6 && '#' + c || 'transparent'})
                    },
                    setImg = function(img, src)
                    {
                        if (isLessThanIE7 && (src.indexOf('AlphaBar.png') != -1 || src.indexOf('Bars.png') != -1 || src.indexOf('Maps.png') != -1))
                        {
                            img.attr('pngSrc', src);
                            img.css({
                                backgroundImage: 'none', filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'' + src + '\', sizingMethod=\'scale\')'
                            })
                        }
                        else
                            img.css({backgroundImage: 'url(\'' + src + '\')'})
                    },
                    setImgLoc = function(img, y)
                    {
                        img.css({top: y + 'px'})
                    },
                    setAlpha = function(obj, alpha)
                    {
                        obj.css({visibility: alpha > 0 ? 'visible' : 'hidden'});
                        if (alpha > 0 && alpha < 100)
                        {
                            if (isLessThanIE7)
                            {
                                var src = obj.attr('pngSrc');
                                if (src != null && (src.indexOf('AlphaBar.png') != -1 || src.indexOf('Bars.png') != -1 || src.indexOf('Maps.png') != -1))
                                    obj.css({filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'' + src + '\', sizingMethod=\'scale\') progid:DXImageTransform.Microsoft.Alpha(opacity=' + alpha + ')'});
                                else
                                    obj.css({opacity: Math.precision(alpha / 100, 4)})
                            }
                            else
                                obj.css({opacity: Math.precision(alpha / 100, 4)})
                        }
                        else if (alpha == 0 || alpha == 100)
                        {
                            if (isLessThanIE7)
                            {
                                var src = obj.attr('pngSrc');
                                if (src != null && (src.indexOf('AlphaBar.png') != -1 || src.indexOf('Bars.png') != -1 || src.indexOf('Maps.png') != -1))
                                    obj.css({filter: 'progid:DXImageTransform.Microsoft.AlphaImageLoader(src=\'' + src + '\', sizingMethod=\'scale\')'});
                                else
                                    obj.css({opacity: ''})
                            }
                            else
                                obj.css({opacity: ''})
                        }
                    },
                    revertColor = function()
                    {
                        color.active.val('ahex', color.current.val('ahex'))
                    },
                    commitColor = function()
                    {
                        color.current.val('ahex', color.active.val('ahex'))
                    },
                    radioClicked = function(e)
                    {
                        $(this).parents('tbody:first').find('input:radio[value!="' + e.target.value + '"]').removeAttr('checked');
                        setColorMode.call($this, e.target.value)
                    },
                    currentClicked = function()
                    {
                        revertColor.call($this)
                    },
                    cancelClicked = function()
                    {
                        revertColor.call($this);
                        settings.window.expandable && hide.call($this);
                        $.isFunction(cancelCallback) && cancelCallback.call($this, color.active, cancelButton)
                    },
                    okClicked = function()
                    {
                        commitColor.call($this);
                        settings.window.expandable && hide.call($this);
                        $.isFunction(commitCallback) && commitCallback.call($this, color.active, okButton)
                    },
                    iconImageClicked = function()
                    {
                        show.call($this)
                    },
                    currentColorChanged = function(ui, context)
                    {
                        var hex = ui.val('hex');
                        currentPreview.css({backgroundColor: hex && '#' + hex || 'transparent'});
                        setAlpha.call($this, currentPreview, Math.precision(((ui.val('a') || 0) * 100) / 255, 4))
                    },
                    expandableColorChanged = function(ui, context)
                    {
                        var hex = ui.val('hex');
                        var va = ui.val('va');
                        iconColor.css({backgroundColor: hex && '#' + hex || 'transparent'});
                        setAlpha.call($this, iconAlpha, Math.precision(((255 - (va && va.a || 0)) * 100) / 255, 4));
                        if (settings.window.bindToInput && settings.window.updateInputColor)
                            settings.window.input.css({
                                backgroundColor: hex && '#' + hex || 'transparent', color: va == null || va.v > 75 ? '#000000' : '#ffffff'
                            })
                    },
                    moveBarMouseDown = function(e)
                    {
                        var element = settings.window.element,
                            page = settings.window.page;
                        elementStartX = parseInt(container.css('left'));
                        elementStartY = parseInt(container.css('top'));
                        pageStartX = e.pageX;
                        pageStartY = e.pageY;
                        $(document).bind('mousemove', documentMouseMove).bind('mouseup', documentMouseUp);
                        e.preventDefault()
                    },
                    documentMouseMove = function(e)
                    {
                        container.css({
                            left: elementStartX - (pageStartX - e.pageX) + 'px', top: elementStartY - (pageStartY - e.pageY) + 'px'
                        });
                        if (settings.window.expandable && !$.support.boxModel)
                            container.prev().css({
                                left: container.css("left"), top: container.css("top")
                            });
                        e.stopPropagation();
                        e.preventDefault();
                        return false
                    },
                    documentMouseUp = function(e)
                    {
                        $(document).unbind('mousemove', documentMouseMove).unbind('mouseup', documentMouseUp);
                        e.stopPropagation();
                        e.preventDefault();
                        return false
                    },
                    quickPickClicked = function(e)
                    {
                        e.preventDefault();
                        e.stopPropagation();
                        color.active.val('ahex', $(this).attr('title') || null, e.target);
                        return false
                    },
                    commitCallback = $.isFunction($arguments[1]) && $arguments[1] || null,
                    liveCallback = $.isFunction($arguments[2]) && $arguments[2] || null,
                    cancelCallback = $.isFunction($arguments[3]) && $arguments[3] || null,
                    show = function()
                    {
                        color.current.val('ahex', color.active.val('ahex'));
                        var attachIFrame = function()
                            {
                                if (!settings.window.expandable || $.support.boxModel)
                                    return;
                                var table = container.find('table:first');
                                container.before('<iframe/>');
                                container.prev().css({
                                    width: table.width(), height: container.height(), opacity: 0, position: 'absolute', left: container.css("left"), top: container.css("top")
                                })
                            };
                        if (settings.window.expandable)
                        {
                            $(document.body).children('div.jPicker.Container').css({zIndex: 10});
                            container.css({zIndex: 20})
                        }
                        switch (settings.window.effects.type)
                        {
                            case'fade':
                                container.fadeIn(settings.window.effects.speed.show, attachIFrame);
                                break;
                            case'slide':
                                container.slideDown(settings.window.effects.speed.show, attachIFrame);
                                break;
                            case'show':
                            default:
                                container.show(settings.window.effects.speed.show, attachIFrame);
                                break
                        }
                    },
                    hide = function()
                    {
                        var removeIFrame = function()
                            {
                                if (settings.window.expandable)
                                    container.css({zIndex: 10});
                                if (!settings.window.expandable || $.support.boxModel)
                                    return;
                                container.prev().remove()
                            };
                        switch (settings.window.effects.type)
                        {
                            case'fade':
                                container.fadeOut(settings.window.effects.speed.hide, removeIFrame);
                                break;
                            case'slide':
                                container.slideUp(settings.window.effects.speed.hide, removeIFrame);
                                break;
                            case'show':
                            default:
                                container.hide(settings.window.effects.speed.hide, removeIFrame);
                                break
                        }
                    },
                    initialize = function()
                    {
                        var win = settings.window,
                            popup = win.expandable ? $($this).next().find('.Container:first') : null;
                        container = win.expandable ? $('<div/>') : $($this);
                        container.addClass('jPicker Container');
                        if (win.expandable)
                            container.hide();
                        container.get(0).onselectstart = function(event)
                        {
                            if (event.target.nodeName.toLowerCase() !== 'input')
                                return false
                        };
                        var all = color.active.val('all');
                        if (win.alphaPrecision < 0)
                            win.alphaPrecision = 0;
                        else if (win.alphaPrecision > 2)
                            win.alphaPrecision = 2;
                        var controlHtml = '<table class="jPicker" cellpadding="0" cellspacing="0"><tbody>' + (win.expandable ? '<tr><td class="Move" colspan="5">&nbsp;</td></tr>' : '') + '<tr><td rowspan="9"><h2 class="Title">' + (win.title || localization.text.title) + '</h2><div class="Map"><span class="Map1">&nbsp;</span><span class="Map2">&nbsp;</span><span class="Map3">&nbsp;</span><img src="' + images.clientPath + images.colorMap.arrow.file + '" class="Arrow"/></div></td><td rowspan="9"><div class="Bar"><span class="Map1">&nbsp;</span><span class="Map2">&nbsp;</span><span class="Map3">&nbsp;</span><span class="Map4">&nbsp;</span><span class="Map5">&nbsp;</span><span class="Map6">&nbsp;</span><img src="' + images.clientPath + images.colorBar.arrow.file + '" class="Arrow"/></div></td><td colspan="2" class="Preview">' + localization.text.newColor + '<div><span class="Active" title="' + localization.tooltips.colors.newColor + '">&nbsp;</span><span class="Current" title="' + localization.tooltips.colors.currentColor + '">&nbsp;</span></div>' + localization.text.currentColor + '</td><td rowspan="9" class="Button"><input type="button" class="Ok" value="' + localization.text.ok + '" title="' + localization.tooltips.buttons.ok + '"/><input type="button" class="Cancel" value="' + localization.text.cancel + '" title="' + localization.tooltips.buttons.cancel + '"/><hr/><div class="Grid">&nbsp;</div></td></tr><tr class="Hue"><td class="Radio"><label title="' + localization.tooltips.hue.radio + '"><input type="radio" value="h"' + (settings.color.mode == 'h' ? ' checked="checked"' : '') + '/>H:</label></td><td class="Text"><input type="text" maxlength="3" value="' + (all != null ? all.h : '') + '" title="' + localization.tooltips.hue.textbox + '"/>&nbsp;&deg;</td></tr><tr class="Saturation"><td class="Radio"><label title="' + localization.tooltips.saturation.radio + '"><input type="radio" value="s"' + (settings.color.mode == 's' ? ' checked="checked"' : '') + '/>S:</label></td><td class="Text"><input type="text" maxlength="3" value="' + (all != null ? all.s : '') + '" title="' + localization.tooltips.saturation.textbox + '"/>&nbsp;%</td></tr><tr class="Value"><td class="Radio"><label title="' + localization.tooltips.value.radio + '"><input type="radio" value="v"' + (settings.color.mode == 'v' ? ' checked="checked"' : '') + '/>V:</label><br/><br/></td><td class="Text"><input type="text" maxlength="3" value="' + (all != null ? all.v : '') + '" title="' + localization.tooltips.value.textbox + '"/>&nbsp;%<br/><br/></td></tr><tr class="Red"><td class="Radio"><label title="' + localization.tooltips.red.radio + '"><input type="radio" value="r"' + (settings.color.mode == 'r' ? ' checked="checked"' : '') + '/>R:</label></td><td class="Text"><input type="text" maxlength="3" value="' + (all != null ? all.r : '') + '" title="' + localization.tooltips.red.textbox + '"/></td></tr><tr class="Green"><td class="Radio"><label title="' + localization.tooltips.green.radio + '"><input type="radio" value="g"' + (settings.color.mode == 'g' ? ' checked="checked"' : '') + '/>G:</label></td><td class="Text"><input type="text" maxlength="3" value="' + (all != null ? all.g : '') + '" title="' + localization.tooltips.green.textbox + '"/></td></tr><tr class="Blue"><td class="Radio"><label title="' + localization.tooltips.blue.radio + '"><input type="radio" value="b"' + (settings.color.mode == 'b' ? ' checked="checked"' : '') + '/>B:</label></td><td class="Text"><input type="text" maxlength="3" value="' + (all != null ? all.b : '') + '" title="' + localization.tooltips.blue.textbox + '"/></td></tr><tr class="Alpha"><td class="Radio">' + (win.alphaSupport ? '<label title="' + localization.tooltips.alpha.radio + '"><input type="radio" value="a"' + (settings.color.mode == 'a' ? ' checked="checked"' : '') + '/>A:</label>' : '&nbsp;') + '</td><td class="Text">' + (win.alphaSupport ? '<input type="text" maxlength="' + (3 + win.alphaPrecision) + '" value="' + (all != null ? Math.precision((all.a * 100) / 255, win.alphaPrecision) : '') + '" title="' + localization.tooltips.alpha.textbox + '"/>&nbsp;%' : '&nbsp;') + '</td></tr><tr class="Hex"><td colspan="2" class="Text"><label title="' + localization.tooltips.hex.textbox + '">#:<input type="text" maxlength="6" class="Hex" value="' + (all != null ? all.hex : '') + '"/></label>' + (win.alphaSupport ? '<input type="text" maxlength="2" class="AHex" value="' + (all != null ? all.ahex.substring(6) : '') + '" title="' + localization.tooltips.hex.alpha + '"/></td>' : '&nbsp;') + '</tr></tbody></table>';
                        if (win.expandable)
                        {
                            container.html(controlHtml);
                            if ($(document.body).children('div.jPicker.Container').length == 0)
                                $(document.body).prepend(container);
                            else
                                $(document.body).children('div.jPicker.Container:last').after(container);
                            container.mousedown(function()
                            {
                                $(document.body).children('div.jPicker.Container').css({zIndex: 10});
                                container.css({zIndex: 20})
                            });
                            container.css({
                                left: win.position.x == 'left' ? (popup.offset().left - 530 - (win.position.y == 'center' ? 25 : 0)) + 'px' : win.position.x == 'center' ? (popup.offset().left - 260) + 'px' : win.position.x == 'right' ? (popup.offset().left - 10 + (win.position.y == 'center' ? 25 : 0)) + 'px' : win.position.x == 'screenCenter' ? (($(document).width() >> 1) - 260) + 'px' : (popup.offset().left + parseInt(win.position.x)) + 'px', position: 'absolute', top: win.position.y == 'top' ? (popup.offset().top - 312) + 'px' : win.position.y == 'center' ? (popup.offset().top - 156) + 'px' : win.position.y == 'bottom' ? (popup.offset().top + 25) + 'px' : (popup.offset().top + parseInt(win.position.y)) + 'px'
                            })
                        }
                        else
                        {
                            container = $($this);
                            container.html(controlHtml)
                        }
                        var tbody = container.find('tbody:first');
                        colorMapDiv = tbody.find('div.Map:first');
                        colorBarDiv = tbody.find('div.Bar:first');
                        var MapMaps = colorMapDiv.find('span'),
                            BarMaps = colorBarDiv.find('span');
                        colorMapL1 = MapMaps.filter('.Map1:first');
                        colorMapL2 = MapMaps.filter('.Map2:first');
                        colorMapL3 = MapMaps.filter('.Map3:first');
                        colorBarL1 = BarMaps.filter('.Map1:first');
                        colorBarL2 = BarMaps.filter('.Map2:first');
                        colorBarL3 = BarMaps.filter('.Map3:first');
                        colorBarL4 = BarMaps.filter('.Map4:first');
                        colorBarL5 = BarMaps.filter('.Map5:first');
                        colorBarL6 = BarMaps.filter('.Map6:first');
                        colorMap = new Slider(colorMapDiv, {
                            map: {
                                width: images.colorMap.width, height: images.colorMap.height
                            }, arrow: {
                                    image: images.clientPath + images.colorMap.arrow.file, width: images.colorMap.arrow.width, height: images.colorMap.arrow.height
                                }
                        });
                        colorMap.bind(mapValueChanged);
                        colorBar = new Slider(colorBarDiv, {
                            map: {
                                width: images.colorBar.width, height: images.colorBar.height
                            }, arrow: {
                                    image: images.clientPath + images.colorBar.arrow.file, width: images.colorBar.arrow.width, height: images.colorBar.arrow.height
                                }
                        });
                        colorBar.bind(colorBarValueChanged);
                        colorPicker = new ColorValuePicker(tbody, color.active, win.expandable && win.bindToInput ? win.input : null, win.alphaPrecision);
                        var hex = all != null ? all.hex : null,
                            preview = tbody.find('.Preview'),
                            button = tbody.find('.Button');
                        activePreview = preview.find('.Active:first').css({backgroundColor: hex && '#' + hex || 'transparent'});
                        currentPreview = preview.find('.Current:first').css({backgroundColor: hex && '#' + hex || 'transparent'}).bind('click', currentClicked);
                        setAlpha.call($this, currentPreview, Math.precision(color.current.val('a') * 100) / 255, 4);
                        okButton = button.find('.Ok:first').bind('click', okClicked);
                        cancelButton = button.find('.Cancel:first').bind('click', cancelClicked);
                        grid = button.find('.Grid:first');
                        setTimeout(function()
                        {
                            setImg.call($this, colorMapL1, images.clientPath + 'Maps.png');
                            setImg.call($this, colorMapL2, images.clientPath + 'Maps.png');
                            setImg.call($this, colorMapL3, images.clientPath + 'map-opacity.png');
                            setImg.call($this, colorBarL1, images.clientPath + 'Bars.png');
                            setImg.call($this, colorBarL2, images.clientPath + 'Bars.png');
                            setImg.call($this, colorBarL3, images.clientPath + 'Bars.png');
                            setImg.call($this, colorBarL4, images.clientPath + 'Bars.png');
                            setImg.call($this, colorBarL5, images.clientPath + 'bar-opacity.png');
                            setImg.call($this, colorBarL6, images.clientPath + 'AlphaBar.png');
                            setImg.call($this, preview.find('div:first'), images.clientPath + 'preview-opacity.png')
                        }, 0);
                        tbody.find('td.Radio input').bind('click', radioClicked);
                        if (color.quickList && color.quickList.length > 0)
                        {
                            var html = '';
                            for (i = 0; i < color.quickList.length; i++)
                            {
                                if ((typeof(color.quickList[i])).toString().toLowerCase() == 'string')
                                    color.quickList[i] = new Color({hex: color.quickList[i]});
                                var alpha = color.quickList[i].val('a');
                                var ahex = color.quickList[i].val('ahex');
                                if (!win.alphaSupport && ahex)
                                    ahex = ahex.substring(0, 6) + 'ff';
                                var quickHex = color.quickList[i].val('hex');
                                if (!ahex)
                                    ahex = "00000000";
                                html += '<span class="QuickColor"' + (ahex && ' title="#' + ahex + '"' || 'none') + ' style="background-color:' + (quickHex && '#' + quickHex || '') + ';' + (quickHex ? '' : 'background-image:url(' + images.clientPath + 'NoColor.png)') + (win.alphaSupport && alpha && alpha < 255 ? ';opacity:' + Math.precision(alpha / 255, 4) + ';filter:Alpha(opacity=' + Math.precision(alpha / 2.55, 4) + ')' : '') + '">&nbsp;</span>'
                            }
                            setImg.call($this, grid, images.clientPath + 'bar-opacity.png');
                            grid.html(html);
                            grid.find('.QuickColor').click(quickPickClicked)
                        }
                        setColorMode.call($this, settings.color.mode);
                        color.active.bind(activeColorChanged);
                        $.isFunction(liveCallback) && color.active.bind(liveCallback);
                        color.current.bind(currentColorChanged);
                        if (win.expandable)
                        {
                            $this.icon = popup.parents('.Icon:first');
                            iconColor = $this.icon.find('.Color:first').css({backgroundColor: hex && '#' + hex || 'transparent'});
                            iconAlpha = $this.icon.find('.Alpha:first');
                            setImg.call($this, iconAlpha, images.clientPath + 'bar-opacity.png');
                            setAlpha.call($this, iconAlpha, Math.precision(((255 - (all != null ? all.a : 0)) * 100) / 255, 4));
                            iconImage = $this.icon.find('.Image:first').css({backgroundImage: 'url(\'' + images.clientPath + images.picker.file + '\')'}).bind('click', iconImageClicked);
                            if (win.bindToInput && win.updateInputColor)
                                win.input.css({
                                    backgroundColor: hex && '#' + hex || 'transparent', color: all == null || all.v > 75 ? '#000000' : '#ffffff'
                                });
                            moveBar = tbody.find('.Move:first').bind('mousedown', moveBarMouseDown);
                            color.active.bind(expandableColorChanged)
                        }
                        else
                            show.call($this)
                    },
                    destroy = function()
                    {
                        container.find('td.Radio input').unbind('click', radioClicked);
                        currentPreview.unbind('click', currentClicked);
                        cancelButton.unbind('click', cancelClicked);
                        okButton.unbind('click', okClicked);
                        if (settings.window.expandable)
                        {
                            iconImage.unbind('click', iconImageClicked);
                            moveBar.unbind('mousedown', moveBarMouseDown);
                            $this.icon = null
                        }
                        container.find('.QuickColor').unbind('click', quickPickClicked);
                        colorMapDiv = null;
                        colorBarDiv = null;
                        colorMapL1 = null;
                        colorMapL2 = null;
                        colorMapL3 = null;
                        colorBarL1 = null;
                        colorBarL2 = null;
                        colorBarL3 = null;
                        colorBarL4 = null;
                        colorBarL5 = null;
                        colorBarL6 = null;
                        colorMap.destroy();
                        colorMap = null;
                        colorBar.destroy();
                        colorBar = null;
                        colorPicker.destroy();
                        colorPicker = null;
                        activePreview = null;
                        currentPreview = null;
                        okButton = null;
                        cancelButton = null;
                        grid = null;
                        commitCallback = null;
                        cancelCallback = null;
                        liveCallback = null;
                        container.html('');
                        for (i = 0; i < List.length; i++)
                            if (List[i] == $this)
                                List.splice(i, 1)
                    },
                    images = settings.images,
                    localization = settings.localization,
                    color = {
                        active: (typeof(settings.color.active)).toString().toLowerCase() == 'string' ? new Color({ahex: !settings.window.alphaSupport && settings.color.active ? settings.color.active.substring(0, 6) + 'ff' : settings.color.active}) : new Color({ahex: !settings.window.alphaSupport && settings.color.active.val('ahex') ? settings.color.active.val('ahex').substring(0, 6) + 'ff' : settings.color.active.val('ahex')}), current: (typeof(settings.color.active)).toString().toLowerCase() == 'string' ? new Color({ahex: !settings.window.alphaSupport && settings.color.active ? settings.color.active.substring(0, 6) + 'ff' : settings.color.active}) : new Color({ahex: !settings.window.alphaSupport && settings.color.active.val('ahex') ? settings.color.active.val('ahex').substring(0, 6) + 'ff' : settings.color.active.val('ahex')}), quickList: settings.color.quickList
                    };
                $.extend(true, $this, {
                    commitCallback: commitCallback, liveCallback: liveCallback, cancelCallback: cancelCallback, color: color, show: show, hide: hide, destroy: destroy
                });
                List.push($this);
                setTimeout(function()
                {
                    initialize.call($this)
                }, 0)
            })
    };
    $.fn.jPicker.defaults = {
        window: {
            title: null, effects: {
                    type: 'slide', speed: {
                            show: 'slow', hide: 'fast'
                        }
                }, position: {
                    x: 'screenCenter', y: 'top'
                }, expandable: false, liveUpdate: true, alphaSupport: false, alphaPrecision: 0, updateInputColor: true
        }, color: {
                mode: 'h', active: new Color({ahex: '#ffcc00ff'}), quickList: [new Color({
                            h: 360, s: 33, v: 100
                        }), new Color({
                            h: 360, s: 66, v: 100
                        }), new Color({
                            h: 360, s: 100, v: 100
                        }), new Color({
                            h: 360, s: 100, v: 75
                        }), new Color({
                            h: 360, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 100
                        }), new Color({
                            h: 30, s: 33, v: 100
                        }), new Color({
                            h: 30, s: 66, v: 100
                        }), new Color({
                            h: 30, s: 100, v: 100
                        }), new Color({
                            h: 30, s: 100, v: 75
                        }), new Color({
                            h: 30, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 90
                        }), new Color({
                            h: 60, s: 33, v: 100
                        }), new Color({
                            h: 60, s: 66, v: 100
                        }), new Color({
                            h: 60, s: 100, v: 100
                        }), new Color({
                            h: 60, s: 100, v: 75
                        }), new Color({
                            h: 60, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 80
                        }), new Color({
                            h: 90, s: 33, v: 100
                        }), new Color({
                            h: 90, s: 66, v: 100
                        }), new Color({
                            h: 90, s: 100, v: 100
                        }), new Color({
                            h: 90, s: 100, v: 75
                        }), new Color({
                            h: 90, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 70
                        }), new Color({
                            h: 120, s: 33, v: 100
                        }), new Color({
                            h: 120, s: 66, v: 100
                        }), new Color({
                            h: 120, s: 100, v: 100
                        }), new Color({
                            h: 120, s: 100, v: 75
                        }), new Color({
                            h: 120, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 60
                        }), new Color({
                            h: 150, s: 33, v: 100
                        }), new Color({
                            h: 150, s: 66, v: 100
                        }), new Color({
                            h: 150, s: 100, v: 100
                        }), new Color({
                            h: 150, s: 100, v: 75
                        }), new Color({
                            h: 150, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 50
                        }), new Color({
                            h: 180, s: 33, v: 100
                        }), new Color({
                            h: 180, s: 66, v: 100
                        }), new Color({
                            h: 180, s: 100, v: 100
                        }), new Color({
                            h: 180, s: 100, v: 75
                        }), new Color({
                            h: 180, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 40
                        }), new Color({
                            h: 210, s: 33, v: 100
                        }), new Color({
                            h: 210, s: 66, v: 100
                        }), new Color({
                            h: 210, s: 100, v: 100
                        }), new Color({
                            h: 210, s: 100, v: 75
                        }), new Color({
                            h: 210, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 30
                        }), new Color({
                            h: 240, s: 33, v: 100
                        }), new Color({
                            h: 240, s: 66, v: 100
                        }), new Color({
                            h: 240, s: 100, v: 100
                        }), new Color({
                            h: 240, s: 100, v: 75
                        }), new Color({
                            h: 240, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 20
                        }), new Color({
                            h: 270, s: 33, v: 100
                        }), new Color({
                            h: 270, s: 66, v: 100
                        }), new Color({
                            h: 270, s: 100, v: 100
                        }), new Color({
                            h: 270, s: 100, v: 75
                        }), new Color({
                            h: 270, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 10
                        }), new Color({
                            h: 300, s: 33, v: 100
                        }), new Color({
                            h: 300, s: 66, v: 100
                        }), new Color({
                            h: 300, s: 100, v: 100
                        }), new Color({
                            h: 300, s: 100, v: 75
                        }), new Color({
                            h: 300, s: 100, v: 50
                        }), new Color({
                            h: 180, s: 0, v: 0
                        }), new Color({
                            h: 330, s: 33, v: 100
                        }), new Color({
                            h: 330, s: 66, v: 100
                        }), new Color({
                            h: 330, s: 100, v: 100
                        }), new Color({
                            h: 330, s: 100, v: 75
                        }), new Color({
                            h: 330, s: 100, v: 50
                        }), new Color]
            }, images: {
                clientPath: '/jPicker/images/', colorMap: {
                        width: 256, height: 256, arrow: {
                                file: 'mappoint.gif', width: 15, height: 15
                            }
                    }, colorBar: {
                        width: 20, height: 256, arrow: {
                                file: 'rangearrows.gif', width: 20, height: 7
                            }
                    }, picker: {
                        file: 'picker.gif', width: 25, height: 24
                    }
            }, localization: {
                text: {
                    title: 'Drag Markers To Pick A Color', newColor: 'new', currentColor: 'current', ok: 'OK', cancel: 'Cancel'
                }, tooltips: {
                        colors: {
                            newColor: 'New Color - Press &ldquo;OK&rdquo; To Commit', currentColor: 'Click To Revert To Original Color'
                        }, buttons: {
                                ok: 'Commit To This Color Selection', cancel: 'Cancel And Revert To Original Color'
                            }, hue: {
                                radio: 'Set To &ldquo;Hue&rdquo; Color Mode', textbox: 'Enter A &ldquo;Hue&rdquo; Value (0-360&deg;)'
                            }, saturation: {
                                radio: 'Set To &ldquo;Saturation&rdquo; Color Mode', textbox: 'Enter A &ldquo;Saturation&rdquo; Value (0-100%)'
                            }, value: {
                                radio: 'Set To &ldquo;Value&rdquo; Color Mode', textbox: 'Enter A &ldquo;Value&rdquo; Value (0-100%)'
                            }, red: {
                                radio: 'Set To &ldquo;Red&rdquo; Color Mode', textbox: 'Enter A &ldquo;Red&rdquo; Value (0-255)'
                            }, green: {
                                radio: 'Set To &ldquo;Green&rdquo; Color Mode', textbox: 'Enter A &ldquo;Green&rdquo; Value (0-255)'
                            }, blue: {
                                radio: 'Set To &ldquo;Blue&rdquo; Color Mode', textbox: 'Enter A &ldquo;Blue&rdquo; Value (0-255)'
                            }, alpha: {
                                radio: 'Set To &ldquo;Alpha&rdquo; Color Mode', textbox: 'Enter A &ldquo;Alpha&rdquo; Value (0-100)'
                            }, hex: {
                                textbox: 'Enter A &ldquo;Hex&rdquo; Color Value (#000000-#ffffff)', alpha: 'Enter A &ldquo;Alpha&rdquo; Value (#00-#ff)'
                            }
                    }
            }
    }
})(jQuery, '1.1.6');
svgedit = {NS: {
        HTML: 'http://www.w3.org/1999/xhtml', MATH: 'http://www.w3.org/1998/Math/MathML', SE: 'http://svg-edit.googlecode.com', SVG: 'http://www.w3.org/2000/svg', XLINK: 'http://www.w3.org/1999/xlink', XML: 'http://www.w3.org/XML/1998/namespace', XMLNS: 'http://www.w3.org/2000/xmlns/'
    }};
svgedit.getReverseNS = function()
{
    'use strict';
    var reverseNS = {};
    $.each(this.NS, function(name, URI)
    {
        reverseNS[URI] = name.toLowerCase()
    });
    return reverseNS
};
(function()
{
    'use strict';
    var proxied = jQuery.fn.attr,
        svgns = "http://www.w3.org/2000/svg";
    jQuery.fn.attr = function(key, value)
    {
        var i,
            attr;
        var len = this.length;
        if (!len)
        {
            return proxied.apply(this, arguments)
        }
        for (i = 0; i < len; ++i)
        {
            var elem = this[i];
            if (elem.namespaceURI === svgns)
            {
                if (value !== undefined)
                {
                    elem.setAttribute(key, value)
                }
                else if ($.isArray(key))
                {
                    var j = key.length,
                        obj = {};
                    while (j--)
                    {
                        var aname = key[j];
                        attr = elem.getAttribute(aname);
                        if (attr || attr === "0")
                        {
                            attr = isNaN(attr) ? attr : (attr - 0)
                        }
                        obj[aname] = attr
                    }
                    return obj
                }
                if (typeof key === "object")
                {
                    var v;
                    for (v in key)
                    {
                        elem.setAttribute(v, key[v])
                    }
                }
                else
                {
                    attr = elem.getAttribute(key);
                    if (attr || attr === "0")
                    {
                        attr = isNaN(attr) ? attr : (attr - 0)
                    }
                    return attr
                }
            }
            else
            {
                return proxied.apply(this, arguments)
            }
        }
        return this
    }
}());
if (jQuery)
    (function()
    {
        var win = $(window);
        var doc = $(document);
        $.extend($.fn, {
            contextMenu: function(o, callback)
            {
                if (o.menu == undefined)
                    return false;
                if (o.inSpeed == undefined)
                    o.inSpeed = 150;
                if (o.outSpeed == undefined)
                    o.outSpeed = 75;
                if (o.inSpeed == 0)
                    o.inSpeed = -1;
                if (o.outSpeed == 0)
                    o.outSpeed = -1;
                $(this).each(function()
                {
                    var el = $(this);
                    var offset = $(el).offset();
                    var menu = $('#' + o.menu);
                    menu.addClass('contextMenu');
                    $(this).bind("mousedown", function(e)
                    {
                        var evt = e;
                        $(this).mouseup(function(e)
                        {
                            var srcElement = $(this);
                            srcElement.unbind('mouseup');
                            if (evt.button === 2 || o.allowLeft || (evt.ctrlKey && svgedit.browser.isMac()))
                            {
                                e.stopPropagation();
                                $(".contextMenu").hide();
                                if (el.hasClass('disabled'))
                                    return false;
                                var d = {},
                                    x = e.pageX,
                                    y = e.pageY;
                                var x_off = win.width() - menu.width(),
                                    y_off = win.height() - menu.height();
                                if (x > x_off - 15)
                                    x = x_off - 15;
                                if (y > y_off - 30)
                                    y = y_off - 30;
                                doc.unbind('click');
                                menu.css({
                                    top: y, left: x
                                }).fadeIn(o.inSpeed);
                                menu.find('A').mouseover(function()
                                {
                                    menu.find('LI.hover').removeClass('hover');
                                    $(this).parent().addClass('hover')
                                }).mouseout(function()
                                {
                                    menu.find('LI.hover').removeClass('hover')
                                });
                                doc.keypress(function(e)
                                {
                                    switch (e.keyCode)
                                    {
                                        case 38:
                                            if (!menu.find('LI.hover').length)
                                            {
                                                menu.find('LI:last').addClass('hover')
                                            }
                                            else
                                            {
                                                menu.find('LI.hover').removeClass('hover').prevAll('LI:not(.disabled)').eq(0).addClass('hover');
                                                if (!menu.find('LI.hover').length)
                                                    menu.find('LI:last').addClass('hover')
                                            }
                                            break;
                                        case 40:
                                            if (menu.find('LI.hover').length == 0)
                                            {
                                                menu.find('LI:first').addClass('hover')
                                            }
                                            else
                                            {
                                                menu.find('LI.hover').removeClass('hover').nextAll('LI:not(.disabled)').eq(0).addClass('hover');
                                                if (!menu.find('LI.hover').length)
                                                    menu.find('LI:first').addClass('hover')
                                            }
                                            break;
                                        case 13:
                                            menu.find('LI.hover A').trigger('click');
                                            break;
                                        case 27:
                                            doc.trigger('click');
                                            break
                                    }
                                });
                                menu.find('A').unbind('mouseup');
                                menu.find('LI:not(.disabled) A').mouseup(function()
                                {
                                    doc.unbind('click').unbind('keypress');
                                    $(".contextMenu").hide();
                                    if (callback)
                                        callback($(this).attr('href').substr(1), $(srcElement), {
                                            x: x - offset.left, y: y - offset.top, docX: x, docY: y
                                        });
                                    return false
                                });
                                setTimeout(function()
                                {
                                    doc.click(function()
                                    {
                                        doc.unbind('click').unbind('keypress');
                                        menu.fadeOut(o.outSpeed);
                                        return false
                                    })
                                }, 0)
                            }
                        })
                    });
                    $(el).add($('UL.contextMenu')).bind('contextmenu', function()
                    {
                        return false
                    })
                });
                return $(this)
            }, disableContextMenuItems: function(o)
                {
                    if (o == undefined)
                    {
                        $(this).find('LI').addClass('disabled');
                        return ($(this))
                    }
                    $(this).each(function()
                    {
                        if (o != undefined)
                        {
                            var d = o.split(',');
                            for (var i = 0; i < d.length; i++)
                            {
                                $(this).find('A[href="' + d[i] + '"]').parent().addClass('disabled')
                            }
                        }
                    });
                    return ($(this))
                }, enableContextMenuItems: function(o)
                {
                    if (o == undefined)
                    {
                        $(this).find('LI.disabled').removeClass('disabled');
                        return ($(this))
                    }
                    $(this).each(function()
                    {
                        if (o != undefined)
                        {
                            var d = o.split(',');
                            for (var i = 0; i < d.length; i++)
                            {
                                $(this).find('A[href="' + d[i] + '"]').parent().removeClass('disabled')
                            }
                        }
                    });
                    return ($(this))
                }, disableContextMenu: function()
                {
                    $(this).each(function()
                    {
                        $(this).addClass('disabled')
                    });
                    return ($(this))
                }, enableContextMenu: function()
                {
                    $(this).each(function()
                    {
                        $(this).removeClass('disabled')
                    });
                    return ($(this))
                }, destroyContextMenu: function()
                {
                    $(this).each(function()
                    {
                        $(this).unbind('mousedown').unbind('mouseup')
                    });
                    return ($(this))
                }
        })
    })(jQuery);
(function()
{
    'use strict';
    if (!svgedit.browser)
    {
        svgedit.browser = {}
    }
    var NS = svgedit.NS;
    var supportsSvg_ = (function()
        {
            return !!document.createElementNS && !!document.createElementNS(NS.SVG, 'svg').createSVGRect
        }());
    svgedit.browser.supportsSvg = function()
    {
        return supportsSvg_
    };
    if (!svgedit.browser.supportsSvg())
    {
        window.location = 'browser-not-supported.html';
        return
    }
    var userAgent = navigator.userAgent;
    var svg = document.createElementNS(NS.SVG, 'svg');
    var isOpera_ = !!window.opera;
    var isWebkit_ = userAgent.indexOf('AppleWebKit') >= 0;
    var isGecko_ = userAgent.indexOf('Gecko/') >= 0;
    var isIE_ = userAgent.indexOf('MSIE') >= 0;
    var isChrome_ = userAgent.indexOf('Chrome/') >= 0;
    var isWindows_ = userAgent.indexOf('Windows') >= 0;
    var isMac_ = userAgent.indexOf('Macintosh') >= 0;
    var isTouch_ = 'ontouchstart' in window;
    var supportsSelectors_ = (function()
        {
            return !!svg.querySelector
        }());
    var supportsXpath_ = (function()
        {
            return !!document.evaluate
        }());
    var supportsPathReplaceItem_ = (function()
        {
            var path = document.createElementNS(NS.SVG, 'path');
            path.setAttribute('d', 'M0,0 10,10');
            var seglist = path.pathSegList;
            var seg = path.createSVGPathSegLinetoAbs(5, 5);
            try
            {
                seglist.replaceItem(seg, 0);
                return true
            }
            catch(err) {}
            return false
        }());
    var supportsPathInsertItemBefore_ = (function()
        {
            var path = document.createElementNS(NS.SVG, 'path');
            path.setAttribute('d', 'M0,0 10,10');
            var seglist = path.pathSegList;
            var seg = path.createSVGPathSegLinetoAbs(5, 5);
            try
            {
                seglist.insertItemBefore(seg, 0);
                return true
            }
            catch(err) {}
            return false
        }());
    var supportsGoodTextCharPos_ = (function()
        {
            var svgroot = document.createElementNS(NS.SVG, 'svg');
            var svgcontent = document.createElementNS(NS.SVG, 'svg');
            document.documentElement.appendChild(svgroot);
            svgcontent.setAttribute('x', 5);
            svgroot.appendChild(svgcontent);
            var text = document.createElementNS(NS.SVG, 'text');
            text.textContent = 'a';
            svgcontent.appendChild(text);
            var pos = text.getStartPositionOfChar(0).x;
            document.documentElement.removeChild(svgroot);
            return (pos === 0)
        }());
    var supportsPathBBox_ = (function()
        {
            var svgcontent = document.createElementNS(NS.SVG, 'svg');
            document.documentElement.appendChild(svgcontent);
            var path = document.createElementNS(NS.SVG, 'path');
            path.setAttribute('d', 'M0,0 C0,0 10,10 10,0');
            svgcontent.appendChild(path);
            var bbox = path.getBBox();
            document.documentElement.removeChild(svgcontent);
            return (bbox.height > 4 && bbox.height < 5)
        }());
    var supportsHVLineContainerBBox_ = (function()
        {
            var svgcontent = document.createElementNS(NS.SVG, 'svg');
            document.documentElement.appendChild(svgcontent);
            var path = document.createElementNS(NS.SVG, 'path');
            path.setAttribute('d', 'M0,0 10,0');
            var path2 = document.createElementNS(NS.SVG, 'path');
            path2.setAttribute('d', 'M5,0 15,0');
            var g = document.createElementNS(NS.SVG, 'g');
            g.appendChild(path);
            g.appendChild(path2);
            svgcontent.appendChild(g);
            var bbox = g.getBBox();
            document.documentElement.removeChild(svgcontent);
            return (bbox.width == 15)
        }());
    var supportsEditableText_ = (function()
        {
            return isOpera_
        }());
    var supportsGoodDecimals_ = (function()
        {
            var rect = document.createElementNS(NS.SVG, 'rect');
            rect.setAttribute('x', 0.1);
            var crect = rect.cloneNode(false);
            var retValue = (crect.getAttribute('x').indexOf(',') == -1);
            if (!retValue)
            {
                $.alert('NOTE: This version of Opera is known to contain bugs in SVG-edit.\n' + 'Please upgrade to the <a href="http://opera.com">latest version</a> in which the problems have been fixed.')
            }
            return retValue
        }());
    var supportsNonScalingStroke_ = (function()
        {
            var rect = document.createElementNS(NS.SVG, 'rect');
            rect.setAttribute('style', 'vector-effect:non-scaling-stroke');
            return rect.style.vectorEffect === 'non-scaling-stroke'
        }());
    var supportsNativeSVGTransformLists_ = (function()
        {
            var rect = document.createElementNS(NS.SVG, 'rect');
            var rxform = rect.transform.baseVal;
            var t1 = svg.createSVGTransform();
            rxform.appendItem(t1);
            return rxform.getItem(0) == t1
        }());
    svgedit.browser.isOpera = function()
    {
        return isOpera_
    };
    svgedit.browser.isWebkit = function()
    {
        return isWebkit_
    };
    svgedit.browser.isGecko = function()
    {
        return isGecko_
    };
    svgedit.browser.isIE = function()
    {
        return isIE_
    };
    svgedit.browser.isChrome = function()
    {
        return isChrome_
    };
    svgedit.browser.isWindows = function()
    {
        return isWindows_
    };
    svgedit.browser.isMac = function()
    {
        return isMac_
    };
    svgedit.browser.isTouch = function()
    {
        return isTouch_
    };
    svgedit.browser.supportsSelectors = function()
    {
        return supportsSelectors_
    };
    svgedit.browser.supportsXpath = function()
    {
        return supportsXpath_
    };
    svgedit.browser.supportsPathReplaceItem = function()
    {
        return supportsPathReplaceItem_
    };
    svgedit.browser.supportsPathInsertItemBefore = function()
    {
        return supportsPathInsertItemBefore_
    };
    svgedit.browser.supportsPathBBox = function()
    {
        return supportsPathBBox_
    };
    svgedit.browser.supportsHVLineContainerBBox = function()
    {
        return supportsHVLineContainerBBox_
    };
    svgedit.browser.supportsGoodTextCharPos = function()
    {
        return supportsGoodTextCharPos_
    };
    svgedit.browser.supportsEditableText = function()
    {
        return supportsEditableText_
    };
    svgedit.browser.supportsGoodDecimals = function()
    {
        return supportsGoodDecimals_
    };
    svgedit.browser.supportsNonScalingStroke = function()
    {
        return supportsNonScalingStroke_
    };
    svgedit.browser.supportsNativeTransformLists = function()
    {
        return supportsNativeSVGTransformLists_
    }
}());
(function()
{
    'use strict';
    if (!svgedit.transformlist)
    {
        svgedit.transformlist = {}
    }
    var svgroot = document.createElementNS(svgedit.NS.SVG, 'svg');
    function transformToString(xform)
    {
        var m = xform.matrix,
            text = '';
        switch (xform.type)
        {
            case 1:
                text = 'matrix(' + [m.a, m.b, m.c, m.d, m.e, m.f].join(',') + ')';
                break;
            case 2:
                text = 'translate(' + m.e + ',' + m.f + ')';
                break;
            case 3:
                if (m.a == m.d)
                {
                    text = 'scale(' + m.a + ')'
                }
                else
                {
                    text = 'scale(' + m.a + ',' + m.d + ')'
                }
                break;
            case 4:
                var cx = 0,
                    cy = 0;
                if (xform.angle != 0)
                {
                    var K = 1 - m.a;
                    cy = (K * m.f + m.b * m.e) / (K * K + m.b * m.b);
                    cx = (m.e - m.b * cy) / K
                }
                text = 'rotate(' + xform.angle + ' ' + cx + ',' + cy + ')';
                break
        }
        return text
    }
    var listMap_ = {};
    svgedit.transformlist.SVGTransformList = function(elem)
    {
        this._elem = elem || null;
        this._xforms = [];
        this._update = function()
        {
            var tstr = '';
            var concatMatrix = svgroot.createSVGMatrix();
            var i;
            for (i = 0; i < this.numberOfItems; ++i)
            {
                var xform = this._list.getItem(i);
                tstr += transformToString(xform) + ' '
            }
            this._elem.setAttribute('transform', tstr)
        };
        this._list = this;
        this._init = function()
        {
            var str = this._elem.getAttribute('transform');
            if (!str)
            {
                return
            }
            var re = /\s*((scale|matrix|rotate|translate)\s*\(.*?\))\s*,?\s*/;
            var m = true;
            while (m)
            {
                m = str.match(re);
                str = str.replace(re, '');
                if (m && m[1])
                {
                    var x = m[1];
                    var bits = x.split(/\s*\(/);
                    var name = bits[0];
                    var val_bits = bits[1].match(/\s*(.*?)\s*\)/);
                    val_bits[1] = val_bits[1].replace(/(\d)-/g, '$1 -');
                    var val_arr = val_bits[1].split(/[, ]+/);
                    var letters = 'abcdef'.split('');
                    var mtx = svgroot.createSVGMatrix();
                    $.each(val_arr, function(i, item)
                    {
                        val_arr[i] = parseFloat(item);
                        if (name == 'matrix')
                        {
                            mtx[letters[i]] = val_arr[i]
                        }
                    });
                    var xform = svgroot.createSVGTransform();
                    var fname = 'set' + name.charAt(0).toUpperCase() + name.slice(1);
                    var values = name == 'matrix' ? [mtx] : val_arr;
                    if (name == 'scale' && values.length == 1)
                    {
                        values.push(values[0])
                    }
                    else if (name == 'translate' && values.length == 1)
                    {
                        values.push(0)
                    }
                    else if (name == 'rotate' && values.length == 1)
                    {
                        values.push(0, 0)
                    }
                    xform[fname].apply(xform, values);
                    this._list.appendItem(xform)
                }
            }
        };
        this._removeFromOtherLists = function(item)
        {
            if (item)
            {
                var found = false;
                var id;
                for (id in listMap_)
                {
                    var tl = listMap_[id];
                    var i,
                        len;
                    for (i = 0, len = tl._xforms.length; i < len; ++i)
                    {
                        if (tl._xforms[i] == item)
                        {
                            found = true;
                            tl.removeItem(i);
                            break
                        }
                    }
                    if (found)
                    {
                        break
                    }
                }
            }
        };
        this.numberOfItems = 0;
        this.clear = function()
        {
            this.numberOfItems = 0;
            this._xforms = []
        };
        this.initialize = function(newItem)
        {
            this.numberOfItems = 1;
            this._removeFromOtherLists(newItem);
            this._xforms = [newItem]
        };
        this.getItem = function(index)
        {
            if (index < this.numberOfItems && index >= 0)
            {
                return this._xforms[index]
            }
            throw{code: 1};
        };
        this.insertItemBefore = function(newItem, index)
        {
            var retValue = null;
            if (index >= 0)
            {
                if (index < this.numberOfItems)
                {
                    this._removeFromOtherLists(newItem);
                    var newxforms = new Array(this.numberOfItems + 1);
                    var i;
                    for (i = 0; i < index; ++i)
                    {
                        newxforms[i] = this._xforms[i]
                    }
                    newxforms[i] = newItem;
                    var j;
                    for (j = i + 1; i < this.numberOfItems; ++j, ++i)
                    {
                        newxforms[j] = this._xforms[i]
                    }
                    this.numberOfItems++;
                    this._xforms = newxforms;
                    retValue = newItem;
                    this._list._update()
                }
                else
                {
                    retValue = this._list.appendItem(newItem)
                }
            }
            return retValue
        };
        this.replaceItem = function(newItem, index)
        {
            var retValue = null;
            if (index < this.numberOfItems && index >= 0)
            {
                this._removeFromOtherLists(newItem);
                this._xforms[index] = newItem;
                retValue = newItem;
                this._list._update()
            }
            return retValue
        };
        this.removeItem = function(index)
        {
            if (index < this.numberOfItems && index >= 0)
            {
                var retValue = this._xforms[index];
                var newxforms = new Array(this.numberOfItems - 1);
                var i,
                    j;
                for (i = 0; i < index; ++i)
                {
                    newxforms[i] = this._xforms[i]
                }
                for (j = i; j < this.numberOfItems - 1; ++j, ++i)
                {
                    newxforms[j] = this._xforms[i + 1]
                }
                this.numberOfItems--;
                this._xforms = newxforms;
                this._list._update();
                return retValue
            }
            throw{code: 1};
        };
        this.appendItem = function(newItem)
        {
            this._removeFromOtherLists(newItem);
            this._xforms.push(newItem);
            this.numberOfItems++;
            this._list._update();
            return newItem
        }
    };
    svgedit.transformlist.resetListMap = function()
    {
        listMap_ = {}
    };
    svgedit.transformlist.removeElementFromListMap = function(elem)
    {
        if (elem.id && listMap_[elem.id])
        {
            delete listMap_[elem.id]
        }
    };
    svgedit.transformlist.getTransformList = function(elem)
    {
        if (!svgedit.browser.supportsNativeTransformLists())
        {
            var id = elem.id || 'temp';
            var t = listMap_[id];
            if (!t || id === 'temp')
            {
                listMap_[id] = new svgedit.transformlist.SVGTransformList(elem);
                listMap_[id]._init();
                t = listMap_[id]
            }
            return t
        }
        if (elem.transform)
        {
            return elem.transform.baseVal
        }
        if (elem.gradientTransform)
        {
            return elem.gradientTransform.baseVal
        }
        if (elem.patternTransform)
        {
            return elem.patternTransform.baseVal
        }
        return null
    }
}());
(function()
{
    'use strict';
    if (!svgedit.math)
    {
        svgedit.math = {}
    }
    var NEAR_ZERO = 1e-14;
    var svg = document.createElementNS(svgedit.NS.SVG, 'svg');
    svgedit.math.transformPoint = function(x, y, m)
    {
        return {
                x: m.a * x + m.c * y + m.e, y: m.b * x + m.d * y + m.f
            }
    };
    svgedit.math.isIdentity = function(m)
    {
        return (m.a === 1 && m.b === 0 && m.c === 0 && m.d === 1 && m.e === 0 && m.f === 0)
    };
    svgedit.math.matrixMultiply = function(matr)
    {
        var args = arguments,
            i = args.length,
            m = args[i - 1];
        while (i-- > 1)
        {
            var m1 = args[i - 1];
            m = m1.multiply(m)
        }
        if (Math.abs(m.a) < NEAR_ZERO)
        {
            m.a = 0
        }
        if (Math.abs(m.b) < NEAR_ZERO)
        {
            m.b = 0
        }
        if (Math.abs(m.c) < NEAR_ZERO)
        {
            m.c = 0
        }
        if (Math.abs(m.d) < NEAR_ZERO)
        {
            m.d = 0
        }
        if (Math.abs(m.e) < NEAR_ZERO)
        {
            m.e = 0
        }
        if (Math.abs(m.f) < NEAR_ZERO)
        {
            m.f = 0
        }
        return m
    };
    svgedit.math.hasMatrixTransform = function(tlist)
    {
        if (!tlist)
        {
            return false
        }
        var num = tlist.numberOfItems;
        while (num--)
        {
            var xform = tlist.getItem(num);
            if (xform.type == 1 && !svgedit.math.isIdentity(xform.matrix))
            {
                return true
            }
        }
        return false
    };
    svgedit.math.transformBox = function(l, t, w, h, m)
    {
        var transformPoint = svgedit.math.transformPoint,
            tl = transformPoint(l, t, m),
            tr = transformPoint((l + w), t, m),
            bl = transformPoint(l, (t + h), m),
            br = transformPoint((l + w), (t + h), m),
            minx = Math.min(tl.x, tr.x, bl.x, br.x),
            maxx = Math.max(tl.x, tr.x, bl.x, br.x),
            miny = Math.min(tl.y, tr.y, bl.y, br.y),
            maxy = Math.max(tl.y, tr.y, bl.y, br.y);
        return {
                tl: tl, tr: tr, bl: bl, br: br, aabox: {
                        x: minx, y: miny, width: (maxx - minx), height: (maxy - miny)
                    }
            }
    };
    svgedit.math.transformListToTransform = function(tlist, min, max)
    {
        if (tlist == null)
        {
            return svg.createSVGTransformFromMatrix(svg.createSVGMatrix())
        }
        min = min || 0;
        max = max || (tlist.numberOfItems - 1);
        min = parseInt(min, 10);
        max = parseInt(max, 10);
        if (min > max)
        {
            var temp = max;
            max = min;
            min = temp
        }
        var m = svg.createSVGMatrix();
        var i;
        for (i = min; i <= max; ++i)
        {
            var mtom = (i >= 0 && i < tlist.numberOfItems ? tlist.getItem(i).matrix : svg.createSVGMatrix());
            m = svgedit.math.matrixMultiply(m, mtom)
        }
        return svg.createSVGTransformFromMatrix(m)
    };
    svgedit.math.getMatrix = function(elem)
    {
        var tlist = svgedit.transformlist.getTransformList(elem);
        return svgedit.math.transformListToTransform(tlist).matrix
    };
    svgedit.math.snapToAngle = function(x1, y1, x2, y2)
    {
        var snap = Math.PI / 4;
        var dx = x2 - x1;
        var dy = y2 - y1;
        var angle = Math.atan2(dy, dx);
        var dist = Math.sqrt(dx * dx + dy * dy);
        var snapangle = Math.round(angle / snap) * snap;
        return {
                x: x1 + dist * Math.cos(snapangle), y: y1 + dist * Math.sin(snapangle), a: snapangle
            }
    };
    svgedit.math.rectsIntersect = function(r1, r2)
    {
        return r2.x < (r1.x + r1.width) && (r2.x + r2.width) > r1.x && r2.y < (r1.y + r1.height) && (r2.y + r2.height) > r1.y
    }
}());
(function()
{
    'use strict';
    if (!svgedit.units)
    {
        svgedit.units = {}
    }
    var NS = svgedit.NS;
    var wAttrs = ['x', 'x1', 'cx', 'rx', 'width'];
    var hAttrs = ['y', 'y1', 'cy', 'ry', 'height'];
    var unitAttrs = ['r', 'radius'].concat(wAttrs, hAttrs);
    var unitNumMap = {
            '%': 2, em: 3, ex: 4, px: 5, cm: 6, mm: 7, 'in': 8, pt: 9, pc: 10
        };
    var elementContainer_;
    var typeMap_ = {};
    svgedit.units.init = function(elementContainer)
    {
        elementContainer_ = elementContainer;
        var svg = document.createElementNS(NS.SVG, 'svg');
        document.body.appendChild(svg);
        var rect = document.createElementNS(NS.SVG, 'rect');
        rect.setAttribute('width', '1em');
        rect.setAttribute('height', '1ex');
        rect.setAttribute('x', '1in');
        svg.appendChild(rect);
        var bb = rect.getBBox();
        document.body.removeChild(svg);
        var inch = bb.x;
        typeMap_ = {
            em: bb.width, ex: bb.height, 'in': inch, cm: inch / 2.54, mm: inch / 25.4, pt: inch / 72, pc: inch / 6, px: 1, '%': 0
        }
    };
    svgedit.units.getTypeMap = function()
    {
        return typeMap_
    };
    svgedit.units.shortFloat = function(val)
    {
        var digits = elementContainer_.getRoundDigits();
        if (!isNaN(val))
        {
            return +((+val).toFixed(digits))
        }
        if ($.isArray(val))
        {
            return svgedit.units.shortFloat(val[0]) + ',' + svgedit.units.shortFloat(val[1])
        }
        return parseFloat(val).toFixed(digits) - 0
    };
    svgedit.units.convertUnit = function(val, unit)
    {
        unit = unit || elementContainer_.getBaseUnit();
        return svgedit.units.shortFloat(val / typeMap_[unit])
    };
    svgedit.units.setUnitAttr = function(elem, attr, val)
    {
        elem.setAttribute(attr, val)
    };
    var attrsToConvert = {
            line: ['x1', 'x2', 'y1', 'y2'], circle: ['cx', 'cy', 'r'], ellipse: ['cx', 'cy', 'rx', 'ry'], foreignObject: ['x', 'y', 'width', 'height'], rect: ['x', 'y', 'width', 'height'], image: ['x', 'y', 'width', 'height'], use: ['x', 'y', 'width', 'height'], text: ['x', 'y']
        };
    svgedit.units.convertAttrs = function(element)
    {
        var elName = element.tagName;
        var unit = elementContainer_.getBaseUnit();
        var attrs = attrsToConvert[elName];
        if (!attrs)
        {
            return
        }
        var len = attrs.length;
        var i;
        for (i = 0; i < len; i++)
        {
            var attr = attrs[i];
            var cur = element.getAttribute(attr);
            if (cur)
            {
                if (!isNaN(cur))
                {
                    element.setAttribute(attr, (cur / typeMap_[unit]) + unit)
                }
            }
        }
    };
    svgedit.units.convertToNum = function(attr, val)
    {
        if (!isNaN(val))
        {
            return val - 0
        }
        var num;
        if (val.substr(-1) === '%')
        {
            num = val.substr(0, val.length - 1) / 100;
            var width = elementContainer_.getWidth();
            var height = elementContainer_.getHeight();
            if (wAttrs.indexOf(attr) >= 0)
            {
                return num * width
            }
            if (hAttrs.indexOf(attr) >= 0)
            {
                return num * height
            }
            return num * Math.sqrt((width * width) + (height * height)) / Math.sqrt(2)
        }
        var unit = val.substr(-2);
        num = val.substr(0, val.length - 2);
        return num * typeMap_[unit]
    };
    svgedit.units.isValidUnit = function(attr, val, selectedElement)
    {
        var valid = false;
        if (unitAttrs.indexOf(attr) >= 0)
        {
            if (!isNaN(val))
            {
                valid = true
            }
            else
            {
                val = val.toLowerCase();
                $.each(typeMap_, function(unit)
                {
                    if (valid)
                    {
                        return
                    }
                    var re = new RegExp('^-?[\\d\\.]+' + unit + '$');
                    if (re.test(val))
                    {
                        valid = true
                    }
                })
            }
        }
        else if (attr == 'id')
        {
            var result = false;
            try
            {
                var elem = elementContainer_.getElement(val);
                result = (elem == null || elem === selectedElement)
            }
            catch(e) {}
            return result
        }
        valid = true;
        return valid
    }
}());
(function()
{
    'use strict';
    if (!svgedit.utilities)
    {
        svgedit.utilities = {}
    }
    var KEYSTR = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/=';
    var NS = svgedit.NS;
    var visElems = 'a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use';
    var visElems_arr = visElems.split(',');
    var editorContext_ = null;
    var domdoc_ = null;
    var domcontainer_ = null;
    var svgroot_ = null;
    svgedit.utilities.init = function(editorContext)
    {
        editorContext_ = editorContext;
        domdoc_ = editorContext.getDOMDocument();
        domcontainer_ = editorContext.getDOMContainer();
        svgroot_ = editorContext.getSVGRoot()
    };
    svgedit.utilities.toXml = function(str)
    {
        return str.replace(/&/g, '&amp;').replace(/</g, '&lt;').replace(/>/g, '&gt;').replace(/"/g, '&quot;').replace(/'/, '&#x27;')
    };
    svgedit.utilities.fromXml = function(str)
    {
        return $('<p/>').html(str).text()
    };
    svgedit.utilities.encode64 = function(input)
    {
        input = svgedit.utilities.encodeUTF8(input);
        if (window.btoa)
        {
            return window.btoa(input)
        }
        var output = new Array(Math.floor((input.length + 2) / 3) * 4);
        var chr1,
            chr2,
            chr3;
        var enc1,
            enc2,
            enc3,
            enc4;
        var i = 0,
            p = 0;
        do
        {
            chr1 = input.charCodeAt(i++);
            chr2 = input.charCodeAt(i++);
            chr3 = input.charCodeAt(i++);
            enc1 = chr1 >> 2;
            enc2 = ((chr1 & 3) << 4) | (chr2 >> 4);
            enc3 = ((chr2 & 15) << 2) | (chr3 >> 6);
            enc4 = chr3 & 63;
            if (isNaN(chr2))
            {
                enc3 = enc4 = 64
            }
            else if (isNaN(chr3))
            {
                enc4 = 64
            }
            output[p++] = KEYSTR.charAt(enc1);
            output[p++] = KEYSTR.charAt(enc2);
            output[p++] = KEYSTR.charAt(enc3);
            output[p++] = KEYSTR.charAt(enc4)
        } while (i < input.length);
        return output.join('')
    };
    svgedit.utilities.decode64 = function(input)
    {
        if (window.atob)
        {
            return window.atob(input)
        }
        var output = '';
        var chr1,
            chr2,
            chr3 = '';
        var enc1,
            enc2,
            enc3,
            enc4 = '';
        var i = 0;
        input = input.replace(/[^A-Za-z0-9\+\/\=]/g, '');
        do
        {
            enc1 = KEYSTR.indexOf(input.charAt(i++));
            enc2 = KEYSTR.indexOf(input.charAt(i++));
            enc3 = KEYSTR.indexOf(input.charAt(i++));
            enc4 = KEYSTR.indexOf(input.charAt(i++));
            chr1 = (enc1 << 2) | (enc2 >> 4);
            chr2 = ((enc2 & 15) << 4) | (enc3 >> 2);
            chr3 = ((enc3 & 3) << 6) | enc4;
            output = output + String.fromCharCode(chr1);
            if (enc3 != 64)
            {
                output = output + String.fromCharCode(chr2)
            }
            if (enc4 != 64)
            {
                output = output + String.fromCharCode(chr3)
            }
            chr1 = chr2 = chr3 = '';
            enc1 = enc2 = enc3 = enc4 = ''
        } while (i < input.length);
        return unescape(output)
    };
    svgedit.utilities.encodeUTF8 = function(argString)
    {
        if (argString === null || typeof argString === 'undefined')
        {
            return ''
        }
        var string = String(argString);
        var utftext = '',
            start,
            end,
            stringl = 0;
        start = end = 0;
        stringl = string.length;
        var n;
        for (n = 0; n < stringl; n++)
        {
            var c1 = string.charCodeAt(n);
            var enc = null;
            if (c1 < 128)
            {
                end++
            }
            else if (c1 > 127 && c1 < 2048)
            {
                enc = String.fromCharCode((c1 >> 6) | 192, (c1 & 63) | 128)
            }
            else if ((c1 & 0xF800) != 0xD800)
            {
                enc = String.fromCharCode((c1 >> 12) | 224, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128)
            }
            else
            {
                if ((c1 & 0xFC00) != 0xD800)
                {
                    throw new RangeError('Unmatched trail surrogate at ' + n);
                }
                var c2 = string.charCodeAt(++n);
                if ((c2 & 0xFC00) != 0xDC00)
                {
                    throw new RangeError('Unmatched lead surrogate at ' + (n - 1));
                }
                c1 = ((c1 & 0x3FF) << 10) + (c2 & 0x3FF) + 0x10000;
                enc = String.fromCharCode((c1 >> 18) | 240, ((c1 >> 12) & 63) | 128, ((c1 >> 6) & 63) | 128, (c1 & 63) | 128)
            }
            if (enc !== null)
            {
                if (end > start)
                {
                    utftext += string.slice(start, end)
                }
                utftext += enc;
                start = end = n + 1
            }
        }
        if (end > start)
        {
            utftext += string.slice(start, stringl)
        }
        return utftext
    };
    svgedit.utilities.convertToXMLReferences = function(input)
    {
        var n,
            output = '';
        for (n = 0; n < input.length; n++)
        {
            var c = input.charCodeAt(n);
            if (c < 128)
            {
                output += input[n]
            }
            else if (c > 127)
            {
                output += ('&#' + c + ';')
            }
        }
        return output
    };
    svgedit.utilities.text2xml = function(sXML)
    {
        if (sXML.indexOf('<svg:svg') >= 0)
        {
            sXML = sXML.replace(/<(\/?)svg:/g, '<$1').replace('xmlns:svg', 'xmlns')
        }
        var out,
            dXML;
        try
        {
            dXML = (window.DOMParser) ? new DOMParser : new ActiveXObject('Microsoft.XMLDOM');
            dXML.async = false
        }
        catch(e)
        {
            throw new Error('XML Parser could not be instantiated');
        }
        try
        {
            if (dXML.loadXML)
            {
                out = (dXML.loadXML(sXML)) ? dXML : false
            }
            else
            {
                out = dXML.parseFromString(sXML, 'text/xml')
            }
        }
        catch(e2)
        {
            throw new Error('Error parsing XML string');
        }
        return out
    };
    svgedit.utilities.bboxToObj = function(bbox)
    {
        return {
                x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height
            }
    };
    svgedit.utilities.walkTree = function(elem, cbFn)
    {
        if (elem && elem.nodeType == 1)
        {
            cbFn(elem);
            var i = elem.childNodes.length;
            while (i--)
            {
                svgedit.utilities.walkTree(elem.childNodes.item(i), cbFn)
            }
        }
    };
    svgedit.utilities.walkTreePost = function(elem, cbFn)
    {
        if (elem && elem.nodeType == 1)
        {
            var i = elem.childNodes.length;
            while (i--)
            {
                svgedit.utilities.walkTree(elem.childNodes.item(i), cbFn)
            }
            cbFn(elem)
        }
    };
    svgedit.utilities.getUrlFromAttr = function(attrVal)
    {
        if (attrVal)
        {
            if (attrVal.indexOf('url("') === 0)
            {
                return attrVal.substring(5, attrVal.indexOf('"', 6))
            }
            if (attrVal.indexOf("url('") === 0)
            {
                return attrVal.substring(5, attrVal.indexOf("'", 6))
            }
            if (attrVal.indexOf("url(") === 0)
            {
                return attrVal.substring(4, attrVal.indexOf(')'))
            }
        }
        return null
    };
    svgedit.utilities.getHref = function(elem)
    {
        return elem.getAttributeNS(NS.XLINK, 'href')
    };
    svgedit.utilities.setHref = function(elem, val)
    {
        elem.setAttributeNS(NS.XLINK, 'xlink:href', val)
    };
    svgedit.utilities.findDefs = function()
    {
        var svgElement = editorContext_.getSVGContent();
        var defs = svgElement.getElementsByTagNameNS(NS.SVG, 'defs');
        if (defs.length > 0)
        {
            defs = defs[0]
        }
        else
        {
            defs = svgElement.ownerDocument.createElementNS(NS.SVG, 'defs');
            if (svgElement.firstChild)
            {
                svgElement.insertBefore(defs, svgElement.firstChild.nextSibling)
            }
            else
            {
                svgElement.appendChild(defs)
            }
        }
        return defs
    };
    svgedit.utilities.getPathBBox = function(path)
    {
        var seglist = path.pathSegList;
        var tot = seglist.numberOfItems;
        var bounds = [[], []];
        var start = seglist.getItem(0);
        var P0 = [start.x, start.y];
        var i;
        for (i = 0; i < tot; i++)
        {
            var seg = seglist.getItem(i);
            if (typeof seg.x === 'undefined')
            {
                continue
            }
            bounds[0].push(P0[0]);
            bounds[1].push(P0[1]);
            if (seg.x1)
            {
                var P1 = [seg.x1, seg.y1],
                    P2 = [seg.x2, seg.y2],
                    P3 = [seg.x, seg.y];
                var j;
                for (j = 0; j < 2; j++)
                {
                    var calc = function(t)
                        {
                            return Math.pow(1 - t, 3) * P0[j] + 3 * Math.pow(1 - t, 2) * t * P1[j] + 3 * (1 - t) * Math.pow(t, 2) * P2[j] + Math.pow(t, 3) * P3[j]
                        };
                    var b = 6 * P0[j] - 12 * P1[j] + 6 * P2[j];
                    var a = -3 * P0[j] + 9 * P1[j] - 9 * P2[j] + 3 * P3[j];
                    var c = 3 * P1[j] - 3 * P0[j];
                    if (a == 0)
                    {
                        if (b == 0)
                        {
                            continue
                        }
                        var t = -c / b;
                        if (0 < t && t < 1)
                        {
                            bounds[j].push(calc(t))
                        }
                        continue
                    }
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0)
                    {
                        continue
                    }
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1)
                    {
                        bounds[j].push(calc(t1))
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1)
                    {
                        bounds[j].push(calc(t2))
                    }
                }
                P0 = P3
            }
            else
            {
                bounds[0].push(seg.x);
                bounds[1].push(seg.y)
            }
        }
        var x = Math.min.apply(null, bounds[0]);
        var w = Math.max.apply(null, bounds[0]) - x;
        var y = Math.min.apply(null, bounds[1]);
        var h = Math.max.apply(null, bounds[1]) - y;
        return {
                x: x, y: y, width: w, height: h
            }
    };
    function groupBBFix(selected)
    {
        if (svgedit.browser.supportsHVLineContainerBBox())
        {
            try
            {
                return selected.getBBox()
            }
            catch(e) {}
        }
        var ref = $.data(selected, 'ref');
        var matched = null;
        var ret,
            copy;
        if (ref)
        {
            copy = $(ref).children().clone().attr('visibility', 'hidden');
            $(svgroot_).append(copy);
            matched = copy.filter('line, path')
        }
        else
        {
            matched = $(selected).find('line, path')
        }
        var issue = false;
        if (matched.length)
        {
            matched.each(function()
            {
                var bb = this.getBBox();
                if (!bb.width || !bb.height)
                {
                    issue = true
                }
            });
            if (issue)
            {
                var elems = ref ? copy : $(selected).children();
                ret = getStrokedBBox(elems)
            }
            else
            {
                ret = selected.getBBox()
            }
        }
        else
        {
            ret = selected.getBBox()
        }
        if (ref)
        {
            copy.remove()
        }
        return ret
    }
    svgedit.utilities.getBBox = function(elem)
    {
        var selected = elem || editorContext_.geSelectedElements()[0];
        if (elem.nodeType != 1)
        {
            return null
        }
        var ret = null;
        var elname = selected.nodeName;
        switch (elname)
        {
            case'text':
                if (selected.textContent === '')
                {
                    selected.textContent = 'a';
                    ret = selected.getBBox();
                    selected.textContent = ''
                }
                else
                {
                    try
                    {
                        ret = selected.getBBox()
                    }
                    catch(e) {}
                }
                break;
            case'path':
                if (!svgedit.browser.supportsPathBBox())
                {
                    ret = svgedit.utilities.getPathBBox(selected)
                }
                else
                {
                    try
                    {
                        ret = selected.getBBox()
                    }
                    catch(e2) {}
                }
                break;
            case'g':
            case'a':
                ret = groupBBFix(selected);
                break;
            default:
                if (elname === 'use')
                {
                    ret = groupBBFix(selected, true)
                }
                if (elname === 'use' || (elname === 'foreignObject' && svgedit.browser.isWebkit()))
                {
                    if (!ret)
                    {
                        ret = selected.getBBox()
                    }
                    var bb = {};
                    bb.width = ret.width;
                    bb.height = ret.height;
                    bb.x = ret.x + parseFloat(selected.getAttribute('x') || 0);
                    bb.y = ret.y + parseFloat(selected.getAttribute('y') || 0);
                    ret = bb
                }
                else if (~visElems_arr.indexOf(elname))
                {
                    try
                    {
                        ret = selected.getBBox()
                    }
                    catch(e3)
                    {
                        var fo = $(selected).closest('foreignObject');
                        if (fo.length)
                        {
                            try
                            {
                                ret = fo[0].getBBox()
                            }
                            catch(e4)
                            {
                                ret = null
                            }
                        }
                        else
                        {
                            ret = null
                        }
                    }
                }
        }
        if (ret)
        {
            ret = svgedit.utilities.bboxToObj(ret)
        }
        return ret
    };
    svgedit.utilities.getRotationAngle = function(elem, to_rad)
    {
        var selected = elem || editorContext_.getSelectedElements()[0];
        var tlist = svgedit.transformlist.getTransformList(selected);
        if (!tlist)
        {
            return 0
        }
        var N = tlist.numberOfItems;
        var i;
        for (i = 0; i < N; ++i)
        {
            var xform = tlist.getItem(i);
            if (xform.type == 4)
            {
                return to_rad ? xform.angle * Math.PI / 180.0 : xform.angle
            }
        }
        return 0.0
    };
    svgedit.utilities.getRefElem = function(attrVal)
    {
        return svgedit.utilities.getElem(svgedit.utilities.getUrlFromAttr(attrVal).substr(1))
    };
    if (svgedit.browser.supportsSelectors())
    {
        svgedit.utilities.getElem = function(id)
        {
            return svgroot_.querySelector('#' + id)
        }
    }
    else if (svgedit.browser.supportsXpath())
    {
        svgedit.utilities.getElem = function(id)
        {
            return domdoc_.evaluate('svg:svg[@id="svgroot"]//svg:*[@id="' + id + '"]', domcontainer_, function()
                {
                    return svgedit.NS.SVG
                }, 9, null).singleNodeValue
        }
    }
    else
    {
        svgedit.utilities.getElem = function(id)
        {
            return $(svgroot_).find('[id=' + id + ']')[0]
        }
    }
    svgedit.utilities.assignAttributes = function(node, attrs, suspendLength, unitCheck)
    {
        if (!suspendLength)
        {
            suspendLength = 0
        }
        var handle = null;
        if (!svgedit.browser.isOpera())
        {
            svgroot_.suspendRedraw(suspendLength)
        }
        var i;
        for (i in attrs)
        {
            var ns = (i.substr(0, 4) === 'xml:' ? NS.XML : i.substr(0, 6) === 'xlink:' ? NS.XLINK : null);
            if (ns)
            {
                node.setAttributeNS(ns, i, attrs[i])
            }
            else if (!unitCheck)
            {
                node.setAttribute(i, attrs[i])
            }
            else
            {
                svgedit.units.setUnitAttr(node, i, attrs[i])
            }
        }
        if (!svgedit.browser.isOpera())
        {
            svgroot_.unsuspendRedraw(handle)
        }
    };
    svgedit.utilities.cleanupElement = function(element)
    {
        var handle = svgroot_.suspendRedraw(60);
        var defaults = {
                'fill-opacity': 1, 'stop-opacity': 1, opacity: 1, stroke: 'none', 'stroke-dasharray': 'none', 'stroke-linejoin': 'miter', 'stroke-linecap': 'butt', 'stroke-opacity': 1, 'stroke-width': 1, rx: 0, ry: 0
            };
        var attr;
        for (attr in defaults)
        {
            var val = defaults[attr];
            if (element.getAttribute(attr) == val)
            {
                element.removeAttribute(attr)
            }
        }
        svgroot_.unsuspendRedraw(handle)
    };
    svgedit.utilities.snapToGrid = function(value)
    {
        var stepSize = editorContext_.getSnappingStep();
        var unit = editorContext_.getBaseUnit();
        if (unit !== "px")
        {
            stepSize *= svgedit.units.getTypeMap()[unit]
        }
        value = Math.round(value / stepSize) * stepSize;
        return value
    };
    svgedit.utilities.preg_quote = function(str, delimiter)
    {
        return String(str).replace(new RegExp('[.\\\\+*?\\[\\^\\]$(){}=!<>|:\\' + (delimiter || '') + '-]', 'g'), '\\$&')
    }
}());
(function()
{
    'use strict';
    if (!svgedit.sanitize)
    {
        svgedit.sanitize = {}
    }
    var NS = svgedit.NS,
        REVERSE_NS = svgedit.getReverseNS();
    var svgWhiteList_ = {
            a: ["class", "clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "id", "mask", "opacity", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform", "xlink:href", "xlink:title"], circle: ["class", "clip-path", "clip-rule", "cx", "cy", "fill", "fill-opacity", "fill-rule", "filter", "id", "mask", "opacity", "r", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform"], clipPath: ["class", "clipPathUnits", "id"], defs: [], style: ["type"], desc: [], ellipse: ["class", "clip-path", "clip-rule", "cx", "cy", "fill", "fill-opacity", "fill-rule", "filter", "id", "mask", "opacity", "requiredFeatures", "rx", "ry", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform"], feGaussianBlur: ["class", "color-interpolation-filters", "id", "requiredFeatures", "stdDeviation"], filter: ["class", "color-interpolation-filters", "filterRes", "filterUnits", "height", "id", "primitiveUnits", "requiredFeatures", "width", "x", "xlink:href", "y"], foreignObject: ["class", "font-size", "height", "id", "opacity", "requiredFeatures", "style", "transform", "width", "x", "y"], g: ["class", "clip-path", "clip-rule", "id", "display", "fill", "fill-opacity", "fill-rule", "filter", "mask", "opacity", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform", "font-family", "font-size", "font-style", "font-weight", "text-anchor"], image: ["class", "clip-path", "clip-rule", "filter", "height", "id", "mask", "opacity", "requiredFeatures", "style", "systemLanguage", "transform", "width", "x", "xlink:href", "xlink:title", "y"], line: ["class", "clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "id", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform", "x1", "x2", "y1", "y2"], linearGradient: ["class", "id", "gradientTransform", "gradientUnits", "requiredFeatures", "spreadMethod", "systemLanguage", "x1", "x2", "xlink:href", "y1", "y2"], marker: ["id", "class", "markerHeight", "markerUnits", "markerWidth", "orient", "preserveAspectRatio", "refX", "refY", "systemLanguage", "viewBox"], mask: ["class", "height", "id", "maskContentUnits", "maskUnits", "width", "x", "y"], metadata: ["class", "id"], path: ["class", "clip-path", "clip-rule", "d", "fill", "fill-opacity", "fill-rule", "filter", "id", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform"], pattern: ["class", "height", "id", "patternContentUnits", "patternTransform", "patternUnits", "requiredFeatures", "style", "systemLanguage", "viewBox", "width", "x", "xlink:href", "y"], polygon: ["class", "clip-path", "clip-rule", "id", "fill", "fill-opacity", "fill-rule", "filter", "id", "class", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "points", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform"], polyline: ["class", "clip-path", "clip-rule", "id", "fill", "fill-opacity", "fill-rule", "filter", "marker-end", "marker-mid", "marker-start", "mask", "opacity", "points", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform"], radialGradient: ["class", "cx", "cy", "fx", "fy", "gradientTransform", "gradientUnits", "id", "r", "requiredFeatures", "spreadMethod", "systemLanguage", "xlink:href"], rect: ["class", "clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "height", "id", "mask", "opacity", "requiredFeatures", "rx", "ry", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform", "width", "x", "y"], stop: ["class", "id", "offset", "requiredFeatures", "stop-color", "stop-opacity", "style", "systemLanguage"], svg: ["class", "clip-path", "clip-rule", "filter", "id", "height", "mask", "preserveAspectRatio", "requiredFeatures", "style", "systemLanguage", "viewBox", "width", "x", "xmlns", "xmlns:se", "xmlns:xlink", "y"], "switch": ["class", "id", "requiredFeatures", "systemLanguage"], symbol: ["class", "fill", "fill-opacity", "fill-rule", "filter", "font-family", "font-size", "font-style", "font-weight", "id", "opacity", "preserveAspectRatio", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "transform", "viewBox"], text: ["class", "clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "font-family", "font-size", "font-style", "font-weight", "id", "mask", "opacity", "requiredFeatures", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "text-anchor", "transform", "x", "xml:space", "y"], textPath: ["class", "id", "method", "requiredFeatures", "spacing", "startOffset", "style", "systemLanguage", "transform", "xlink:href"], title: [], tspan: ["class", "clip-path", "clip-rule", "dx", "dy", "fill", "fill-opacity", "fill-rule", "filter", "font-family", "font-size", "font-style", "font-weight", "id", "mask", "opacity", "requiredFeatures", "rotate", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "systemLanguage", "text-anchor", "textLength", "transform", "x", "xml:space", "y"], use: ["class", "clip-path", "clip-rule", "fill", "fill-opacity", "fill-rule", "filter", "height", "id", "mask", "stroke", "stroke-dasharray", "stroke-dashoffset", "stroke-linecap", "stroke-linejoin", "stroke-miterlimit", "stroke-opacity", "stroke-width", "style", "transform", "width", "x", "xlink:href", "y"], annotation: ["encoding"], "annotation-xml": ["encoding"], maction: ["actiontype", "other", "selection"], math: ["class", "id", "display", "xmlns"], menclose: ["notation"], merror: [], mfrac: ["linethickness"], mi: ["mathvariant"], mmultiscripts: [], mn: [], mo: ["fence", "lspace", "maxsize", "minsize", "rspace", "stretchy"], mover: [], mpadded: ["lspace", "width", "height", "depth", "voffset"], mphantom: [], mprescripts: [], mroot: [], mrow: ["xlink:href", "xlink:type", "xmlns:xlink"], mspace: ["depth", "height", "width"], msqrt: [], mstyle: ["displaystyle", "mathbackground", "mathcolor", "mathvariant", "scriptlevel"], msub: [], msubsup: [], msup: [], mtable: ["align", "columnalign", "columnlines", "columnspacing", "displaystyle", "equalcolumns", "equalrows", "frame", "rowalign", "rowlines", "rowspacing", "width"], mtd: ["columnalign", "columnspan", "rowalign", "rowspan"], mtext: [], mtr: ["columnalign", "rowalign"], munder: [], munderover: [], none: [], semantics: []
        };
    var svgWhiteListNS_ = {};
    $.each(svgWhiteList_, function(elt, atts)
    {
        var attNS = {};
        $.each(atts, function(i, att)
        {
            if (att.indexOf(':') >= 0)
            {
                var v = att.split(':');
                attNS[v[1]] = NS[(v[0]).toUpperCase()]
            }
            else
            {
                attNS[att] = att == 'xmlns' ? NS.XMLNS : null
            }
        });
        svgWhiteListNS_[elt] = attNS
    });
    svgedit.sanitize.sanitizeSvg = function(node)
    {
        if (node.nodeType == 3)
        {
            node.nodeValue = node.nodeValue.replace(/^\s+|\s+$/g, '');
            if (node.nodeValue.length === 0)
            {
                node.parentNode.removeChild(node)
            }
        }
        if (node.nodeType != 1)
        {
            return
        }
        var doc = node.ownerDocument;
        var parent = node.parentNode;
        if (!doc || !parent)
        {
            return
        }
        var allowedAttrs = svgWhiteList_[node.nodeName];
        var allowedAttrsNS = svgWhiteListNS_[node.nodeName];
        var i;
        if (typeof allowedAttrs !== 'undefined')
        {
            var seAttrs = [];
            i = node.attributes.length;
            while (i--)
            {
                var attr = node.attributes.item(i);
                var attrName = attr.nodeName;
                var attrLocalName = attr.localName;
                var attrNsURI = attr.namespaceURI;
                if (!(allowedAttrsNS.hasOwnProperty(attrLocalName) && attrNsURI == allowedAttrsNS[attrLocalName] && attrNsURI != NS.XMLNS) && !(attrNsURI == NS.XMLNS && REVERSE_NS[attr.nodeValue]))
                {
                    if (attrName.indexOf('se:') === 0)
                    {
                        seAttrs.push([attrName, attr.nodeValue])
                    }
                    node.removeAttributeNS(attrNsURI, attrLocalName)
                }
                if (svgedit.browser.isGecko())
                {
                    switch (attrName)
                    {
                        case'transform':
                        case'gradientTransform':
                        case'patternTransform':
                            var val = attr.nodeValue.replace(/(\d)-/g, '$1 -');
                            node.setAttribute(attrName, val);
                            break
                    }
                }
                if (attrName == 'style')
                {
                    var props = attr.nodeValue.split(';'),
                        p = props.length;
                    while (p--)
                    {
                        var nv = props[p].split(':');
                        var styleAttrName = $.trim(nv[0]);
                        var styleAttrVal = $.trim(nv[1]);
                        if (allowedAttrs.indexOf(styleAttrName) >= 0)
                        {
                            node.setAttribute(styleAttrName, styleAttrVal)
                        }
                    }
                    node.removeAttribute('style')
                }
            }
            $.each(seAttrs, function(i, attr)
            {
                node.setAttributeNS(NS.SE, attr[0], attr[1])
            });
            var href = svgedit.utilities.getHref(node);
            if (href && ['filter', 'linearGradient', 'pattern', 'radialGradient', 'textPath', 'use'].indexOf(node.nodeName) >= 0)
            {
                if (href[0] != '#')
                {
                    svgedit.utilities.setHref(node, '');
                    node.removeAttributeNS(NS.XLINK, 'href')
                }
            }
            if (node.nodeName == 'use' && !svgedit.utilities.getHref(node))
            {
                parent.removeChild(node);
                return
            }
            $.each(['clip-path', 'fill', 'filter', 'marker-end', 'marker-mid', 'marker-start', 'mask', 'stroke'], function(i, attr)
            {
                var val = node.getAttribute(attr);
                if (val)
                {
                    val = svgedit.utilities.getUrlFromAttr(val);
                    if (val && val[0] !== '#')
                    {
                        node.setAttribute(attr, '');
                        node.removeAttribute(attr)
                    }
                }
            });
            i = node.childNodes.length;
            while (i--)
            {
                svgedit.sanitize.sanitizeSvg(node.childNodes.item(i))
            }
        }
        else
        {
            var children = [];
            while (node.hasChildNodes())
            {
                children.push(parent.insertBefore(node.firstChild, node))
            }
            parent.removeChild(node);
            i = children.length;
            while (i--)
            {
                svgedit.sanitize.sanitizeSvg(children[i])
            }
        }
    }
}());
(function()
{
    'use strict';
    if (!svgedit.history)
    {
        svgedit.history = {}
    }
    svgedit.history.HistoryEventTypes = {
        BEFORE_APPLY: 'before_apply', AFTER_APPLY: 'after_apply', BEFORE_UNAPPLY: 'before_unapply', AFTER_UNAPPLY: 'after_unapply'
    };
    var removedElements = {};
    svgedit.history.MoveElementCommand = function(elem, oldNextSibling, oldParent, text)
    {
        this.elem = elem;
        this.text = text ? ("Move " + elem.tagName + " to " + text) : ("Move " + elem.tagName);
        this.oldNextSibling = oldNextSibling;
        this.oldParent = oldParent;
        this.newNextSibling = elem.nextSibling;
        this.newParent = elem.parentNode
    };
    svgedit.history.MoveElementCommand.type = function()
    {
        return 'svgedit.history.MoveElementCommand'
    };
    svgedit.history.MoveElementCommand.prototype.type = svgedit.history.MoveElementCommand.type;
    svgedit.history.MoveElementCommand.prototype.getText = function()
    {
        return this.text
    };
    svgedit.history.MoveElementCommand.prototype.apply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this)
        }
        this.elem = this.newParent.insertBefore(this.elem, this.newNextSibling);
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this)
        }
    };
    svgedit.history.MoveElementCommand.prototype.unapply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this)
        }
        this.elem = this.oldParent.insertBefore(this.elem, this.oldNextSibling);
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this)
        }
    };
    svgedit.history.MoveElementCommand.prototype.elements = function()
    {
        return [this.elem]
    };
    svgedit.history.InsertElementCommand = function(elem, text)
    {
        this.elem = elem;
        this.text = text || ("Create " + elem.tagName);
        this.parent = elem.parentNode;
        this.nextSibling = this.elem.nextSibling
    };
    svgedit.history.InsertElementCommand.type = function()
    {
        return 'svgedit.history.InsertElementCommand'
    };
    svgedit.history.InsertElementCommand.prototype.type = svgedit.history.InsertElementCommand.type;
    svgedit.history.InsertElementCommand.prototype.getText = function()
    {
        return this.text
    };
    svgedit.history.InsertElementCommand.prototype.apply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this)
        }
        this.elem = this.parent.insertBefore(this.elem, this.nextSibling);
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this)
        }
    };
    svgedit.history.InsertElementCommand.prototype.unapply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this)
        }
        this.parent = this.elem.parentNode;
        this.elem = this.elem.parentNode.removeChild(this.elem);
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this)
        }
    };
    svgedit.history.InsertElementCommand.prototype.elements = function()
    {
        return [this.elem]
    };
    svgedit.history.RemoveElementCommand = function(elem, oldNextSibling, oldParent, text)
    {
        this.elem = elem;
        this.text = text || ("Delete " + elem.tagName);
        this.nextSibling = oldNextSibling;
        this.parent = oldParent;
        svgedit.transformlist.removeElementFromListMap(elem)
    };
    svgedit.history.RemoveElementCommand.type = function()
    {
        return 'svgedit.history.RemoveElementCommand'
    };
    svgedit.history.RemoveElementCommand.prototype.type = svgedit.history.RemoveElementCommand.type;
    svgedit.history.RemoveElementCommand.prototype.getText = function()
    {
        return this.text
    };
    svgedit.history.RemoveElementCommand.prototype.apply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this)
        }
        svgedit.transformlist.removeElementFromListMap(this.elem);
        this.parent = this.elem.parentNode;
        this.elem = this.parent.removeChild(this.elem);
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this)
        }
    };
    svgedit.history.RemoveElementCommand.prototype.unapply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this)
        }
        svgedit.transformlist.removeElementFromListMap(this.elem);
        if (this.nextSibling == null)
        {
            if (window.console)
            {
                console.log('Error: reference element was lost')
            }
        }
        this.parent.insertBefore(this.elem, this.nextSibling);
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this)
        }
    };
    svgedit.history.RemoveElementCommand.prototype.elements = function()
    {
        return [this.elem]
    };
    svgedit.history.ChangeElementCommand = function(elem, attrs, text)
    {
        this.elem = elem;
        this.text = text ? ("Change " + elem.tagName + " " + text) : ("Change " + elem.tagName);
        this.newValues = {};
        this.oldValues = attrs;
        var attr;
        for (attr in attrs)
        {
            if (attr == "#text")
            {
                this.newValues[attr] = elem.textContent
            }
            else if (attr == "#href")
            {
                this.newValues[attr] = svgedit.utilities.getHref(elem)
            }
            else
            {
                this.newValues[attr] = elem.getAttribute(attr)
            }
        }
    };
    svgedit.history.ChangeElementCommand.type = function()
    {
        return 'svgedit.history.ChangeElementCommand'
    };
    svgedit.history.ChangeElementCommand.prototype.type = svgedit.history.ChangeElementCommand.type;
    svgedit.history.ChangeElementCommand.prototype.getText = function()
    {
        return this.text
    };
    svgedit.history.ChangeElementCommand.prototype.apply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this)
        }
        var bChangedTransform = false;
        var attr;
        for (attr in this.newValues)
        {
            if (this.newValues[attr])
            {
                if (attr == "#text")
                {
                    this.elem.textContent = this.newValues[attr]
                }
                else if (attr == "#href")
                {
                    svgedit.utilities.setHref(this.elem, this.newValues[attr])
                }
                else
                {
                    this.elem.setAttribute(attr, this.newValues[attr])
                }
            }
            else
            {
                if (attr == "#text")
                {
                    this.elem.textContent = ""
                }
                else
                {
                    this.elem.setAttribute(attr, "");
                    this.elem.removeAttribute(attr)
                }
            }
            if (attr == "transform")
            {
                bChangedTransform = true
            }
        }
        if (!bChangedTransform)
        {
            var angle = svgedit.utilities.getRotationAngle(this.elem);
            if (angle)
            {
                var bbox = elem.getBBox();
                var cx = bbox.x + bbox.width / 2,
                    cy = bbox.y + bbox.height / 2;
                var rotate = ["rotate(", angle, " ", cx, ",", cy, ")"].join('');
                if (rotate != elem.getAttribute("transform"))
                {
                    elem.setAttribute("transform", rotate)
                }
            }
        }
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this)
        }
        return true
    };
    svgedit.history.ChangeElementCommand.prototype.unapply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this)
        }
        var bChangedTransform = false;
        var attr;
        for (attr in this.oldValues)
        {
            if (this.oldValues[attr])
            {
                if (attr == "#text")
                {
                    this.elem.textContent = this.oldValues[attr]
                }
                else if (attr == "#href")
                {
                    svgedit.utilities.setHref(this.elem, this.oldValues[attr])
                }
                else
                {
                    this.elem.setAttribute(attr, this.oldValues[attr])
                }
            }
            else
            {
                if (attr == "#text")
                {
                    this.elem.textContent = ""
                }
                else
                {
                    this.elem.removeAttribute(attr)
                }
            }
            if (attr == "transform")
            {
                bChangedTransform = true
            }
        }
        if (!bChangedTransform)
        {
            var angle = svgedit.utilities.getRotationAngle(this.elem);
            if (angle)
            {
                var bbox = elem.getBBox();
                var cx = bbox.x + bbox.width / 2,
                    cy = bbox.y + bbox.height / 2;
                var rotate = ["rotate(", angle, " ", cx, ",", cy, ")"].join('');
                if (rotate != elem.getAttribute("transform"))
                {
                    elem.setAttribute("transform", rotate)
                }
            }
        }
        svgedit.transformlist.removeElementFromListMap(this.elem);
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this)
        }
        return true
    };
    svgedit.history.ChangeElementCommand.prototype.elements = function()
    {
        return [this.elem]
    };
    svgedit.history.BatchCommand = function(text)
    {
        this.text = text || "Batch Command";
        this.stack = []
    };
    svgedit.history.BatchCommand.type = function()
    {
        return 'svgedit.history.BatchCommand'
    };
    svgedit.history.BatchCommand.prototype.type = svgedit.history.BatchCommand.type;
    svgedit.history.BatchCommand.prototype.getText = function()
    {
        return this.text
    };
    svgedit.history.BatchCommand.prototype.apply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_APPLY, this)
        }
        var i,
            len = this.stack.length;
        for (i = 0; i < len; ++i)
        {
            this.stack[i].apply(handler)
        }
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_APPLY, this)
        }
    };
    svgedit.history.BatchCommand.prototype.unapply = function(handler)
    {
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.BEFORE_UNAPPLY, this)
        }
        var i;
        for (i = this.stack.length - 1; i >= 0; i--)
        {
            this.stack[i].unapply(handler)
        }
        if (handler)
        {
            handler.handleHistoryEvent(svgedit.history.HistoryEventTypes.AFTER_UNAPPLY, this)
        }
    };
    svgedit.history.BatchCommand.prototype.elements = function()
    {
        var elems = [];
        var cmd = this.stack.length;
        while (cmd--)
        {
            var thisElems = this.stack[cmd].elements();
            var elem = thisElems.length;
            while (elem--)
            {
                if (elems.indexOf(thisElems[elem]) == -1)
                {
                    elems.push(thisElems[elem])
                }
            }
        }
        return elems
    };
    svgedit.history.BatchCommand.prototype.addSubCommand = function(cmd)
    {
        this.stack.push(cmd)
    };
    svgedit.history.BatchCommand.prototype.isEmpty = function()
    {
        return this.stack.length === 0
    };
    svgedit.history.UndoManager = function(historyEventHandler)
    {
        this.handler_ = historyEventHandler || null;
        this.undoStackPointer = 0;
        this.undoStack = [];
        this.undoChangeStackPointer = -1;
        this.undoableChangeStack = []
    };
    svgedit.history.UndoManager.prototype.resetUndoStack = function()
    {
        this.undoStack = [];
        this.undoStackPointer = 0
    };
    svgedit.history.UndoManager.prototype.getUndoStackSize = function()
    {
        return this.undoStackPointer
    };
    svgedit.history.UndoManager.prototype.getRedoStackSize = function()
    {
        return this.undoStack.length - this.undoStackPointer
    };
    svgedit.history.UndoManager.prototype.getNextUndoCommandText = function()
    {
        return this.undoStackPointer > 0 ? this.undoStack[this.undoStackPointer - 1].getText() : ""
    };
    svgedit.history.UndoManager.prototype.getNextRedoCommandText = function()
    {
        return this.undoStackPointer < this.undoStack.length ? this.undoStack[this.undoStackPointer].getText() : ""
    };
    svgedit.history.UndoManager.prototype.undo = function()
    {
        if (this.undoStackPointer > 0)
        {
            var cmd = this.undoStack[--this.undoStackPointer];
            cmd.unapply(this.handler_)
        }
    };
    svgedit.history.UndoManager.prototype.redo = function()
    {
        if (this.undoStackPointer < this.undoStack.length && this.undoStack.length > 0)
        {
            var cmd = this.undoStack[this.undoStackPointer++];
            cmd.apply(this.handler_)
        }
    };
    svgedit.history.UndoManager.prototype.addCommandToHistory = function(cmd)
    {
        if (this.undoStackPointer < this.undoStack.length && this.undoStack.length > 0)
        {
            this.undoStack = this.undoStack.splice(0, this.undoStackPointer)
        }
        this.undoStack.push(cmd);
        this.undoStackPointer = this.undoStack.length
    };
    svgedit.history.UndoManager.prototype.beginUndoableChange = function(attrName, elems)
    {
        var p = ++this.undoChangeStackPointer;
        var i = elems.length;
        var oldValues = new Array(i),
            elements = new Array(i);
        while (i--)
        {
            var elem = elems[i];
            if (elem == null)
            {
                continue
            }
            elements[i] = elem;
            oldValues[i] = elem.getAttribute(attrName)
        }
        this.undoableChangeStack[p] = {
            attrName: attrName, oldValues: oldValues, elements: elements
        }
    };
    svgedit.history.UndoManager.prototype.finishUndoableChange = function()
    {
        var p = this.undoChangeStackPointer--;
        var changeset = this.undoableChangeStack[p];
        var i = changeset.elements.length;
        var attrName = changeset.attrName;
        var batchCmd = new svgedit.history.BatchCommand("Change " + attrName);
        while (i--)
        {
            var elem = changeset.elements[i];
            if (elem == null)
            {
                continue
            }
            var changes = {};
            changes[attrName] = changeset.oldValues[i];
            if (changes[attrName] != elem.getAttribute(attrName))
            {
                batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(elem, changes, attrName))
            }
        }
        this.undoableChangeStack[p] = null;
        return batchCmd
    }
}());
var svgedit = svgedit || {};
(function()
{
    'use strict';
    if (!svgedit.coords)
    {
        svgedit.coords = {}
    }
    var pathMap = [0, 'z', 'M', 'm', 'L', 'l', 'C', 'c', 'Q', 'q', 'A', 'a', 'H', 'h', 'V', 'v', 'S', 's', 'T', 't'];
    var editorContext_ = null;
    svgedit.coords.init = function(editorContext)
    {
        editorContext_ = editorContext
    };
    svgedit.coords.remapElement = function(selected, changes, m)
    {
        var i,
            type,
            remap = function(x, y)
            {
                return svgedit.math.transformPoint(x, y, m)
            },
            scalew = function(w)
            {
                return m.a * w
            },
            scaleh = function(h)
            {
                return m.d * h
            },
            doSnapping = editorContext_.getGridSnapping() && selected.parentNode.parentNode.localName === 'svg',
            finishUp = function()
            {
                var o;
                if (doSnapping)
                {
                    for (o in changes)
                    {
                        changes[o] = svgedit.utilities.snapToGrid(changes[o])
                    }
                }
                svgedit.utilities.assignAttributes(selected, changes, 1000, true)
            },
            box = svgedit.utilities.getBBox(selected);
        for (i = 0; i < 2; i++)
        {
            type = i === 0 ? 'fill' : 'stroke';
            var attrVal = selected.getAttribute(type);
            if (attrVal && attrVal.indexOf('url(') === 0)
            {
                if (m.a < 0 || m.d < 0)
                {
                    var grad = svgedit.utilities.getRefElem(attrVal);
                    var newgrad = grad.cloneNode(true);
                    if (m.a < 0)
                    {
                        var x1 = newgrad.getAttribute('x1');
                        var x2 = newgrad.getAttribute('x2');
                        newgrad.setAttribute('x1', -(x1 - 1));
                        newgrad.setAttribute('x2', -(x2 - 1))
                    }
                    if (m.d < 0)
                    {
                        var y1 = newgrad.getAttribute('y1');
                        var y2 = newgrad.getAttribute('y2');
                        newgrad.setAttribute('y1', -(y1 - 1));
                        newgrad.setAttribute('y2', -(y2 - 1))
                    }
                    newgrad.id = editorContext_.getDrawing().getNextId();
                    svgedit.utilities.findDefs().appendChild(newgrad);
                    selected.setAttribute(type, 'url(#' + newgrad.id + ')')
                }
            }
        }
        var elName = selected.tagName;
        var chlist,
            mt;
        if (elName === 'g' || elName === 'text' || elName == 'tspan' || elName === 'use')
        {
            if (m.a == 1 && m.b == 0 && m.c == 0 && m.d == 1 && (m.e != 0 || m.f != 0))
            {
                var existing = svgedit.math.transformListToTransform(selected).matrix,
                    t_new = svgedit.math.matrixMultiply(existing.inverse(), m, existing);
                changes.x = parseFloat(changes.x) + t_new.e;
                changes.y = parseFloat(changes.y) + t_new.f
            }
            else
            {
                chlist = svgedit.transformlist.getTransformList(selected);
                mt = svgroot.createSVGTransform();
                mt.setMatrix(svgedit.math.matrixMultiply(svgedit.math.transformListToTransform(chlist).matrix, m));
                chlist.clear();
                chlist.appendItem(mt)
            }
        }
        var c,
            pt,
            pt1,
            pt2,
            len;
        switch (elName)
        {
            case'foreignObject':
            case'rect':
            case'image':
                if (elName === 'image' && (m.a < 0 || m.d < 0))
                {
                    chlist = svgedit.transformlist.getTransformList(selected);
                    mt = svgroot.createSVGTransform();
                    mt.setMatrix(svgedit.math.matrixMultiply(svgedit.math.transformListToTransform(chlist).matrix, m));
                    chlist.clear();
                    chlist.appendItem(mt)
                }
                else
                {
                    pt1 = remap(changes.x, changes.y);
                    changes.width = scalew(changes.width);
                    changes.height = scaleh(changes.height);
                    changes.x = pt1.x + Math.min(0, changes.width);
                    changes.y = pt1.y + Math.min(0, changes.height);
                    changes.width = Math.abs(changes.width);
                    changes.height = Math.abs(changes.height)
                }
                finishUp();
                break;
            case'ellipse':
                c = remap(changes.cx, changes.cy);
                changes.cx = c.x;
                changes.cy = c.y;
                changes.rx = scalew(changes.rx);
                changes.ry = scaleh(changes.ry);
                changes.rx = Math.abs(changes.rx);
                changes.ry = Math.abs(changes.ry);
                finishUp();
                break;
            case'circle':
                c = remap(changes.cx, changes.cy);
                changes.cx = c.x;
                changes.cy = c.y;
                var tbox = svgedit.math.transformBox(box.x, box.y, box.width, box.height, m);
                var w = tbox.tr.x - tbox.tl.x,
                    h = tbox.bl.y - tbox.tl.y;
                changes.r = Math.min(w / 2, h / 2);
                if (changes.r)
                {
                    changes.r = Math.abs(changes.r)
                }
                finishUp();
                break;
            case'line':
                pt1 = remap(changes.x1, changes.y1);
                pt2 = remap(changes.x2, changes.y2);
                changes.x1 = pt1.x;
                changes.y1 = pt1.y;
                changes.x2 = pt2.x;
                changes.y2 = pt2.y;
            case'text':
            case'tspan':
            case'use':
                finishUp();
                break;
            case'g':
                var gsvg = $(selected).data('gsvg');
                if (gsvg)
                {
                    svgedit.utilities.assignAttributes(gsvg, changes, 1000, true)
                }
                break;
            case'polyline':
            case'polygon':
                len = changes.points.length;
                for (i = 0; i < len; ++i)
                {
                    pt = changes.points[i];
                    pt = remap(pt.x, pt.y);
                    changes.points[i].x = pt.x;
                    changes.points[i].y = pt.y
                }
                len = changes.points.length;
                var pstr = '';
                for (i = 0; i < len; ++i)
                {
                    pt = changes.points[i];
                    pstr += pt.x + ',' + pt.y + ' '
                }
                selected.setAttribute('points', pstr);
                break;
            case'path':
                var seg;
                var segList = selected.pathSegList;
                len = segList.numberOfItems;
                changes.d = [];
                for (i = 0; i < len; ++i)
                {
                    seg = segList.getItem(i);
                    changes.d[i] = {
                        type: seg.pathSegType, x: seg.x, y: seg.y, x1: seg.x1, y1: seg.y1, x2: seg.x2, y2: seg.y2, r1: seg.r1, r2: seg.r2, angle: seg.angle, largeArcFlag: seg.largeArcFlag, sweepFlag: seg.sweepFlag
                    }
                }
                len = changes.d.length;
                var firstseg = changes.d[0],
                    currentpt = remap(firstseg.x, firstseg.y);
                changes.d[0].x = currentpt.x;
                changes.d[0].y = currentpt.y;
                for (i = 1; i < len; ++i)
                {
                    seg = changes.d[i];
                    type = seg.type;
                    if (type % 2 == 0)
                    {
                        var thisx = (seg.x != undefined) ? seg.x : currentpt.x,
                            thisy = (seg.y != undefined) ? seg.y : currentpt.y;
                        pt = remap(thisx, thisy);
                        pt1 = remap(seg.x1, seg.y1);
                        pt2 = remap(seg.x2, seg.y2);
                        seg.x = pt.x;
                        seg.y = pt.y;
                        seg.x1 = pt1.x;
                        seg.y1 = pt1.y;
                        seg.x2 = pt2.x;
                        seg.y2 = pt2.y;
                        seg.r1 = scalew(seg.r1);
                        seg.r2 = scaleh(seg.r2)
                    }
                    else
                    {
                        seg.x = scalew(seg.x);
                        seg.y = scaleh(seg.y);
                        seg.x1 = scalew(seg.x1);
                        seg.y1 = scaleh(seg.y1);
                        seg.x2 = scalew(seg.x2);
                        seg.y2 = scaleh(seg.y2);
                        seg.r1 = scalew(seg.r1);
                        seg.r2 = scaleh(seg.r2)
                    }
                }
                var dstr = '';
                len = changes.d.length;
                for (i = 0; i < len; ++i)
                {
                    seg = changes.d[i];
                    type = seg.type;
                    dstr += pathMap[type];
                    switch (type)
                    {
                        case 13:
                        case 12:
                            dstr += seg.x + ' ';
                            break;
                        case 15:
                        case 14:
                            dstr += seg.y + ' ';
                            break;
                        case 3:
                        case 5:
                        case 19:
                        case 2:
                        case 4:
                        case 18:
                            dstr += seg.x + ',' + seg.y + ' ';
                            break;
                        case 7:
                        case 6:
                            dstr += seg.x1 + ',' + seg.y1 + ' ' + seg.x2 + ',' + seg.y2 + ' ' + seg.x + ',' + seg.y + ' ';
                            break;
                        case 9:
                        case 8:
                            dstr += seg.x1 + ',' + seg.y1 + ' ' + seg.x + ',' + seg.y + ' ';
                            break;
                        case 11:
                        case 10:
                            dstr += seg.r1 + ',' + seg.r2 + ' ' + seg.angle + ' ' + (+seg.largeArcFlag) + ' ' + (+seg.sweepFlag) + ' ' + seg.x + ',' + seg.y + ' ';
                            break;
                        case 17:
                        case 16:
                            dstr += seg.x2 + ',' + seg.y2 + ' ' + seg.x + ',' + seg.y + ' ';
                            break
                    }
                }
                selected.setAttribute('d', dstr);
                break
        }
    }
}());
var svgedit = svgedit || {};
(function()
{
    if (!svgedit.recalculate)
    {
        svgedit.recalculate = {}
    }
    var NS = svgedit.NS;
    var context_;
    svgedit.recalculate.init = function(editorContext)
    {
        context_ = editorContext
    };
    svgedit.recalculate.updateClipPath = function(attr, tx, ty)
    {
        var path = getRefElem(attr).firstChild;
        var cp_xform = svgedit.transformlist.getTransformList(path);
        var newxlate = context_.getSVGRoot().createSVGTransform();
        newxlate.setTranslate(tx, ty);
        cp_xform.appendItem(newxlate);
        svgedit.recalculate.recalculateDimensions(path)
    };
    svgedit.recalculate.recalculateDimensions = function(selected)
    {
        if (selected == null)
        {
            return null
        }
        if (selected.nodeName == "svg" && navigator.userAgent.indexOf("Firefox/20") >= 0)
        {
            return null
        }
        var svgroot = context_.getSVGRoot();
        var tlist = svgedit.transformlist.getTransformList(selected);
        var k;
        if (tlist && tlist.numberOfItems > 0)
        {
            k = tlist.numberOfItems;
            while (k--)
            {
                var xform = tlist.getItem(k);
                if (xform.type === 0)
                {
                    tlist.removeItem(k)
                }
                else if (xform.type === 1)
                {
                    if (svgedit.math.isIdentity(xform.matrix))
                    {
                        tlist.removeItem(k)
                    }
                }
                else if (xform.type === 4)
                {
                    if (xform.angle === 0)
                    {
                        tlist.removeItem(k)
                    }
                }
            }
            if (tlist.numberOfItems === 1 && svgedit.utilities.getRotationAngle(selected))
            {
                return null
            }
        }
        if (!tlist || tlist.numberOfItems == 0)
        {
            selected.setAttribute('transform', '');
            selected.removeAttribute('transform');
            return null
        }
        if (tlist)
        {
            k = tlist.numberOfItems;
            var mxs = [];
            while (k--)
            {
                var xform = tlist.getItem(k);
                if (xform.type === 1)
                {
                    mxs.push([xform.matrix, k])
                }
                else if (mxs.length)
                {
                    mxs = []
                }
            }
            if (mxs.length === 2)
            {
                var m_new = svgroot.createSVGTransformFromMatrix(svgedit.math.matrixMultiply(mxs[1][0], mxs[0][0]));
                tlist.removeItem(mxs[0][1]);
                tlist.removeItem(mxs[1][1]);
                tlist.insertItemBefore(m_new, mxs[1][1])
            }
            k = tlist.numberOfItems;
            if (k >= 2 && tlist.getItem(k - 2).type === 1 && tlist.getItem(k - 1).type === 2)
            {
                var mt = svgroot.createSVGTransform();
                var m = svgedit.math.matrixMultiply(tlist.getItem(k - 2).matrix, tlist.getItem(k - 1).matrix);
                mt.setMatrix(m);
                tlist.removeItem(k - 2);
                tlist.removeItem(k - 2);
                tlist.appendItem(mt)
            }
        }
        switch (selected.tagName)
        {
            case'line':
            case'polyline':
            case'polygon':
            case'path':
                break;
            default:
                if ((tlist.numberOfItems === 1 && tlist.getItem(0).type === 1) || (tlist.numberOfItems === 2 && tlist.getItem(0).type === 1 && tlist.getItem(0).type === 4))
                {
                    return null
                }
        }
        var gsvg = $(selected).data('gsvg');
        var batchCmd = new svgedit.history.BatchCommand('Transform');
        var changes = {},
            initial = null,
            attrs = [];
        switch (selected.tagName)
        {
            case'line':
                attrs = ['x1', 'y1', 'x2', 'y2'];
                break;
            case'circle':
                attrs = ['cx', 'cy', 'r'];
                break;
            case'ellipse':
                attrs = ['cx', 'cy', 'rx', 'ry'];
                break;
            case'foreignObject':
            case'rect':
            case'image':
                attrs = ['width', 'height', 'x', 'y'];
                break;
            case'use':
            case'text':
            case'tspan':
                attrs = ['x', 'y'];
                break;
            case'polygon':
            case'polyline':
                initial = {};
                initial.points = selected.getAttribute('points');
                var list = selected.points;
                var len = list.numberOfItems;
                changes.points = new Array(len);
                var i;
                for (i = 0; i < len; ++i)
                {
                    var pt = list.getItem(i);
                    changes.points[i] = {
                        x: pt.x, y: pt.y
                    }
                }
                break;
            case'path':
                initial = {};
                initial.d = selected.getAttribute('d');
                changes.d = selected.getAttribute('d');
                break
        }
        if (attrs.length)
        {
            changes = $(selected).attr(attrs);
            $.each(changes, function(attr, val)
            {
                changes[attr] = svgedit.units.convertToNum(attr, val)
            })
        }
        else if (gsvg)
        {
            changes = {
                x: $(gsvg).attr('x') || 0, y: $(gsvg).attr('y') || 0
            }
        }
        if (initial == null)
        {
            initial = $.extend(true, {}, changes);
            $.each(initial, function(attr, val)
            {
                initial[attr] = svgedit.units.convertToNum(attr, val)
            })
        }
        initial.transform = context_.getStartTransform() || '';
        if ((selected.tagName == 'g' && !gsvg) || selected.tagName == 'a')
        {
            var box = svgedit.utilities.getBBox(selected),
                oldcenter = {
                    x: box.x + box.width / 2, y: box.y + box.height / 2
                },
                newcenter = svgedit.math.transformPoint(box.x + box.width / 2, box.y + box.height / 2, svgedit.math.transformListToTransform(tlist).matrix),
                m = svgroot.createSVGMatrix();
            var gangle = svgedit.utilities.getRotationAngle(selected);
            if (gangle)
            {
                var a = gangle * Math.PI / 180;
                if (Math.abs(a) > (1.0e-10))
                {
                    var s = Math.sin(a) / (1 - Math.cos(a))
                }
                else
                {
                    var s = 2 / a
                }
                var i;
                for (i = 0; i < tlist.numberOfItems; ++i)
                {
                    var xform = tlist.getItem(i);
                    if (xform.type == 4)
                    {
                        var rm = xform.matrix;
                        oldcenter.y = (s * rm.e + rm.f) / 2;
                        oldcenter.x = (rm.e - s * rm.f) / 2;
                        tlist.removeItem(i);
                        break
                    }
                }
            }
            var tx = 0,
                ty = 0,
                operation = 0,
                N = tlist.numberOfItems;
            if (N)
            {
                var first_m = tlist.getItem(0).matrix
            }
            if (N >= 3 && tlist.getItem(N - 2).type == 3 && tlist.getItem(N - 3).type == 2 && tlist.getItem(N - 1).type == 2)
            {
                operation = 3;
                var tm = tlist.getItem(N - 3).matrix,
                    sm = tlist.getItem(N - 2).matrix,
                    tmn = tlist.getItem(N - 1).matrix;
                var children = selected.childNodes;
                var c = children.length;
                while (c--)
                {
                    var child = children.item(c);
                    tx = 0;
                    ty = 0;
                    if (child.nodeType == 1)
                    {
                        var childTlist = svgedit.transformlist.getTransformList(child);
                        if (!childTlist)
                        {
                            continue
                        }
                        var m = svgedit.math.transformListToTransform(childTlist).matrix;
                        var angle = svgedit.utilities.getRotationAngle(child);
                        var oldStartTransform = context_.getStartTransform();
                        var childxforms = [];
                        context_.setStartTransform(child.getAttribute('transform'));
                        if (angle || svgedit.math.hasMatrixTransform(childTlist))
                        {
                            var e2t = svgroot.createSVGTransform();
                            e2t.setMatrix(svgedit.math.matrixMultiply(tm, sm, tmn, m));
                            childTlist.clear();
                            childTlist.appendItem(e2t);
                            childxforms.push(e2t)
                        }
                        else
                        {
                            var t2n = svgedit.math.matrixMultiply(m.inverse(), tmn, m);
                            var t2 = svgroot.createSVGMatrix();
                            t2.e = -t2n.e;
                            t2.f = -t2n.f;
                            var s2 = svgedit.math.matrixMultiply(t2.inverse(), m.inverse(), tm, sm, tmn, m, t2n.inverse());
                            var translateOrigin = svgroot.createSVGTransform(),
                                scale = svgroot.createSVGTransform(),
                                translateBack = svgroot.createSVGTransform();
                            translateOrigin.setTranslate(t2n.e, t2n.f);
                            scale.setScale(s2.a, s2.d);
                            translateBack.setTranslate(t2.e, t2.f);
                            childTlist.appendItem(translateBack);
                            childTlist.appendItem(scale);
                            childTlist.appendItem(translateOrigin);
                            childxforms.push(translateBack);
                            childxforms.push(scale);
                            childxforms.push(translateOrigin)
                        }
                        batchCmd.addSubCommand(svgedit.recalculate.recalculateDimensions(child));
                        context_.setStartTransform(oldStartTransform)
                    }
                }
                tlist.removeItem(N - 1);
                tlist.removeItem(N - 2);
                tlist.removeItem(N - 3)
            }
            else if (N >= 3 && tlist.getItem(N - 1).type == 1)
            {
                operation = 3;
                m = svgedit.math.transformListToTransform(tlist).matrix;
                var e2t = svgroot.createSVGTransform();
                e2t.setMatrix(m);
                tlist.clear();
                tlist.appendItem(e2t)
            }
            else if ((N == 1 || (N > 1 && tlist.getItem(1).type != 3)) && tlist.getItem(0).type == 2)
            {
                operation = 2;
                var T_M = svgedit.math.transformListToTransform(tlist).matrix;
                tlist.removeItem(0);
                var M_inv = svgedit.math.transformListToTransform(tlist).matrix.inverse();
                var M2 = svgedit.math.matrixMultiply(M_inv, T_M);
                tx = M2.e;
                ty = M2.f;
                if (tx != 0 || ty != 0)
                {
                    var children = selected.childNodes;
                    var c = children.length;
                    var clipPaths_done = [];
                    while (c--)
                    {
                        var child = children.item(c);
                        if (child.nodeType == 1)
                        {
                            if (child.getAttribute('clip-path'))
                            {
                                var attr = child.getAttribute('clip-path');
                                if (clipPaths_done.indexOf(attr) === -1)
                                {
                                    svgedit.recalculate.updateClipPath(attr, tx, ty);
                                    clipPaths_done.push(attr)
                                }
                            }
                            var oldStartTransform = context_.getStartTransform();
                            context_.setStartTransform(child.getAttribute('transform'));
                            var childTlist = svgedit.transformlist.getTransformList(child);
                            if (childTlist)
                            {
                                var newxlate = svgroot.createSVGTransform();
                                newxlate.setTranslate(tx, ty);
                                if (childTlist.numberOfItems)
                                {
                                    childTlist.insertItemBefore(newxlate, 0)
                                }
                                else
                                {
                                    childTlist.appendItem(newxlate)
                                }
                                batchCmd.addSubCommand(svgedit.recalculate.recalculateDimensions(child));
                                var uses = selected.getElementsByTagNameNS(NS.SVG, 'use');
                                var href = '#' + child.id;
                                var u = uses.length;
                                while (u--)
                                {
                                    var useElem = uses.item(u);
                                    if (href == svgedit.utilities.getHref(useElem))
                                    {
                                        var usexlate = svgroot.createSVGTransform();
                                        usexlate.setTranslate(-tx, -ty);
                                        svgedit.transformlist.getTransformList(useElem).insertItemBefore(usexlate, 0);
                                        batchCmd.addSubCommand(svgedit.recalculate.recalculateDimensions(useElem))
                                    }
                                }
                                context_.setStartTransform(oldStartTransform)
                            }
                        }
                    }
                    clipPaths_done = [];
                    context_.setStartTransform(oldStartTransform)
                }
            }
            else if (N == 1 && tlist.getItem(0).type == 1 && !gangle)
            {
                operation = 1;
                var m = tlist.getItem(0).matrix,
                    children = selected.childNodes,
                    c = children.length;
                while (c--)
                {
                    var child = children.item(c);
                    if (child.nodeType == 1)
                    {
                        var oldStartTransform = context_.getStartTransform();
                        context_.setStartTransform(child.getAttribute('transform'));
                        var childTlist = svgedit.transformlist.getTransformList(child);
                        if (!childTlist)
                        {
                            continue
                        }
                        var em = svgedit.math.matrixMultiply(m, svgedit.math.transformListToTransform(childTlist).matrix);
                        var e2m = svgroot.createSVGTransform();
                        e2m.setMatrix(em);
                        childTlist.clear();
                        childTlist.appendItem(e2m, 0);
                        batchCmd.addSubCommand(svgedit.recalculate.recalculateDimensions(child));
                        context_.setStartTransform(oldStartTransform);
                        var sw = child.getAttribute('stroke-width');
                        if (child.getAttribute('stroke') !== 'none' && !isNaN(sw))
                        {
                            var avg = (Math.abs(em.a) + Math.abs(em.d)) / 2;
                            child.setAttribute('stroke-width', sw * avg)
                        }
                    }
                }
                tlist.clear()
            }
            else
            {
                if (gangle)
                {
                    var newRot = svgroot.createSVGTransform();
                    newRot.setRotate(gangle, newcenter.x, newcenter.y);
                    if (tlist.numberOfItems)
                    {
                        tlist.insertItemBefore(newRot, 0)
                    }
                    else
                    {
                        tlist.appendItem(newRot)
                    }
                }
                if (tlist.numberOfItems == 0)
                {
                    selected.removeAttribute('transform')
                }
                return null
            }
            if (operation == 2)
            {
                if (gangle)
                {
                    newcenter = {
                        x: oldcenter.x + first_m.e, y: oldcenter.y + first_m.f
                    };
                    var newRot = svgroot.createSVGTransform();
                    newRot.setRotate(gangle, newcenter.x, newcenter.y);
                    if (tlist.numberOfItems)
                    {
                        tlist.insertItemBefore(newRot, 0)
                    }
                    else
                    {
                        tlist.appendItem(newRot)
                    }
                }
            }
            else if (operation == 3)
            {
                var m = svgedit.math.transformListToTransform(tlist).matrix;
                var roldt = svgroot.createSVGTransform();
                roldt.setRotate(gangle, oldcenter.x, oldcenter.y);
                var rold = roldt.matrix;
                var rnew = svgroot.createSVGTransform();
                rnew.setRotate(gangle, newcenter.x, newcenter.y);
                var rnew_inv = rnew.matrix.inverse(),
                    m_inv = m.inverse(),
                    extrat = svgedit.math.matrixMultiply(m_inv, rnew_inv, rold, m);
                tx = extrat.e;
                ty = extrat.f;
                if (tx != 0 || ty != 0)
                {
                    var children = selected.childNodes;
                    var c = children.length;
                    while (c--)
                    {
                        var child = children.item(c);
                        if (child.nodeType == 1)
                        {
                            var oldStartTransform = context_.getStartTransform();
                            context_.setStartTransform(child.getAttribute('transform'));
                            var childTlist = svgedit.transformlist.getTransformList(child);
                            var newxlate = svgroot.createSVGTransform();
                            newxlate.setTranslate(tx, ty);
                            if (childTlist.numberOfItems)
                            {
                                childTlist.insertItemBefore(newxlate, 0)
                            }
                            else
                            {
                                childTlist.appendItem(newxlate)
                            }
                            batchCmd.addSubCommand(svgedit.recalculate.recalculateDimensions(child));
                            context_.setStartTransform(oldStartTransform)
                        }
                    }
                }
                if (gangle)
                {
                    if (tlist.numberOfItems)
                    {
                        tlist.insertItemBefore(rnew, 0)
                    }
                    else
                    {
                        tlist.appendItem(rnew)
                    }
                }
            }
        }
        else
        {
            var box = svgedit.utilities.getBBox(selected);
            if (!box && selected.tagName != 'path')
                return null;
            var m = svgroot.createSVGMatrix(),
                angle = svgedit.utilities.getRotationAngle(selected);
            if (angle)
            {
                var oldcenter = {
                        x: box.x + box.width / 2, y: box.y + box.height / 2
                    },
                    newcenter = svgedit.math.transformPoint(box.x + box.width / 2, box.y + box.height / 2, svgedit.math.transformListToTransform(tlist).matrix);
                var a = angle * Math.PI / 180;
                if (Math.abs(a) > (1.0e-10))
                {
                    var s = Math.sin(a) / (1 - Math.cos(a))
                }
                else
                {
                    var s = 2 / a
                }
                for (var i = 0; i < tlist.numberOfItems; ++i)
                {
                    var xform = tlist.getItem(i);
                    if (xform.type == 4)
                    {
                        var rm = xform.matrix;
                        oldcenter.y = (s * rm.e + rm.f) / 2;
                        oldcenter.x = (rm.e - s * rm.f) / 2;
                        tlist.removeItem(i);
                        break
                    }
                }
            }
            var operation = 0;
            var N = tlist.numberOfItems;
            if (!svgedit.browser.isWebkit())
            {
                var fill = selected.getAttribute('fill');
                if (fill && fill.indexOf('url(') === 0)
                {
                    var paint = getRefElem(fill);
                    var type = 'pattern';
                    if (paint.tagName !== type)
                        type = 'gradient';
                    var attrVal = paint.getAttribute(type + 'Units');
                    if (attrVal === 'userSpaceOnUse')
                    {
                        m = svgedit.math.transformListToTransform(tlist).matrix;
                        var gtlist = svgedit.transformlist.getTransformList(paint);
                        var gmatrix = svgedit.math.transformListToTransform(gtlist).matrix;
                        m = svgedit.math.matrixMultiply(m, gmatrix);
                        var m_str = 'matrix(' + [m.a, m.b, m.c, m.d, m.e, m.f].join(',') + ')';
                        paint.setAttribute(type + 'Transform', m_str)
                    }
                }
            }
            if (N >= 3 && tlist.getItem(N - 2).type == 3 && tlist.getItem(N - 3).type == 2 && tlist.getItem(N - 1).type == 2)
            {
                operation = 3;
                m = svgedit.math.transformListToTransform(tlist, N - 3, N - 1).matrix;
                tlist.removeItem(N - 1);
                tlist.removeItem(N - 2);
                tlist.removeItem(N - 3)
            }
            else if (N == 4 && tlist.getItem(N - 1).type == 1)
            {
                operation = 3;
                m = svgedit.math.transformListToTransform(tlist).matrix;
                var e2t = svgroot.createSVGTransform();
                e2t.setMatrix(m);
                tlist.clear();
                tlist.appendItem(e2t);
                m = svgroot.createSVGMatrix()
            }
            else if ((N == 1 || (N > 1 && tlist.getItem(1).type != 3)) && tlist.getItem(0).type == 2)
            {
                operation = 2;
                var oldxlate = tlist.getItem(0).matrix,
                    meq = svgedit.math.transformListToTransform(tlist, 1).matrix,
                    meq_inv = meq.inverse();
                m = svgedit.math.matrixMultiply(meq_inv, oldxlate, meq);
                tlist.removeItem(0)
            }
            else if (N == 1 && tlist.getItem(0).type == 1 && !angle)
            {
                m = svgedit.math.transformListToTransform(tlist).matrix;
                switch (selected.tagName)
                {
                    case'line':
                        changes = $(selected).attr(['x1', 'y1', 'x2', 'y2']);
                    case'polyline':
                    case'polygon':
                        changes.points = selected.getAttribute('points');
                        if (changes.points)
                        {
                            var list = selected.points;
                            var len = list.numberOfItems;
                            changes.points = new Array(len);
                            for (var i = 0; i < len; ++i)
                            {
                                var pt = list.getItem(i);
                                changes.points[i] = {
                                    x: pt.x, y: pt.y
                                }
                            }
                        }
                    case'path':
                        changes.d = selected.getAttribute('d');
                        operation = 1;
                        tlist.clear();
                        break;
                    default:
                        break
                }
            }
            else
            {
                operation = 4;
                if (angle)
                {
                    var newRot = svgroot.createSVGTransform();
                    newRot.setRotate(angle, newcenter.x, newcenter.y);
                    if (tlist.numberOfItems)
                    {
                        tlist.insertItemBefore(newRot, 0)
                    }
                    else
                    {
                        tlist.appendItem(newRot)
                    }
                }
                if (tlist.numberOfItems == 0)
                {
                    selected.removeAttribute('transform')
                }
                return null
            }
            if (operation == 1 || operation == 2 || operation == 3)
            {
                svgedit.coords.remapElement(selected, changes, m)
            }
            if (operation == 2)
            {
                if (angle)
                {
                    if (!svgedit.math.hasMatrixTransform(tlist))
                    {
                        newcenter = {
                            x: oldcenter.x + m.e, y: oldcenter.y + m.f
                        }
                    }
                    var newRot = svgroot.createSVGTransform();
                    newRot.setRotate(angle, newcenter.x, newcenter.y);
                    if (tlist.numberOfItems)
                    {
                        tlist.insertItemBefore(newRot, 0)
                    }
                    else
                    {
                        tlist.appendItem(newRot)
                    }
                }
                if (selected.tagName == 'text')
                {
                    var children = selected.childNodes;
                    var c = children.length;
                    while (c--)
                    {
                        var child = children.item(c);
                        if (child.tagName == 'tspan')
                        {
                            var tspanChanges = {
                                    x: $(child).attr('x') || 0, y: $(child).attr('y') || 0
                                };
                            svgedit.coords.remapElement(child, tspanChanges, m)
                        }
                    }
                }
            }
            else if (operation == 3 && angle)
            {
                var m = svgedit.math.transformListToTransform(tlist).matrix;
                var roldt = svgroot.createSVGTransform();
                roldt.setRotate(angle, oldcenter.x, oldcenter.y);
                var rold = roldt.matrix;
                var rnew = svgroot.createSVGTransform();
                rnew.setRotate(angle, newcenter.x, newcenter.y);
                var rnew_inv = rnew.matrix.inverse();
                var m_inv = m.inverse();
                var extrat = svgedit.math.matrixMultiply(m_inv, rnew_inv, rold, m);
                svgedit.coords.remapElement(selected, changes, extrat);
                if (angle)
                {
                    if (tlist.numberOfItems)
                    {
                        tlist.insertItemBefore(rnew, 0)
                    }
                    else
                    {
                        tlist.appendItem(rnew)
                    }
                }
            }
        }
        if (tlist.numberOfItems == 0)
        {
            selected.removeAttribute('transform')
        }
        batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(selected, initial));
        return batchCmd
    }
})();
(function()
{
    'use strict';
    if (!svgedit.select)
    {
        svgedit.select = {}
    }
    var svgFactory_;
    var config_;
    var selectorManager_;
    var gripRadius = svgedit.browser.isTouch() ? 10 : 4;
    svgedit.select.Selector = function(id, elem)
    {
        this.id = id;
        this.selectedElement = elem;
        this.locked = true;
        this.selectorGroup = svgFactory_.createSVGElement({
            element: 'g', attr: {id: ('selectorGroup' + this.id)}
        });
        this.selectorRect = this.selectorGroup.appendChild(svgFactory_.createSVGElement({
            element: 'path', attr: {
                    id: ('selectedBox' + this.id), fill: 'none', stroke: '#22C', 'stroke-width': '1', 'stroke-dasharray': '5,5', style: 'pointer-events:none'
                }
        }));
        this.gripCoords = {
            nw: null, n: null, ne: null, e: null, se: null, s: null, sw: null, w: null
        };
        this.reset(this.selectedElement)
    };
    svgedit.select.Selector.prototype.reset = function(e)
    {
        this.locked = true;
        this.selectedElement = e;
        this.resize();
        this.selectorGroup.setAttribute('display', 'inline')
    };
    svgedit.select.Selector.prototype.updateGripCursors = function(angle)
    {
        var dir,
            dir_arr = [],
            steps = Math.round(angle / 45);
        if (steps < 0)
        {
            steps += 8
        }
        for (dir in selectorManager_.selectorGrips)
        {
            dir_arr.push(dir)
        }
        while (steps > 0)
        {
            dir_arr.push(dir_arr.shift());
            steps--
        }
        var i = 0;
        for (dir in selectorManager_.selectorGrips)
        {
            selectorManager_.selectorGrips[dir].setAttribute('style', ('cursor:' + dir_arr[i] + '-resize'));
            i++
        }
    };
    svgedit.select.Selector.prototype.showGrips = function(show)
    {
        var bShow = show ? 'inline' : 'none';
        selectorManager_.selectorGripsGroup.setAttribute('display', bShow);
        var elem = this.selectedElement;
        this.hasGrips = show;
        if (elem && show)
        {
            this.selectorGroup.appendChild(selectorManager_.selectorGripsGroup);
            this.updateGripCursors(svgedit.utilities.getRotationAngle(elem))
        }
    };
    svgedit.select.Selector.prototype.resize = function()
    {
        var selectedBox = this.selectorRect,
            mgr = selectorManager_,
            selectedGrips = mgr.selectorGrips,
            selected = this.selectedElement,
            sw = selected.getAttribute('stroke-width'),
            current_zoom = svgFactory_.currentZoom();
        var offset = 1 / current_zoom;
        if (selected.getAttribute('stroke') !== 'none' && !isNaN(sw))
        {
            offset += (sw / 2)
        }
        var tagName = selected.tagName;
        if (tagName === 'text')
        {
            offset += 2 / current_zoom
        }
        var tlist = svgedit.transformlist.getTransformList(selected);
        var m = svgedit.math.transformListToTransform(tlist).matrix;
        m.e *= current_zoom;
        m.f *= current_zoom;
        var bbox = svgedit.utilities.getBBox(selected);
        if (tagName === 'g' && !$.data(selected, 'gsvg'))
        {
            var stroked_bbox = svgFactory_.getStrokedBBox(selected.childNodes);
            if (stroked_bbox)
            {
                bbox = stroked_bbox
            }
        }
        var l = bbox.x,
            t = bbox.y,
            w = bbox.width,
            h = bbox.height;
        bbox = {
            x: l, y: t, width: w, height: h
        };
        offset *= current_zoom;
        var nbox = svgedit.math.transformBox(l * current_zoom, t * current_zoom, w * current_zoom, h * current_zoom, m),
            aabox = nbox.aabox,
            nbax = aabox.x - offset,
            nbay = aabox.y - offset,
            nbaw = aabox.width + (offset * 2),
            nbah = aabox.height + (offset * 2);
        var cx = nbax + nbaw / 2,
            cy = nbay + nbah / 2;
        var angle = svgedit.utilities.getRotationAngle(selected);
        if (angle)
        {
            var rot = svgFactory_.svgRoot().createSVGTransform();
            rot.setRotate(-angle, cx, cy);
            var rotm = rot.matrix;
            nbox.tl = svgedit.math.transformPoint(nbox.tl.x, nbox.tl.y, rotm);
            nbox.tr = svgedit.math.transformPoint(nbox.tr.x, nbox.tr.y, rotm);
            nbox.bl = svgedit.math.transformPoint(nbox.bl.x, nbox.bl.y, rotm);
            nbox.br = svgedit.math.transformPoint(nbox.br.x, nbox.br.y, rotm);
            var tl = nbox.tl;
            var minx = tl.x,
                miny = tl.y,
                maxx = tl.x,
                maxy = tl.y;
            var min = Math.min,
                max = Math.max;
            minx = min(minx, min(nbox.tr.x, min(nbox.bl.x, nbox.br.x))) - offset;
            miny = min(miny, min(nbox.tr.y, min(nbox.bl.y, nbox.br.y))) - offset;
            maxx = max(maxx, max(nbox.tr.x, max(nbox.bl.x, nbox.br.x))) + offset;
            maxy = max(maxy, max(nbox.tr.y, max(nbox.bl.y, nbox.br.y))) + offset;
            nbax = minx;
            nbay = miny;
            nbaw = (maxx - minx);
            nbah = (maxy - miny)
        }
        var sr_handle = svgFactory_.svgRoot().suspendRedraw(100);
        var dstr = 'M' + nbax + ',' + nbay + ' L' + (nbax + nbaw) + ',' + nbay + ' ' + (nbax + nbaw) + ',' + (nbay + nbah) + ' ' + nbax + ',' + (nbay + nbah) + 'z';
        selectedBox.setAttribute('d', dstr);
        var xform = angle ? 'rotate(' + [angle, cx, cy].join(',') + ')' : '';
        this.selectorGroup.setAttribute('transform', xform);
        this.gripCoords = {
            nw: [nbax, nbay], ne: [nbax + nbaw, nbay], sw: [nbax, nbay + nbah], se: [nbax + nbaw, nbay + nbah], n: [nbax + (nbaw) / 2, nbay], w: [nbax, nbay + (nbah) / 2], e: [nbax + nbaw, nbay + (nbah) / 2], s: [nbax + (nbaw) / 2, nbay + nbah]
        };
        var dir;
        for (dir in this.gripCoords)
        {
            var coords = this.gripCoords[dir];
            selectedGrips[dir].setAttribute('cx', coords[0]);
            selectedGrips[dir].setAttribute('cy', coords[1])
        }
        mgr.rotateGripConnector.setAttribute('x1', nbax + (nbaw) / 2);
        mgr.rotateGripConnector.setAttribute('y1', nbay);
        mgr.rotateGripConnector.setAttribute('x2', nbax + (nbaw) / 2);
        mgr.rotateGripConnector.setAttribute('y2', nbay - (gripRadius * 5));
        mgr.rotateGrip.setAttribute('cx', nbax + (nbaw) / 2);
        mgr.rotateGrip.setAttribute('cy', nbay - (gripRadius * 5));
        svgFactory_.svgRoot().unsuspendRedraw(sr_handle)
    };
    svgedit.select.SelectorManager = function()
    {
        this.selectorParentGroup = null;
        this.rubberBandBox = null;
        this.selectors = [];
        this.selectorMap = {};
        this.selectorGrips = {
            nw: null, n: null, ne: null, e: null, se: null, s: null, sw: null, w: null
        };
        this.selectorGripsGroup = null;
        this.rotateGripConnector = null;
        this.rotateGrip = null;
        this.initGroup()
    };
    svgedit.select.SelectorManager.prototype.initGroup = function()
    {
        if (this.selectorParentGroup && this.selectorParentGroup.parentNode)
        {
            this.selectorParentGroup.parentNode.removeChild(this.selectorParentGroup)
        }
        this.selectorParentGroup = svgFactory_.createSVGElement({
            element: 'g', attr: {id: 'selectorParentGroup'}
        });
        this.selectorGripsGroup = svgFactory_.createSVGElement({
            element: 'g', attr: {display: 'none'}
        });
        this.selectorParentGroup.appendChild(this.selectorGripsGroup);
        svgFactory_.svgRoot().appendChild(this.selectorParentGroup);
        this.selectorMap = {};
        this.selectors = [];
        this.rubberBandBox = null;
        var dir;
        for (dir in this.selectorGrips)
        {
            var grip = svgFactory_.createSVGElement({
                    element: 'circle', attr: {
                            id: ('selectorGrip_resize_' + dir), fill: '#22C', r: gripRadius, style: ('cursor:' + dir + '-resize'), 'stroke-width': 2, 'pointer-events': 'all'
                        }
                });
            $.data(grip, 'dir', dir);
            $.data(grip, 'type', 'resize');
            this.selectorGrips[dir] = this.selectorGripsGroup.appendChild(grip)
        }
        this.rotateGripConnector = this.selectorGripsGroup.appendChild(svgFactory_.createSVGElement({
            element: 'line', attr: {
                    id: ('selectorGrip_rotateconnector'), stroke: '#22C', 'stroke-width': '1'
                }
        }));
        this.rotateGrip = this.selectorGripsGroup.appendChild(svgFactory_.createSVGElement({
            element: 'circle', attr: {
                    id: 'selectorGrip_rotate', fill: 'lime', r: gripRadius, stroke: '#22C', 'stroke-width': 2, style: 'cursor:url(' + config_.imgPath + 'rotate.png) 12 12, auto;'
                }
        }));
        $.data(this.rotateGrip, 'type', 'rotate');
        if ($('#canvasBackground').length)
        {
            return
        }
        var dims = config_.dimensions;
        var canvasbg = svgFactory_.createSVGElement({
                element: 'svg', attr: {
                        id: 'canvasBackground', width: dims[0], height: dims[1], x: 0, y: 0, overflow: (svgedit.browser.isWebkit() ? 'none' : 'visible'), style: 'pointer-events:none'
                    }
            });
        var rect = svgFactory_.createSVGElement({
                element: 'rect', attr: {
                        width: '100%', height: '100%', x: 0, y: 0, 'stroke-width': 1, stroke: '#000', fill: '#FFF', style: 'pointer-events:none'
                    }
            });
        canvasbg.appendChild(rect);
        svgFactory_.svgRoot().insertBefore(canvasbg, svgFactory_.svgContent())
    };
    svgedit.select.SelectorManager.prototype.requestSelector = function(elem)
    {
        if (elem == null)
        {
            return null
        }
        var i,
            N = this.selectors.length;
        if (typeof(this.selectorMap[elem.id]) == 'object')
        {
            this.selectorMap[elem.id].locked = true;
            return this.selectorMap[elem.id]
        }
        for (i = 0; i < N; ++i)
        {
            if (this.selectors[i] && !this.selectors[i].locked)
            {
                this.selectors[i].locked = true;
                this.selectors[i].reset(elem);
                this.selectorMap[elem.id] = this.selectors[i];
                return this.selectors[i]
            }
        }
        this.selectors[N] = new svgedit.select.Selector(N, elem);
        this.selectorParentGroup.appendChild(this.selectors[N].selectorGroup);
        this.selectorMap[elem.id] = this.selectors[N];
        return this.selectors[N]
    };
    svgedit.select.SelectorManager.prototype.releaseSelector = function(elem)
    {
        if (elem == null)
        {
            return
        }
        var i,
            N = this.selectors.length,
            sel = this.selectorMap[elem.id];
        for (i = 0; i < N; ++i)
        {
            if (this.selectors[i] && this.selectors[i] == sel)
            {
                if (sel.locked == false)
                {
                    console.log('WARNING! selector was released but was already unlocked')
                }
                delete this.selectorMap[elem.id];
                sel.locked = false;
                sel.selectedElement = null;
                sel.showGrips(false);
                try
                {
                    sel.selectorGroup.setAttribute('display', 'none')
                }
                catch(e) {}
                break
            }
        }
    };
    svgedit.select.SelectorManager.prototype.getRubberBandBox = function()
    {
        if (!this.rubberBandBox)
        {
            this.rubberBandBox = this.selectorParentGroup.appendChild(svgFactory_.createSVGElement({
                element: 'rect', attr: {
                        id: 'selectorRubberBand', fill: '#22C', 'fill-opacity': 0.15, stroke: '#22C', 'stroke-width': 0.5, display: 'none', style: 'pointer-events:none'
                    }
            }))
        }
        return this.rubberBandBox
    };
    svgedit.select.init = function(config, svgFactory)
    {
        config_ = config;
        svgFactory_ = svgFactory;
        selectorManager_ = new svgedit.select.SelectorManager
    };
    svgedit.select.getSelectorManager = function()
    {
        return selectorManager_
    }
}());
(function()
{
    'use strict';
    if (!svgedit.draw)
    {
        svgedit.draw = {}
    }
    var NS = svgedit.NS;
    var visElems = 'a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use'.split(',');
    var RandomizeModes = {
            LET_DOCUMENT_DECIDE: 0, ALWAYS_RANDOMIZE: 1, NEVER_RANDOMIZE: 2
        };
    var randomize_ids = RandomizeModes.LET_DOCUMENT_DECIDE;
    svgedit.draw.Layer = function(name, group)
    {
        this.name_ = name;
        this.group_ = group
    };
    svgedit.draw.Layer.prototype.getName = function()
    {
        return this.name_
    };
    svgedit.draw.Layer.prototype.getGroup = function()
    {
        return this.group_
    };
    svgedit.draw.randomizeIds = function(enableRandomization, currentDrawing)
    {
        randomize_ids = enableRandomization === false ? RandomizeModes.NEVER_RANDOMIZE : RandomizeModes.ALWAYS_RANDOMIZE;
        if (randomize_ids == RandomizeModes.ALWAYS_RANDOMIZE && !currentDrawing.getNonce())
        {
            currentDrawing.setNonce(Math.floor(Math.random() * 100001))
        }
        else if (randomize_ids == RandomizeModes.NEVER_RANDOMIZE && currentDrawing.getNonce())
        {
            currentDrawing.clearNonce()
        }
    };
    svgedit.draw.Drawing = function(svgElem, opt_idPrefix)
    {
        if (!svgElem || !svgElem.tagName || !svgElem.namespaceURI || svgElem.tagName != 'svg' || svgElem.namespaceURI != NS.SVG)
        {
            throw"Error: svgedit.draw.Drawing instance initialized without a <svg> element";
        }
        this.svgElem_ = svgElem;
        this.obj_num = 0;
        this.idPrefix = opt_idPrefix || "svg_";
        this.releasedNums = [];
        this.all_layers = [];
        this.current_layer = null;
        this.nonce_ = '';
        var n = this.svgElem_.getAttributeNS(NS.SE, 'nonce');
        if (!!n && randomize_ids != RandomizeModes.NEVER_RANDOMIZE)
        {
            this.nonce_ = n
        }
        else if (randomize_ids == RandomizeModes.ALWAYS_RANDOMIZE)
        {
            this.setNonce(Math.floor(Math.random() * 100001))
        }
    };
    svgedit.draw.Drawing.prototype.getElem_ = function(id)
    {
        if (this.svgElem_.querySelector)
        {
            return this.svgElem_.querySelector('#' + id)
        }
        return $(this.svgElem_).find('[id=' + id + ']')[0]
    };
    svgedit.draw.Drawing.prototype.getSvgElem = function()
    {
        return this.svgElem_
    };
    svgedit.draw.Drawing.prototype.getNonce = function()
    {
        return this.nonce_
    };
    svgedit.draw.Drawing.prototype.setNonce = function(n)
    {
        this.svgElem_.setAttributeNS(NS.XMLNS, 'xmlns:se', NS.SE);
        this.svgElem_.setAttributeNS(NS.SE, 'se:nonce', n);
        this.nonce_ = n
    };
    svgedit.draw.Drawing.prototype.clearNonce = function()
    {
        this.nonce_ = ''
    };
    svgedit.draw.Drawing.prototype.getId = function()
    {
        return this.nonce_ ? this.idPrefix + this.nonce_ + '_' + this.obj_num : this.idPrefix + this.obj_num
    };
    svgedit.draw.Drawing.prototype.getNextId = function()
    {
        var oldObjNum = this.obj_num;
        var restoreOldObjNum = false;
        if (this.releasedNums.length > 0)
        {
            this.obj_num = this.releasedNums.pop();
            restoreOldObjNum = true
        }
        else
        {
            this.obj_num++
        }
        var id = this.getId();
        while (this.getElem_(id))
        {
            if (restoreOldObjNum)
            {
                this.obj_num = oldObjNum;
                restoreOldObjNum = false
            }
            this.obj_num++;
            id = this.getId()
        }
        if (restoreOldObjNum)
        {
            this.obj_num = oldObjNum
        }
        return id
    };
    svgedit.draw.Drawing.prototype.releaseId = function(id)
    {
        var front = this.idPrefix + (this.nonce_ ? this.nonce_ + '_' : '');
        if (typeof id !== 'string' || id.indexOf(front) !== 0)
        {
            return false
        }
        var num = parseInt(id.substr(front.length), 10);
        if (typeof num !== 'number' || num <= 0 || this.releasedNums.indexOf(num) != -1)
        {
            return false
        }
        this.releasedNums.push(num);
        return true
    };
    svgedit.draw.Drawing.prototype.getNumLayers = function()
    {
        return this.all_layers.length
    };
    svgedit.draw.Drawing.prototype.hasLayer = function(name)
    {
        var i;
        for (i = 0; i < this.getNumLayers(); i++)
        {
            if (this.all_layers[i][0] == name)
            {
                return true
            }
        }
        return false
    };
    svgedit.draw.Drawing.prototype.getLayerName = function(i)
    {
        if (i >= 0 && i < this.getNumLayers())
        {
            return this.all_layers[i][0]
        }
        return ''
    };
    svgedit.draw.Drawing.prototype.getCurrentLayer = function()
    {
        return this.current_layer
    };
    svgedit.draw.Drawing.prototype.getCurrentLayerName = function()
    {
        var i;
        for (i = 0; i < this.getNumLayers(); ++i)
        {
            if (this.all_layers[i][1] == this.current_layer)
            {
                return this.getLayerName(i)
            }
        }
        return ''
    };
    svgedit.draw.Drawing.prototype.setCurrentLayer = function(name)
    {
        var i;
        for (i = 0; i < this.getNumLayers(); ++i)
        {
            if (name == this.getLayerName(i))
            {
                if (this.current_layer != this.all_layers[i][1])
                {
                    this.current_layer.setAttribute("style", "pointer-events:none");
                    this.current_layer = this.all_layers[i][1];
                    this.current_layer.setAttribute("style", "pointer-events:all")
                }
                return true
            }
        }
        return false
    };
    svgedit.draw.Drawing.prototype.deleteCurrentLayer = function()
    {
        if (this.current_layer && this.getNumLayers() > 1)
        {
            var parent = this.current_layer.parentNode;
            var nextSibling = this.current_layer.nextSibling;
            var oldLayerGroup = parent.removeChild(this.current_layer);
            this.identifyLayers();
            return oldLayerGroup
        }
        return null
    };
    svgedit.draw.Drawing.prototype.identifyLayers = function()
    {
        this.all_layers = [];
        var numchildren = this.svgElem_.childNodes.length;
        var orphans = [],
            layernames = [];
        var a_layer = null;
        var childgroups = false;
        var i;
        for (i = 0; i < numchildren; ++i)
        {
            var child = this.svgElem_.childNodes.item(i);
            if (child && child.nodeType == 1)
            {
                if (child.tagName == "g")
                {
                    childgroups = true;
                    var name = $("title", child).text();
                    if (!name && svgedit.browser.isOpera() && child.querySelectorAll)
                    {
                        name = $(child.querySelectorAll('title')).text()
                    }
                    if (name)
                    {
                        layernames.push(name);
                        this.all_layers.push([name, child]);
                        a_layer = child;
                        svgedit.utilities.walkTree(child, function(e)
                        {
                            e.setAttribute("style", "pointer-events:inherit")
                        });
                        a_layer.setAttribute("style", "pointer-events:none")
                    }
                    else
                    {
                        orphans.push(child)
                    }
                }
                else if (~visElems.indexOf(child.nodeName))
                {
                    var bb = svgedit.utilities.getBBox(child);
                    orphans.push(child)
                }
            }
        }
        var svgdoc = this.svgElem_.ownerDocument;
        if (orphans.length > 0 || !childgroups)
        {
            i = 1;
            while (layernames.indexOf(("Layer " + i)) >= 0)
            {
                i++
            }
            var newname = "Layer " + i;
            a_layer = svgdoc.createElementNS(NS.SVG, "g");
            var layer_title = svgdoc.createElementNS(NS.SVG, "title");
            layer_title.textContent = newname;
            a_layer.appendChild(layer_title);
            var j;
            for (j = 0; j < orphans.length; ++j)
            {
                a_layer.appendChild(orphans[j])
            }
            this.svgElem_.appendChild(a_layer);
            this.all_layers.push([newname, a_layer])
        }
        svgedit.utilities.walkTree(a_layer, function(e)
        {
            e.setAttribute("style", "pointer-events:inherit")
        });
        this.current_layer = a_layer;
        this.current_layer.setAttribute("style", "pointer-events:all")
    };
    svgedit.draw.Drawing.prototype.createLayer = function(name)
    {
        var svgdoc = this.svgElem_.ownerDocument;
        var new_layer = svgdoc.createElementNS(NS.SVG, "g");
        var layer_title = svgdoc.createElementNS(NS.SVG, "title");
        layer_title.textContent = name;
        new_layer.appendChild(layer_title);
        this.svgElem_.appendChild(new_layer);
        this.identifyLayers();
        return new_layer
    };
    svgedit.draw.Drawing.prototype.getLayerVisibility = function(layername)
    {
        var layer = null;
        var i;
        for (i = 0; i < this.getNumLayers(); ++i)
        {
            if (this.getLayerName(i) == layername)
            {
                layer = this.all_layers[i][1];
                break
            }
        }
        if (!layer)
        {
            return false
        }
        return (layer.getAttribute('display') !== 'none')
    };
    svgedit.draw.Drawing.prototype.setLayerVisibility = function(layername, bVisible)
    {
        if (typeof bVisible !== 'boolean')
        {
            return null
        }
        var layer = null;
        var i;
        for (i = 0; i < this.getNumLayers(); ++i)
        {
            if (this.getLayerName(i) == layername)
            {
                layer = this.all_layers[i][1];
                break
            }
        }
        if (!layer)
        {
            return null
        }
        var oldDisplay = layer.getAttribute("display");
        if (!oldDisplay)
        {
            oldDisplay = "inline"
        }
        layer.setAttribute("display", bVisible ? "inline" : "none");
        return layer
    };
    svgedit.draw.Drawing.prototype.getLayerOpacity = function(layername)
    {
        var i;
        for (i = 0; i < this.getNumLayers(); ++i)
        {
            if (this.getLayerName(i) == layername)
            {
                var g = this.all_layers[i][1];
                var opacity = g.getAttribute('opacity');
                if (!opacity)
                {
                    opacity = '1.0'
                }
                return parseFloat(opacity)
            }
        }
        return null
    };
    svgedit.draw.Drawing.prototype.setLayerOpacity = function(layername, opacity)
    {
        if (typeof opacity !== 'number' || opacity < 0.0 || opacity > 1.0)
        {
            return
        }
        var i;
        for (i = 0; i < this.getNumLayers(); ++i)
        {
            if (this.getLayerName(i) == layername)
            {
                var g = this.all_layers[i][1];
                g.setAttribute("opacity", opacity);
                break
            }
        }
    }
}());
(function()
{
    'use strict';
    if (!svgedit.path)
    {
        svgedit.path = {}
    }
    var NS = svgedit.NS;
    var uiStrings = {
            pathNodeTooltip: 'Drag node to move it. Double-click node to change segment type', pathCtrlPtTooltip: 'Drag control point to adjust curve properties'
        };
    var segData = {
            2: ['x', 'y'], 4: ['x', 'y'], 6: ['x', 'y', 'x1', 'y1', 'x2', 'y2'], 8: ['x', 'y', 'x1', 'y1'], 10: ['x', 'y', 'r1', 'r2', 'angle', 'largeArcFlag', 'sweepFlag'], 12: ['x'], 14: ['y'], 16: ['x', 'y', 'x2', 'y2'], 18: ['x', 'y']
        };
    var pathFuncs = [];
    var link_control_pts = true;
    var pathData = {};
    svgedit.path.setLinkControlPoints = function(lcp)
    {
        link_control_pts = lcp
    };
    svgedit.path.path = null;
    var editorContext_ = null;
    svgedit.path.init = function(editorContext)
    {
        editorContext_ = editorContext;
        pathFuncs = [0, 'ClosePath'];
        var pathFuncsStrs = ['Moveto', 'Lineto', 'CurvetoCubic', 'CurvetoQuadratic', 'Arc', 'LinetoHorizontal', 'LinetoVertical', 'CurvetoCubicSmooth', 'CurvetoQuadraticSmooth'];
        $.each(pathFuncsStrs, function(i, s)
        {
            pathFuncs.push(s + 'Abs');
            pathFuncs.push(s + 'Rel')
        })
    };
    svgedit.path.insertItemBefore = function(elem, newseg, index)
    {
        var list = elem.pathSegList;
        if (svgedit.browser.supportsPathInsertItemBefore())
        {
            list.insertItemBefore(newseg, index);
            return
        }
        var len = list.numberOfItems;
        var arr = [];
        var i;
        for (i = 0; i < len; i++)
        {
            var cur_seg = list.getItem(i);
            arr.push(cur_seg)
        }
        list.clear();
        for (i = 0; i < len; i++)
        {
            if (i == index)
            {
                list.appendItem(newseg)
            }
            list.appendItem(arr[i])
        }
    };
    svgedit.path.ptObjToArr = function(type, seg_item)
    {
        var arr = segData[type],
            len = arr.length;
        var i,
            out = [];
        for (i = 0; i < len; i++)
        {
            out[i] = seg_item[arr[i]]
        }
        return out
    };
    svgedit.path.getGripPt = function(seg, alt_pt)
    {
        var out = {
                x: alt_pt ? alt_pt.x : seg.item.x, y: alt_pt ? alt_pt.y : seg.item.y
            },
            path = seg.path;
        if (path.matrix)
        {
            var pt = svgedit.math.transformPoint(out.x, out.y, path.matrix);
            out = pt
        }
        out.x *= editorContext_.getCurrentZoom();
        out.y *= editorContext_.getCurrentZoom();
        return out
    };
    svgedit.path.getPointFromGrip = function(pt, path)
    {
        var out = {
                x: pt.x, y: pt.y
            };
        if (path.matrix)
        {
            pt = svgedit.math.transformPoint(out.x, out.y, path.imatrix);
            out.x = pt.x;
            out.y = pt.y
        }
        out.x /= editorContext_.getCurrentZoom();
        out.y /= editorContext_.getCurrentZoom();
        return out
    };
    svgedit.path.addPointGrip = function(index, x, y)
    {
        var pointGripContainer = svgedit.path.getGripContainer();
        var pointGrip = svgedit.utilities.getElem('pathpointgrip_' + index);
        if (!pointGrip)
        {
            pointGrip = document.createElementNS(NS.SVG, 'circle');
            svgedit.utilities.assignAttributes(pointGrip, {
                id: 'pathpointgrip_' + index, display: 'none', r: 4, fill: '#0FF', stroke: '#00F', 'stroke-width': 2, cursor: 'move', style: 'pointer-events:all', 'xlink:title': uiStrings.pathNodeTooltip
            });
            pointGrip = pointGripContainer.appendChild(pointGrip);
            var grip = $('#pathpointgrip_' + index);
            grip.dblclick(function()
            {
                if (svgedit.path.path)
                {
                    svgedit.path.path.setSegType()
                }
            })
        }
        if (x && y)
        {
            svgedit.utilities.assignAttributes(pointGrip, {
                cx: x, cy: y, display: 'inline'
            })
        }
        return pointGrip
    };
    svgedit.path.getGripContainer = function()
    {
        var c = svgedit.utilities.getElem('pathpointgrip_container');
        if (!c)
        {
            var parent = svgedit.utilities.getElem('selectorParentGroup');
            c = parent.appendChild(document.createElementNS(NS.SVG, 'g'));
            c.id = 'pathpointgrip_container'
        }
        return c
    };
    svgedit.path.addCtrlGrip = function(id)
    {
        var pointGrip = svgedit.utilities.getElem('ctrlpointgrip_' + id);
        if (pointGrip)
        {
            return pointGrip
        }
        pointGrip = document.createElementNS(NS.SVG, 'circle');
        svgedit.utilities.assignAttributes(pointGrip, {
            id: 'ctrlpointgrip_' + id, display: 'none', r: 4, fill: '#0FF', stroke: '#55F', 'stroke-width': 1, cursor: 'move', style: 'pointer-events:all', 'xlink:title': uiStrings.pathCtrlPtTooltip
        });
        svgedit.path.getGripContainer().appendChild(pointGrip);
        return pointGrip
    };
    svgedit.path.getCtrlLine = function(id)
    {
        var ctrlLine = svgedit.utilities.getElem('ctrlLine_' + id);
        if (ctrlLine)
        {
            return ctrlLine
        }
        ctrlLine = document.createElementNS(NS.SVG, 'line');
        svgedit.utilities.assignAttributes(ctrlLine, {
            id: 'ctrlLine_' + id, stroke: '#555', 'stroke-width': 1, style: 'pointer-events:none'
        });
        svgedit.path.getGripContainer().appendChild(ctrlLine);
        return ctrlLine
    };
    svgedit.path.getPointGrip = function(seg, update)
    {
        var index = seg.index;
        var pointGrip = svgedit.path.addPointGrip(index);
        if (update)
        {
            var pt = svgedit.path.getGripPt(seg);
            svgedit.utilities.assignAttributes(pointGrip, {
                cx: pt.x, cy: pt.y, display: 'inline'
            })
        }
        return pointGrip
    };
    svgedit.path.getControlPoints = function(seg)
    {
        var item = seg.item;
        var index = seg.index;
        if (!('x1' in item) || !('x2' in item))
        {
            return null
        }
        var cpt = {};
        var pointGripContainer = svgedit.path.getGripContainer();
        var prev = svgedit.path.path.segs[index - 1].item;
        var seg_items = [prev, item];
        var i;
        for (i = 1; i < 3; i++)
        {
            var id = index + 'c' + i;
            var ctrlLine = cpt['c' + i + '_line'] = svgedit.path.getCtrlLine(id);
            var pt = svgedit.path.getGripPt(seg, {
                    x: item['x' + i], y: item['y' + i]
                });
            var gpt = svgedit.path.getGripPt(seg, {
                    x: seg_items[i - 1].x, y: seg_items[i - 1].y
                });
            svgedit.utilities.assignAttributes(ctrlLine, {
                x1: pt.x, y1: pt.y, x2: gpt.x, y2: gpt.y, display: 'inline'
            });
            cpt['c' + i + '_line'] = ctrlLine;
            var pointGrip = cpt['c' + i] = svgedit.path.addCtrlGrip(id);
            svgedit.utilities.assignAttributes(pointGrip, {
                cx: pt.x, cy: pt.y, display: 'inline'
            });
            cpt['c' + i] = pointGrip
        }
        return cpt
    };
    svgedit.path.replacePathSeg = function(type, index, pts, elem)
    {
        var path = elem || svgedit.path.path.elem;
        var func = 'createSVGPathSeg' + pathFuncs[type];
        var seg = path[func].apply(path, pts);
        if (svgedit.browser.supportsPathReplaceItem())
        {
            path.pathSegList.replaceItem(seg, index)
        }
        else
        {
            var segList = path.pathSegList;
            var len = segList.numberOfItems;
            var arr = [];
            var i;
            for (i = 0; i < len; i++)
            {
                var cur_seg = segList.getItem(i);
                arr.push(cur_seg)
            }
            segList.clear();
            for (i = 0; i < len; i++)
            {
                if (i == index)
                {
                    segList.appendItem(seg)
                }
                else
                {
                    segList.appendItem(arr[i])
                }
            }
        }
    };
    svgedit.path.getSegSelector = function(seg, update)
    {
        var index = seg.index;
        var segLine = svgedit.utilities.getElem('segline_' + index);
        if (!segLine)
        {
            var pointGripContainer = svgedit.path.getGripContainer();
            segLine = document.createElementNS(NS.SVG, 'path');
            svgedit.utilities.assignAttributes(segLine, {
                id: 'segline_' + index, display: 'none', fill: 'none', stroke: '#0FF', 'stroke-width': 2, style: 'pointer-events:none', d: 'M0,0 0,0'
            });
            pointGripContainer.appendChild(segLine)
        }
        if (update)
        {
            var prev = seg.prev;
            if (!prev)
            {
                segLine.setAttribute('display', 'none');
                return segLine
            }
            var pt = svgedit.path.getGripPt(prev);
            svgedit.path.replacePathSeg(2, 0, [pt.x, pt.y], segLine);
            var pts = svgedit.path.ptObjToArr(seg.type, seg.item, true);
            var i;
            for (i = 0; i < pts.length; i += 2)
            {
                pt = svgedit.path.getGripPt(seg, {
                    x: pts[i], y: pts[i + 1]
                });
                pts[i] = pt.x;
                pts[i + 1] = pt.y
            }
            svgedit.path.replacePathSeg(seg.type, 1, pts, segLine)
        }
        return segLine
    };
    svgedit.path.smoothControlPoints = function(ct1, ct2, pt)
    {
        var x1 = ct1.x - pt.x,
            y1 = ct1.y - pt.y,
            x2 = ct2.x - pt.x,
            y2 = ct2.y - pt.y;
        if ((x1 != 0 || y1 != 0) && (x2 != 0 || y2 != 0))
        {
            var anglea = Math.atan2(y1, x1),
                angleb = Math.atan2(y2, x2),
                r1 = Math.sqrt(x1 * x1 + y1 * y1),
                r2 = Math.sqrt(x2 * x2 + y2 * y2),
                nct1 = editorContext_.getSVGRoot().createSVGPoint(),
                nct2 = editorContext_.getSVGRoot().createSVGPoint();
            if (anglea < 0)
            {
                anglea += 2 * Math.PI
            }
            if (angleb < 0)
            {
                angleb += 2 * Math.PI
            }
            var angleBetween = Math.abs(anglea - angleb),
                angleDiff = Math.abs(Math.PI - angleBetween) / 2;
            var new_anglea,
                new_angleb;
            if (anglea - angleb > 0)
            {
                new_anglea = angleBetween < Math.PI ? (anglea + angleDiff) : (anglea - angleDiff);
                new_angleb = angleBetween < Math.PI ? (angleb - angleDiff) : (angleb + angleDiff)
            }
            else
            {
                new_anglea = angleBetween < Math.PI ? (anglea - angleDiff) : (anglea + angleDiff);
                new_angleb = angleBetween < Math.PI ? (angleb + angleDiff) : (angleb - angleDiff)
            }
            nct1.x = r1 * Math.cos(new_anglea) + pt.x;
            nct1.y = r1 * Math.sin(new_anglea) + pt.y;
            nct2.x = r2 * Math.cos(new_angleb) + pt.x;
            nct2.y = r2 * Math.sin(new_angleb) + pt.y;
            return [nct1, nct2]
        }
        return undefined
    };
    svgedit.path.Segment = function(index, item)
    {
        this.selected = false;
        this.index = index;
        this.item = item;
        this.type = item.pathSegType;
        this.ctrlpts = [];
        this.ptgrip = null;
        this.segsel = null
    };
    svgedit.path.Segment.prototype.showCtrlPts = function(y)
    {
        var i;
        for (i in this.ctrlpts)
        {
            if (this.ctrlpts.hasOwnProperty(i))
            {
                this.ctrlpts[i].setAttribute('display', y ? 'inline' : 'none')
            }
        }
    };
    svgedit.path.Segment.prototype.selectCtrls = function(y)
    {
        $('#ctrlpointgrip_' + this.index + 'c1, #ctrlpointgrip_' + this.index + 'c2').attr('fill', y ? '#0FF' : '#EEE')
    };
    svgedit.path.Segment.prototype.show = function(y)
    {
        if (this.ptgrip)
        {
            this.ptgrip.setAttribute('display', y ? 'inline' : 'none');
            this.segsel.setAttribute('display', y ? 'inline' : 'none');
            this.showCtrlPts(y)
        }
    };
    svgedit.path.Segment.prototype.select = function(y)
    {
        if (this.ptgrip)
        {
            this.ptgrip.setAttribute('stroke', y ? '#0FF' : '#00F');
            this.segsel.setAttribute('display', y ? 'inline' : 'none');
            if (this.ctrlpts)
            {
                this.selectCtrls(y)
            }
            this.selected = y
        }
    };
    svgedit.path.Segment.prototype.addGrip = function()
    {
        this.ptgrip = svgedit.path.getPointGrip(this, true);
        this.ctrlpts = svgedit.path.getControlPoints(this, true);
        this.segsel = svgedit.path.getSegSelector(this, true)
    };
    svgedit.path.Segment.prototype.update = function(full)
    {
        if (this.ptgrip)
        {
            var pt = svgedit.path.getGripPt(this);
            svgedit.utilities.assignAttributes(this.ptgrip, {
                cx: pt.x, cy: pt.y
            });
            svgedit.path.getSegSelector(this, true);
            if (this.ctrlpts)
            {
                if (full)
                {
                    this.item = svgedit.path.path.elem.pathSegList.getItem(this.index);
                    this.type = this.item.pathSegType
                }
                svgedit.path.getControlPoints(this)
            }
        }
    };
    svgedit.path.Segment.prototype.move = function(dx, dy)
    {
        var cur_pts,
            item = this.item;
        if (this.ctrlpts)
        {
            cur_pts = [item.x += dx, item.y += dy, item.x1, item.y1, item.x2 += dx, item.y2 += dy]
        }
        else
        {
            cur_pts = [item.x += dx, item.y += dy]
        }
        svgedit.path.replacePathSeg(this.type, this.index, cur_pts);
        if (this.next && this.next.ctrlpts)
        {
            var next = this.next.item;
            var next_pts = [next.x, next.y, next.x1 += dx, next.y1 += dy, next.x2, next.y2];
            svgedit.path.replacePathSeg(this.next.type, this.next.index, next_pts)
        }
        if (this.mate)
        {
            item = this.mate.item;
            var pts = [item.x += dx, item.y += dy];
            svgedit.path.replacePathSeg(this.mate.type, this.mate.index, pts)
        }
        this.update(true);
        if (this.next)
        {
            this.next.update(true)
        }
    };
    svgedit.path.Segment.prototype.setLinked = function(num)
    {
        var seg,
            anum,
            pt;
        if (num == 2)
        {
            anum = 1;
            seg = this.next;
            if (!seg)
            {
                return
            }
            pt = this.item
        }
        else
        {
            anum = 2;
            seg = this.prev;
            if (!seg)
            {
                return
            }
            pt = seg.item
        }
        var item = seg.item;
        item['x' + anum] = pt.x + (pt.x - this.item['x' + num]);
        item['y' + anum] = pt.y + (pt.y - this.item['y' + num]);
        var pts = [item.x, item.y, item.x1, item.y1, item.x2, item.y2];
        svgedit.path.replacePathSeg(seg.type, seg.index, pts);
        seg.update(true)
    };
    svgedit.path.Segment.prototype.moveCtrl = function(num, dx, dy)
    {
        var item = this.item;
        item['x' + num] += dx;
        item['y' + num] += dy;
        var pts = [item.x, item.y, item.x1, item.y1, item.x2, item.y2];
        svgedit.path.replacePathSeg(this.type, this.index, pts);
        this.update(true)
    };
    svgedit.path.Segment.prototype.setType = function(new_type, pts)
    {
        svgedit.path.replacePathSeg(new_type, this.index, pts);
        this.type = new_type;
        this.item = svgedit.path.path.elem.pathSegList.getItem(this.index);
        this.showCtrlPts(new_type === 6);
        this.ctrlpts = svgedit.path.getControlPoints(this);
        this.update(true)
    };
    svgedit.path.Path = function(elem)
    {
        if (!elem || elem.tagName !== 'path')
        {
            throw'svgedit.path.Path constructed without a <path> element';
        }
        this.elem = elem;
        this.segs = [];
        this.selected_pts = [];
        svgedit.path.path = this;
        this.init()
    };
    svgedit.path.Path.prototype.init = function()
    {
        $(svgedit.path.getGripContainer()).find('*').attr('display', 'none');
        var segList = this.elem.pathSegList;
        var len = segList.numberOfItems;
        this.segs = [];
        this.selected_pts = [];
        this.first_seg = null;
        var i;
        for (i = 0; i < len; i++)
        {
            var item = segList.getItem(i);
            var segment = new svgedit.path.Segment(i, item);
            segment.path = this;
            this.segs.push(segment)
        }
        var segs = this.segs;
        var start_i = null;
        for (i = 0; i < len; i++)
        {
            var seg = segs[i];
            var next_seg = (i + 1) >= len ? null : segs[i + 1];
            var prev_seg = (i - 1) < 0 ? null : segs[i - 1];
            var start_seg;
            if (seg.type === 2)
            {
                if (prev_seg && prev_seg.type !== 1)
                {
                    start_seg = segs[start_i];
                    start_seg.next = segs[start_i + 1];
                    start_seg.next.prev = start_seg;
                    start_seg.addGrip()
                }
                start_i = i
            }
            else if (next_seg && next_seg.type === 1)
            {
                seg.next = segs[start_i + 1];
                seg.next.prev = seg;
                seg.mate = segs[start_i];
                seg.addGrip();
                if (this.first_seg == null)
                {
                    this.first_seg = seg
                }
            }
            else if (!next_seg)
            {
                if (seg.type !== 1)
                {
                    start_seg = segs[start_i];
                    start_seg.next = segs[start_i + 1];
                    start_seg.next.prev = start_seg;
                    start_seg.addGrip();
                    seg.addGrip();
                    if (!this.first_seg)
                    {
                        this.first_seg = segs[start_i]
                    }
                }
            }
            else if (seg.type !== 1)
            {
                seg.addGrip();
                if (next_seg && next_seg.type !== 2)
                {
                    seg.next = next_seg;
                    seg.next.prev = seg
                }
            }
        }
        return this
    };
    svgedit.path.Path.prototype.eachSeg = function(fn)
    {
        var i;
        var len = this.segs.length;
        for (i = 0; i < len; i++)
        {
            var ret = fn.call(this.segs[i], i);
            if (ret === false)
            {
                break
            }
        }
    };
    svgedit.path.Path.prototype.addSeg = function(index)
    {
        var seg = this.segs[index];
        if (!seg.prev)
        {
            return
        }
        var prev = seg.prev;
        var newseg,
            new_x,
            new_y;
        switch (seg.item.pathSegType)
        {
            case 4:
                new_x = (seg.item.x + prev.item.x) / 2;
                new_y = (seg.item.y + prev.item.y) / 2;
                newseg = this.elem.createSVGPathSegLinetoAbs(new_x, new_y);
                break;
            case 6:
                var p0_x = (prev.item.x + seg.item.x1) / 2;
                var p1_x = (seg.item.x1 + seg.item.x2) / 2;
                var p2_x = (seg.item.x2 + seg.item.x) / 2;
                var p01_x = (p0_x + p1_x) / 2;
                var p12_x = (p1_x + p2_x) / 2;
                new_x = (p01_x + p12_x) / 2;
                var p0_y = (prev.item.y + seg.item.y1) / 2;
                var p1_y = (seg.item.y1 + seg.item.y2) / 2;
                var p2_y = (seg.item.y2 + seg.item.y) / 2;
                var p01_y = (p0_y + p1_y) / 2;
                var p12_y = (p1_y + p2_y) / 2;
                new_y = (p01_y + p12_y) / 2;
                newseg = this.elem.createSVGPathSegCurvetoCubicAbs(new_x, new_y, p0_x, p0_y, p01_x, p01_y);
                var pts = [seg.item.x, seg.item.y, p12_x, p12_y, p2_x, p2_y];
                svgedit.path.replacePathSeg(seg.type, index, pts);
                break
        }
        svgedit.path.insertItemBefore(this.elem, newseg, index)
    };
    svgedit.path.Path.prototype.deleteSeg = function(index)
    {
        var seg = this.segs[index];
        var list = this.elem.pathSegList;
        seg.show(false);
        var next = seg.next;
        var pt;
        if (seg.mate)
        {
            pt = [next.item.x, next.item.y];
            svgedit.path.replacePathSeg(2, next.index, pt);
            svgedit.path.replacePathSeg(4, seg.index, pt);
            list.removeItem(seg.mate.index)
        }
        else if (!seg.prev)
        {
            var item = seg.item;
            pt = [next.item.x, next.item.y];
            svgedit.path.replacePathSeg(2, seg.next.index, pt);
            list.removeItem(index)
        }
        else
        {
            list.removeItem(index)
        }
    };
    svgedit.path.Path.prototype.subpathIsClosed = function(index)
    {
        var closed = false;
        svgedit.path.path.eachSeg(function(i)
        {
            if (i <= index)
            {
                return true
            }
            if (this.type === 2)
            {
                return false
            }
            if (this.type === 1)
            {
                closed = true;
                return false
            }
        });
        return closed
    };
    svgedit.path.Path.prototype.removePtFromSelection = function(index)
    {
        var pos = this.selected_pts.indexOf(index);
        if (pos == -1)
        {
            return
        }
        this.segs[index].select(false);
        this.selected_pts.splice(pos, 1)
    };
    svgedit.path.Path.prototype.clearSelection = function()
    {
        this.eachSeg(function()
        {
            this.select(false)
        });
        this.selected_pts = []
    };
    svgedit.path.Path.prototype.storeD = function()
    {
        this.last_d = this.elem.getAttribute('d')
    };
    svgedit.path.Path.prototype.show = function(y)
    {
        this.eachSeg(function()
        {
            this.show(y)
        });
        if (y)
        {
            this.selectPt(this.first_seg.index)
        }
        return this
    };
    svgedit.path.Path.prototype.movePts = function(d_x, d_y)
    {
        var i = this.selected_pts.length;
        while (i--)
        {
            var seg = this.segs[this.selected_pts[i]];
            seg.move(d_x, d_y)
        }
    };
    svgedit.path.Path.prototype.moveCtrl = function(d_x, d_y)
    {
        var seg = this.segs[this.selected_pts[0]];
        seg.moveCtrl(this.dragctrl, d_x, d_y);
        if (link_control_pts)
        {
            seg.setLinked(this.dragctrl)
        }
    };
    svgedit.path.Path.prototype.setSegType = function(new_type)
    {
        this.storeD();
        var i = this.selected_pts.length;
        var text;
        while (i--)
        {
            var sel_pt = this.selected_pts[i];
            var cur = this.segs[sel_pt];
            var prev = cur.prev;
            if (!prev)
            {
                continue
            }
            if (!new_type)
            {
                text = 'Toggle Path Segment Type';
                var old_type = cur.type;
                new_type = (old_type == 6) ? 4 : 6
            }
            new_type = Number(new_type);
            var cur_x = cur.item.x;
            var cur_y = cur.item.y;
            var prev_x = prev.item.x;
            var prev_y = prev.item.y;
            var points;
            switch (new_type)
            {
                case 6:
                    if (cur.olditem)
                    {
                        var old = cur.olditem;
                        points = [cur_x, cur_y, old.x1, old.y1, old.x2, old.y2]
                    }
                    else
                    {
                        var diff_x = cur_x - prev_x;
                        var diff_y = cur_y - prev_y;
                        var ct1_x = (prev_x + (diff_x / 3));
                        var ct1_y = (prev_y + (diff_y / 3));
                        var ct2_x = (cur_x - (diff_x / 3));
                        var ct2_y = (cur_y - (diff_y / 3));
                        points = [cur_x, cur_y, ct1_x, ct1_y, ct2_x, ct2_y]
                    }
                    break;
                case 4:
                    points = [cur_x, cur_y];
                    cur.olditem = cur.item;
                    break
            }
            cur.setType(new_type, points)
        }
        svgedit.path.path.endChanges(text)
    };
    svgedit.path.Path.prototype.selectPt = function(pt, ctrl_num)
    {
        this.clearSelection();
        if (pt == null)
        {
            this.eachSeg(function(i)
            {
                if (this.prev)
                {
                    pt = i
                }
            })
        }
        this.addPtsToSelection(pt);
        if (ctrl_num)
        {
            this.dragctrl = ctrl_num;
            if (link_control_pts)
            {
                this.segs[pt].setLinked(ctrl_num)
            }
        }
    };
    svgedit.path.Path.prototype.update = function()
    {
        var elem = this.elem;
        if (svgedit.utilities.getRotationAngle(elem))
        {
            this.matrix = svgedit.math.getMatrix(elem);
            this.imatrix = this.matrix.inverse()
        }
        else
        {
            this.matrix = null;
            this.imatrix = null
        }
        this.eachSeg(function(i)
        {
            this.item = elem.pathSegList.getItem(i);
            this.update()
        });
        return this
    };
    svgedit.path.getPath_ = function(elem)
    {
        var p = pathData[elem.id];
        if (!p)
        {
            p = pathData[elem.id] = new svgedit.path.Path(elem)
        }
        return p
    };
    svgedit.path.removePath_ = function(id)
    {
        if (id in pathData)
        {
            delete pathData[id]
        }
    };
    var newcx,
        newcy,
        oldcx,
        oldcy,
        angle;
    var getRotVals = function(x, y)
        {
            var dx = x - oldcx;
            var dy = y - oldcy;
            var r = Math.sqrt(dx * dx + dy * dy);
            var theta = Math.atan2(dy, dx) + angle;
            dx = r * Math.cos(theta) + oldcx;
            dy = r * Math.sin(theta) + oldcy;
            dx -= newcx;
            dy -= newcy;
            r = Math.sqrt(dx * dx + dy * dy);
            theta = Math.atan2(dy, dx) - angle;
            return {
                    x: r * Math.cos(theta) + newcx, y: r * Math.sin(theta) + newcy
                }
        };
    svgedit.path.recalcRotatedPath = function()
    {
        var current_path = svgedit.path.path.elem;
        angle = svgedit.utilities.getRotationAngle(current_path, true);
        if (!angle)
        {
            return
        }
        var box = svgedit.utilities.getBBox(current_path),
            oldbox = svgedit.path.path.oldbbox;
        oldcx = oldbox.x + oldbox.width / 2;
        oldcy = oldbox.y + oldbox.height / 2;
        newcx = box.x + box.width / 2;
        newcy = box.y + box.height / 2;
        var dx = newcx - oldcx,
            dy = newcy - oldcy,
            r = Math.sqrt(dx * dx + dy * dy),
            theta = Math.atan2(dy, dx) + angle;
        newcx = r * Math.cos(theta) + oldcx;
        newcy = r * Math.sin(theta) + oldcy;
        var list = current_path.pathSegList,
            i = list.numberOfItems;
        while (i)
        {
            i -= 1;
            var seg = list.getItem(i),
                type = seg.pathSegType;
            if (type == 1)
            {
                continue
            }
            var rvals = getRotVals(seg.x, seg.y),
                points = [rvals.x, rvals.y];
            if (seg.x1 != null && seg.x2 != null)
            {
                var c_vals1 = getRotVals(seg.x1, seg.y1);
                var c_vals2 = getRotVals(seg.x2, seg.y2);
                points.splice(points.length, 0, c_vals1.x, c_vals1.y, c_vals2.x, c_vals2.y)
            }
            svgedit.path.replacePathSeg(type, i, points)
        }
        box = svgedit.utilities.getBBox(current_path);
        var R_nc = svgroot.createSVGTransform(),
            tlist = svgedit.transformlist.getTransformList(current_path);
        R_nc.setRotate((angle * 180.0 / Math.PI), newcx, newcy);
        tlist.replaceItem(R_nc, 0)
    };
    svgedit.path.clearData = function()
    {
        pathData = {}
    }
}());
(function()
{
    if (!window.console)
    {
        window.console = {};
        window.console.log = function(str){};
        window.console.dir = function(str){}
    }
    if (window.opera)
    {
        window.console.log = function(str)
        {
            opera.postError(str)
        };
        window.console.dir = function(str){}
    }
}());
$.SvgCanvas = function(container, config)
{
    var NS = svgedit.NS;
    var curConfig = {
            show_outside_canvas: true, selectNew: true, dimensions: [640, 480]
        };
    if (config)
    {
        $.extend(curConfig, config)
    }
    var dimensions = curConfig.dimensions;
    var canvas = this;
    var svgdoc = container.ownerDocument;
    var svgroot = svgdoc.importNode(svgedit.utilities.text2xml('<svg id="svgroot" xmlns="' + NS.SVG + '" xlinkns="' + NS.XLINK + '" ' + 'width="' + dimensions[0] + '" height="' + dimensions[1] + '" x="' + dimensions[0] + '" y="' + dimensions[1] + '" overflow="visible">' + '<defs>' + '<filter id="canvashadow" filterUnits="objectBoundingBox">' + '<feGaussianBlur in="SourceAlpha" stdDeviation="4" result="blur"/>' + '<feOffset in="blur" dx="5" dy="5" result="offsetBlur"/>' + '<feMerge>' + '<feMergeNode in="offsetBlur"/>' + '<feMergeNode in="SourceGraphic"/>' + '</feMerge>' + '</filter>' + '</defs>' + '</svg>').documentElement, true);
    container.appendChild(svgroot);
    var svgcontent = svgdoc.createElementNS(NS.SVG, "svg");
    var clearSvgContentElement = canvas.clearSvgContentElement = function()
        {
            while (svgcontent.firstChild)
            {
                svgcontent.removeChild(svgcontent.firstChild)
            }
            $(svgcontent).attr({
                id: 'svgcontent', width: dimensions[0], height: dimensions[1], x: dimensions[0], y: dimensions[1], overflow: curConfig.show_outside_canvas ? 'visible' : 'hidden', xmlns: NS.SVG, "xmlns:se": NS.SE, "xmlns:xlink": NS.XLINK
            }).appendTo(svgroot);
            var comment = svgdoc.createComment(" Created with SVG-edit - http://svg-edit.googlecode.com/ ");
            svgcontent.appendChild(comment)
        };
    clearSvgContentElement();
    var idprefix = "svg_";
    canvas.setIdPrefix = function(p)
    {
        idprefix = p
    };
    canvas.current_drawing_ = new svgedit.draw.Drawing(svgcontent, idprefix);
    var getCurrentDrawing = canvas.getCurrentDrawing = function()
        {
            return canvas.current_drawing_
        };
    var current_zoom = 1;
    var current_group = null;
    var all_properties = {shape: {
                fill: (curConfig.initFill.color == 'none' ? '' : '#') + curConfig.initFill.color, fill_paint: null, fill_opacity: curConfig.initFill.opacity, stroke: "#" + curConfig.initStroke.color, stroke_paint: null, stroke_opacity: curConfig.initStroke.opacity, stroke_width: curConfig.initStroke.width, stroke_dasharray: 'none', stroke_linejoin: 'miter', stroke_linecap: 'butt', opacity: curConfig.initOpacity
            }};
    all_properties.text = $.extend(true, {}, all_properties.shape);
    $.extend(all_properties.text, {
        fill: "#000000", stroke_width: 0, font_size: 24, font_family: 'serif'
    });
    var cur_shape = all_properties.shape;
    var selectedElements = new Array(1);
    var addSvgElementFromJson = this.addSvgElementFromJson = function(data)
        {
            var shape = svgedit.utilities.getElem(data.attr.id);
            var current_layer = getCurrentDrawing().getCurrentLayer();
            if (shape && data.element != shape.tagName)
            {
                current_layer.removeChild(shape);
                shape = null
            }
            if (!shape)
            {
                shape = svgdoc.createElementNS(NS.SVG, data.element);
                if (current_layer)
                {
                    (current_group || current_layer).appendChild(shape)
                }
            }
            if (data.curStyles)
            {
                svgedit.utilities.assignAttributes(shape, {
                    fill: cur_shape.fill, stroke: cur_shape.stroke, "stroke-width": cur_shape.stroke_width, "stroke-dasharray": cur_shape.stroke_dasharray, "stroke-linejoin": cur_shape.stroke_linejoin, "stroke-linecap": cur_shape.stroke_linecap, "stroke-opacity": cur_shape.stroke_opacity, "fill-opacity": cur_shape.fill_opacity, opacity: cur_shape.opacity / 2, style: "pointer-events:inherit"
                }, 100)
            }
            svgedit.utilities.assignAttributes(shape, data.attr, 100);
            svgedit.utilities.cleanupElement(shape);
            return shape
        };
    var getTransformList = canvas.getTransformList = svgedit.transformlist.getTransformList;
    var transformPoint = svgedit.math.transformPoint;
    var matrixMultiply = canvas.matrixMultiply = svgedit.math.matrixMultiply;
    var hasMatrixTransform = canvas.hasMatrixTransform = svgedit.math.hasMatrixTransform;
    var transformListToTransform = canvas.transformListToTransform = svgedit.math.transformListToTransform;
    var snapToAngle = svgedit.math.snapToAngle;
    var getMatrix = svgedit.math.getMatrix;
    svgedit.units.init({
        getBaseUnit: function()
        {
            return curConfig.baseUnit
        }, getElement: svgedit.utilities.getElem, getHeight: function()
            {
                return svgcontent.getAttribute("height") / current_zoom
            }, getWidth: function()
            {
                return svgcontent.getAttribute("width") / current_zoom
            }, getRoundDigits: function()
            {
                return save_options.round_digits
            }
    });
    var convertToNum = canvas.convertToNum = svgedit.units.convertToNum;
    svgedit.utilities.init({
        getDOMDocument: function()
        {
            return svgdoc
        }, getDOMContainer: function()
            {
                return container
            }, getSVGRoot: function()
            {
                return svgroot
            }, getSelectedElements: function()
            {
                return selectedElements
            }, getSVGContent: function()
            {
                return svgcontent
            }, getBaseUnit: function()
            {
                return curConfig.baseUnit
            }, getStepSize: function()
            {
                return curConfig.stepSize
            }
    });
    var findDefs = canvas.findDefs = svgedit.utilities.findDefs;
    var getUrlFromAttr = canvas.getUrlFromAttr = svgedit.utilities.getUrlFromAttr;
    var getHref = canvas.getHref = svgedit.utilities.getHref;
    var setHref = canvas.setHref = svgedit.utilities.setHref;
    var getPathBBox = svgedit.utilities.getPathBBox;
    var getBBox = canvas.getBBox = svgedit.utilities.getBBox;
    var getRotationAngle = canvas.getRotationAngle = svgedit.utilities.getRotationAngle;
    var getElem = canvas.getElem = svgedit.utilities.getElem;
    var getRefElem = canvas.getRefElem = svgedit.utilities.getRefElem;
    var assignAttributes = canvas.assignAttributes = svgedit.utilities.assignAttributes;
    var cleanupElement = this.cleanupElement = svgedit.utilities.cleanupElement;
    svgedit.coords.init({
        getDrawing: function()
        {
            return getCurrentDrawing()
        }, getGridSnapping: function()
            {
                return curConfig.gridSnapping
            }
    });
    var remapElement = this.remapElement = svgedit.coords.remapElement;
    svgedit.recalculate.init({
        getSVGRoot: function()
        {
            return svgroot
        }, getStartTransform: function()
            {
                return startTransform
            }, setStartTransform: function(transform)
            {
                startTransform = transform
            }
    });
    var recalculateDimensions = this.recalculateDimensions = svgedit.recalculate.recalculateDimensions;
    var nsMap = svgedit.getReverseNS();
    var sanitizeSvg = canvas.sanitizeSvg = svgedit.sanitize.sanitizeSvg;
    var MoveElementCommand = svgedit.history.MoveElementCommand;
    var InsertElementCommand = svgedit.history.InsertElementCommand;
    var RemoveElementCommand = svgedit.history.RemoveElementCommand;
    var ChangeElementCommand = svgedit.history.ChangeElementCommand;
    var BatchCommand = svgedit.history.BatchCommand;
    canvas.undoMgr = new svgedit.history.UndoManager({handleHistoryEvent: function(eventType, cmd)
        {
            var EventTypes = svgedit.history.HistoryEventTypes;
            if (eventType == EventTypes.BEFORE_UNAPPLY || eventType == EventTypes.BEFORE_APPLY)
            {
                canvas.clearSelection()
            }
            else if (eventType == EventTypes.AFTER_APPLY || eventType == EventTypes.AFTER_UNAPPLY)
            {
                var elems = cmd.elements();
                canvas.pathActions.clear();
                call("changed", elems);
                var cmdType = cmd.type();
                var isApply = (eventType == EventTypes.AFTER_APPLY);
                if (cmdType == MoveElementCommand.type())
                {
                    var parent = isApply ? cmd.newParent : cmd.oldParent;
                    if (parent == svgcontent)
                    {
                        canvas.identifyLayers()
                    }
                }
                else if (cmdType == InsertElementCommand.type() || cmdType == RemoveElementCommand.type())
                {
                    if (cmd.parent == svgcontent)
                    {
                        canvas.identifyLayers()
                    }
                    if (cmdType == InsertElementCommand.type())
                    {
                        if (isApply)
                        {
                            restoreRefElems(cmd.elem)
                        }
                    }
                    else
                    {
                        if (!isApply)
                        {
                            restoreRefElems(cmd.elem)
                        }
                    }
                    if (cmd.elem.tagName === 'use')
                    {
                        setUseData(cmd.elem)
                    }
                }
                else if (cmdType == ChangeElementCommand.type())
                {
                    if (cmd.elem.tagName == "title" && cmd.elem.parentNode.parentNode == svgcontent)
                    {
                        canvas.identifyLayers()
                    }
                    var values = isApply ? cmd.newValues : cmd.oldValues;
                    if (values.stdDeviation)
                    {
                        canvas.setBlurOffsets(cmd.elem.parentNode, values.stdDeviation)
                    }
                }
            }
        }});
    var addCommandToHistory = function(cmd)
        {
            canvas.undoMgr.addCommandToHistory(cmd)
        };
    svgedit.select.init(curConfig, {
        createSVGElement: function(jsonMap)
        {
            return canvas.addSvgElementFromJson(jsonMap)
        }, svgRoot: function()
            {
                return svgroot
            }, svgContent: function()
            {
                return svgcontent
            }, currentZoom: function()
            {
                return current_zoom
            }, getStrokedBBox: function(elems)
            {
                return canvas.getStrokedBBox([elems])
            }
    });
    var selectorManager = this.selectorManager = svgedit.select.getSelectorManager();
    svgedit.path.init({
        getCurrentZoom: function()
        {
            return current_zoom
        }, getSVGRoot: function()
            {
                return svgroot
            }
    });
    var uiStrings = {
            exportNoBlur: "Blurred elements will appear as un-blurred", exportNoforeignObject: "foreignObject elements will not appear", exportNoDashArray: "Strokes will appear filled", exportNoText: "Text may not appear as expected"
        };
    var visElems = 'a,circle,ellipse,foreignObject,g,image,line,path,polygon,polyline,rect,svg,text,tspan,use';
    var ref_attrs = ["clip-path", "fill", "filter", "marker-end", "marker-mid", "marker-start", "mask", "stroke"];
    var elData = $.data;
    var opac_ani = document.createElementNS(NS.SVG, 'animate');
    $(opac_ani).attr({
        attributeName: 'opacity', begin: 'indefinite', dur: 1, fill: 'freeze'
    }).appendTo(svgroot);
    var restoreRefElems = function(elem)
        {
            var o,
                i,
                attrs = $(elem).attr(ref_attrs);
            for (o in attrs)
            {
                var val = attrs[o];
                if (val && val.indexOf('url(') === 0)
                {
                    var id = svgedit.utilities.getUrlFromAttr(val).substr(1);
                    var ref = getElem(id);
                    if (!ref)
                    {
                        svgedit.utilities.findDefs().appendChild(removedElements[id]);
                        delete removedElements[id]
                    }
                }
            }
            var childs = elem.getElementsByTagName('*');
            if (childs.length)
            {
                for (i = 0, l = childs.length; i < l; i++)
                {
                    restoreRefElems(childs[i])
                }
            }
        };
    (function(){}());
    var encodableImages = {},
        last_good_img_url = curConfig.imgPath + 'logo.png',
        disabled_elems = [],
        save_options = {round_digits: 5},
        started = false,
        startTransform = null,
        current_mode = "select",
        current_resize_mode = "none",
        import_ids = {},
        cur_text = all_properties.text,
        cur_properties = cur_shape,
        justSelected = null,
        rubberBox = null,
        curBBoxes = [],
        extensions = {},
        lastClickPoint = null,
        removedElements = {};
    canvas.clipBoard = [];
    var runExtensions = this.runExtensions = function(action, vars, returnArray)
        {
            var result = returnArray ? [] : false;
            $.each(extensions, function(name, opts)
            {
                if (opts && action in opts)
                {
                    if (returnArray)
                    {
                        result.push(opts[action](vars))
                    }
                    else
                    {
                        result = opts[action](vars)
                    }
                }
            });
            return result
        };
    this.addExtension = function(name, ext_func)
    {
        var ext;
        if (!(name in extensions))
        {
            if ($.isFunction(ext_func))
            {
                ext = ext_func($.extend(canvas.getPrivateMethods(), {
                    svgroot: svgroot, svgcontent: svgcontent, nonce: getCurrentDrawing().getNonce(), selectorManager: selectorManager
                }))
            }
            else
            {
                ext = ext_func
            }
            extensions[name] = ext;
            call("extension_added", ext)
        }
        else
        {
            console.log('Cannot add extension "' + name + '", an extension by that name already exists"')
        }
    };
    var round = this.round = function(val)
        {
            return parseInt(val * current_zoom, 10) / current_zoom
        };
    var getIntersectionList = this.getIntersectionList = function(rect)
        {
            if (rubberBox == null)
            {
                return null
            }
            var parent = current_group || getCurrentDrawing().getCurrentLayer();
            if (!curBBoxes.length)
            {
                curBBoxes = getVisibleElementsAndBBoxes(parent)
            }
            var resultList = null;
            try
            {
                resultList = parent.getIntersectionList(rect, null)
            }
            catch(e) {}
            if (resultList == null || typeof(resultList.item) != "function")
            {
                resultList = [];
                var rubberBBox;
                if (!rect)
                {
                    rubberBBox = rubberBox.getBBox();
                    var o,
                        bb = {};
                    for (o in rubberBBox)
                    {
                        bb[o] = rubberBBox[o] / current_zoom
                    }
                    rubberBBox = bb
                }
                else
                {
                    rubberBBox = rect
                }
                var i = curBBoxes.length;
                while (i--)
                {
                    if (!rubberBBox.width)
                    {
                        continue
                    }
                    if (svgedit.math.rectsIntersect(rubberBBox, curBBoxes[i].bbox))
                    {
                        resultList.push(curBBoxes[i].elem)
                    }
                }
            }
            return resultList
        };
    getStrokedBBox = this.getStrokedBBox = function(elems)
    {
        if (!elems)
        {
            elems = getVisibleElements()
        }
        if (!elems.length)
        {
            return false
        }
        var getCheckedBBox = function(elem)
            {
                try
                {
                    var bb = svgedit.utilities.getBBox(elem);
                    var angle = svgedit.utilities.getRotationAngle(elem);
                    if ((angle && angle % 90) || svgedit.math.hasMatrixTransform(svgedit.transformlist.getTransformList(elem)))
                    {
                        var good_bb = false;
                        var elemNames = ['ellipse', 'path', 'line', 'polyline', 'polygon'];
                        if (elemNames.indexOf(elem.tagName) >= 0)
                        {
                            bb = good_bb = canvas.convertToPath(elem, true)
                        }
                        else if (elem.tagName == 'rect')
                        {
                            var rx = elem.getAttribute('rx');
                            var ry = elem.getAttribute('ry');
                            if (rx || ry)
                            {
                                bb = good_bb = canvas.convertToPath(elem, true)
                            }
                        }
                        if (!good_bb)
                        {
                            var clone = elem.cloneNode(true);
                            var g = document.createElementNS(NS.SVG, "g");
                            var parent = elem.parentNode;
                            parent.appendChild(g);
                            g.appendChild(clone);
                            bb = svgedit.utilities.bboxToObj(g.getBBox());
                            parent.removeChild(g)
                        }
                    }
                    return bb
                }
                catch(e)
                {
                    console.log(elem, e);
                    return null
                }
            };
        var full_bb;
        $.each(elems, function()
        {
            if (full_bb)
            {
                return
            }
            if (!this.parentNode)
            {
                return
            }
            full_bb = getCheckedBBox(this)
        });
        if (full_bb == null)
        {
            return null
        }
        var max_x = full_bb.x + full_bb.width;
        var max_y = full_bb.y + full_bb.height;
        var min_x = full_bb.x;
        var min_y = full_bb.y;
        var getOffset = function(elem)
            {
                var sw = elem.getAttribute("stroke-width");
                var offset = 0;
                if (elem.getAttribute("stroke") != "none" && !isNaN(sw))
                {
                    offset += sw / 2
                }
                return offset
            };
        var bboxes = [];
        $.each(elems, function(i, elem)
        {
            var cur_bb = getCheckedBBox(elem);
            if (cur_bb)
            {
                var offset = getOffset(elem);
                min_x = Math.min(min_x, cur_bb.x - offset);
                min_y = Math.min(min_y, cur_bb.y - offset);
                bboxes.push(cur_bb)
            }
        });
        full_bb.x = min_x;
        full_bb.y = min_y;
        $.each(elems, function(i, elem)
        {
            var cur_bb = bboxes[i];
            if (cur_bb && elem.nodeType == 1)
            {
                var offset = getOffset(elem);
                max_x = Math.max(max_x, cur_bb.x + cur_bb.width + offset);
                max_y = Math.max(max_y, cur_bb.y + cur_bb.height + offset)
            }
        });
        full_bb.width = max_x - min_x;
        full_bb.height = max_y - min_y;
        return full_bb
    };
    var getVisibleElements = this.getVisibleElements = function(parent)
        {
            if (!parent)
            {
                parent = $(svgcontent).children()
            }
            var contentElems = [];
            $(parent).children().each(function(i, elem)
            {
                try
                {
                    if (elem.getBBox())
                    {
                        contentElems.push(elem)
                    }
                }
                catch(e) {}
            });
            return contentElems.reverse()
        };
    var getVisibleElementsAndBBoxes = this.getVisibleElementsAndBBoxes = function(parent)
        {
            if (!parent)
            {
                parent = $(svgcontent).children()
            }
            var contentElems = [];
            $(parent).children().each(function(i, elem)
            {
                try
                {
                    if (elem.getBBox())
                    {
                        contentElems.push({
                            elem: elem, bbox: getStrokedBBox([elem])
                        })
                    }
                }
                catch(e) {}
            });
            return contentElems.reverse()
        };
    var groupSvgElem = this.groupSvgElem = function(elem)
        {
            var g = document.createElementNS(NS.SVG, "g");
            elem.parentNode.replaceChild(g, elem);
            $(g).append(elem).data('gsvg', elem)[0].id = getNextId()
        };
    var copyElem = function(el)
        {
            var new_el = document.createElementNS(el.namespaceURI, el.nodeName);
            $.each(el.attributes, function(i, attr)
            {
                if (attr.localName != '-moz-math-font-style')
                {
                    new_el.setAttributeNS(attr.namespaceURI, attr.nodeName, attr.nodeValue)
                }
            });
            new_el.removeAttribute("id");
            new_el.id = getNextId();
            if (svgedit.browser.isWebkit() && el.nodeName == 'path')
            {
                var fixed_d = pathActions.convertPath(el);
                new_el.setAttribute('d', fixed_d)
            }
            $.each(el.childNodes, function(i, child)
            {
                switch (child.nodeType)
                {
                    case 1:
                        new_el.appendChild(copyElem(child));
                        break;
                    case 3:
                        new_el.textContent = child.nodeValue;
                        break;
                    default:
                        break
                }
            });
            if ($(el).data('gsvg'))
            {
                $(new_el).data('gsvg', new_el.firstChild)
            }
            else if ($(el).data('symbol'))
            {
                var ref = $(el).data('symbol');
                $(new_el).data('ref', ref).data('symbol', ref)
            }
            else if (new_el.tagName == 'image')
            {
                preventClickDefault(new_el)
            }
            return new_el
        };
    var getId,
        getNextId,
        call;
    var textActions,
        pathActions;
    (function(c)
    {
        var events = {};
        getId = c.getId = function()
        {
            return getCurrentDrawing().getId()
        };
        getNextId = c.getNextId = function()
        {
            return getCurrentDrawing().getNextId()
        };
        call = c.call = function(event, arg)
        {
            if (events[event])
            {
                return events[event](this, arg)
            }
        };
        c.bind = function(event, f)
        {
            var old = events[event];
            events[event] = f;
            return old
        }
    }(canvas));
    this.prepareSvg = function(newDoc)
    {
        this.sanitizeSvg(newDoc.documentElement);
        var i,
            path,
            len,
            paths = newDoc.getElementsByTagNameNS(NS.SVG, "path");
        for (i = 0, len = paths.length; i < len; ++i)
        {
            path = paths[i];
            path.setAttribute('d', pathActions.convertPath(path));
            pathActions.fixEnd(path)
        }
    };
    var ffClone = function(elem)
        {
            if (!svgedit.browser.isGecko())
            {
                return elem
            }
            var clone = elem.cloneNode(true);
            elem.parentNode.insertBefore(clone, elem);
            elem.parentNode.removeChild(elem);
            selectorManager.releaseSelector(elem);
            selectedElements[0] = clone;
            selectorManager.requestSelector(clone).showGrips(true);
            return clone
        };
    this.setRotationAngle = function(val, preventUndo)
    {
        val = parseFloat(val);
        var elem = selectedElements[0];
        var oldTransform = elem.getAttribute("transform");
        var bbox = svgedit.utilities.getBBox(elem);
        var cx = bbox.x + bbox.width / 2,
            cy = bbox.y + bbox.height / 2;
        var tlist = svgedit.transformlist.getTransformList(elem);
        if (tlist.numberOfItems > 0)
        {
            var xform = tlist.getItem(0);
            if (xform.type == 4)
            {
                tlist.removeItem(0)
            }
        }
        if (val != 0)
        {
            var center = svgedit.math.transformPoint(cx, cy, svgedit.math.transformListToTransform(tlist).matrix);
            var R_nc = svgroot.createSVGTransform();
            R_nc.setRotate(val, center.x, center.y);
            if (tlist.numberOfItems)
            {
                tlist.insertItemBefore(R_nc, 0)
            }
            else
            {
                tlist.appendItem(R_nc)
            }
        }
        else if (tlist.numberOfItems == 0)
        {
            elem.removeAttribute("transform")
        }
        if (!preventUndo)
        {
            var newTransform = elem.getAttribute("transform");
            elem.setAttribute("transform", oldTransform);
            changeSelectedAttribute("transform", newTransform, selectedElements);
            call("changed", selectedElements)
        }
        var pointGripContainer = svgedit.utilities.getElem("pathpointgrip_container");
        var selector = selectorManager.requestSelector(selectedElements[0]);
        selector.resize();
        selector.updateGripCursors(val)
    };
    var recalculateAllSelectedDimensions = this.recalculateAllSelectedDimensions = function()
        {
            var text = (current_resize_mode == "none" ? "position" : "size");
            var batchCmd = new svgedit.history.BatchCommand(text);
            var i = selectedElements.length;
            while (i--)
            {
                var elem = selectedElements[i];
                var cmd = svgedit.recalculate.recalculateDimensions(elem);
                if (cmd)
                {
                    batchCmd.addSubCommand(cmd)
                }
            }
            if (!batchCmd.isEmpty())
            {
                addCommandToHistory(batchCmd);
                call("changed", selectedElements)
            }
        };
    var pathMap = [0, 'z', 'M', 'm', 'L', 'l', 'C', 'c', 'Q', 'q', 'A', 'a', 'H', 'h', 'V', 'v', 'S', 's', 'T', 't'];
    var logMatrix = function(m)
        {
            console.log([m.a, m.b, m.c, m.d, m.e, m.f])
        };
    var root_sctm = null;
    var clearSelection = this.clearSelection = function(noCall)
        {
            if (selectedElements[0] != null)
            {
                var i,
                    elem,
                    len = selectedElements.length;
                for (i = 0; i < len; ++i)
                {
                    elem = selectedElements[i];
                    if (elem == null)
                    {
                        break
                    }
                    selectorManager.releaseSelector(elem);
                    selectedElements[i] = null
                }
            }
            if (!noCall)
            {
                call("selected", selectedElements)
            }
        };
    var addToSelection = this.addToSelection = function(elemsToAdd, showGrips)
        {
            if (elemsToAdd.length == 0)
            {
                return
            }
            var j = 0;
            while (j < selectedElements.length)
            {
                if (selectedElements[j] == null)
                {
                    break
                }
                ++j
            }
            var i = elemsToAdd.length;
            while (i--)
            {
                var elem = elemsToAdd[i];
                if (!elem || !svgedit.utilities.getBBox(elem))
                {
                    continue
                }
                if (elem.tagName === 'a' && elem.childNodes.length === 1)
                {
                    elem = elem.firstChild
                }
                if (selectedElements.indexOf(elem) == -1)
                {
                    selectedElements[j] = elem;
                    j++;
                    var sel = selectorManager.requestSelector(elem);
                    if (selectedElements.length > 1)
                    {
                        sel.showGrips(false)
                    }
                }
            }
            call("selected", selectedElements);
            if (showGrips || selectedElements.length == 1)
            {
                selectorManager.requestSelector(selectedElements[0]).showGrips(true)
            }
            else
            {
                selectorManager.requestSelector(selectedElements[0]).showGrips(false)
            }
            selectedElements.sort(function(a, b)
            {
                if (a && b && a.compareDocumentPosition)
                {
                    return 3 - (b.compareDocumentPosition(a) & 6)
                }
                if (a == null)
                {
                    return 1
                }
            });
            while (selectedElements[0] == null)
            {
                selectedElements.shift(0)
            }
        };
    var selectOnly = this.selectOnly = function(elems, showGrips)
        {
            clearSelection(true);
            addToSelection(elems, showGrips)
        };
    var removeFromSelection = this.removeFromSelection = function(elemsToRemove)
        {
            if (selectedElements[0] == null)
            {
                return
            }
            if (elemsToRemove.length == 0)
            {
                return
            }
            var i,
                j = 0,
                newSelectedItems = new Array(selectedElements.length),
                len = selectedElements.length;
            for (i = 0; i < len; ++i)
            {
                var elem = selectedElements[i];
                if (elem)
                {
                    if (elemsToRemove.indexOf(elem) == -1)
                    {
                        newSelectedItems[j] = elem;
                        j++
                    }
                    else
                    {
                        selectorManager.releaseSelector(elem)
                    }
                }
            }
            selectedElements = newSelectedItems
        };
    this.selectAllInCurrentLayer = function()
    {
        var current_layer = getCurrentDrawing().getCurrentLayer();
        if (current_layer)
        {
            current_mode = "select";
            selectOnly($(current_group || current_layer).children())
        }
    };
    var getMouseTarget = this.getMouseTarget = function(evt)
        {
            if (evt == null)
            {
                return null
            }
            var mouse_target = evt.target;
            if (mouse_target.correspondingUseElement)
            {
                mouse_target = mouse_target.correspondingUseElement
            }
            if ([NS.MATH, NS.HTML].indexOf(mouse_target.namespaceURI) >= 0 && mouse_target.id != "svgcanvas")
            {
                while (mouse_target.nodeName != "foreignObject")
                {
                    mouse_target = mouse_target.parentNode;
                    if (!mouse_target)
                    {
                        return svgroot
                    }
                }
            }
            var current_layer = getCurrentDrawing().getCurrentLayer();
            if ([svgroot, container, svgcontent, current_layer].indexOf(mouse_target) >= 0)
            {
                return svgroot
            }
            var $target = $(mouse_target);
            if ($target.closest('#selectorParentGroup').length)
            {
                return selectorManager.selectorParentGroup
            }
            while (mouse_target.parentNode !== (current_group || current_layer))
            {
                mouse_target = mouse_target.parentNode
            }
            return mouse_target
        };
    (function()
    {
        var d_attr = null,
            start_x = null,
            start_y = null,
            r_start_x = null,
            r_start_y = null,
            init_bbox = {},
            freehand = {
                minx: null, miny: null, maxx: null, maxy: null
            },
            sumDistance = 0,
            controllPoint2 = {
                x: 0, y: 0
            },
            controllPoint1 = {
                x: 0, y: 0
            },
            start = {
                x: 0, y: 0
            },
            end = {
                x: 0, y: 0
            },
            parameter,
            nextParameter,
            bSpline = {
                x: 0, y: 0
            },
            nextPos = {
                x: 0, y: 0
            },
            THRESHOLD_DIST = 0.8,
            STEP_COUNT = 10;
        var getBsplinePoint = function(t)
            {
                var spline = {
                        x: 0, y: 0
                    },
                    p0 = controllPoint2,
                    p1 = controllPoint1,
                    p2 = start,
                    p3 = end,
                    S = 1.0 / 6.0,
                    t2 = t * t,
                    t3 = t2 * t;
                var m = [[-1, 3, -3, 1], [3, -6, 3, 0], [-3, 0, 3, 0], [1, 4, 1, 0]];
                spline.x = S * ((p0.x * m[0][0] + p1.x * m[0][1] + p2.x * m[0][2] + p3.x * m[0][3]) * t3 + (p0.x * m[1][0] + p1.x * m[1][1] + p2.x * m[1][2] + p3.x * m[1][3]) * t2 + (p0.x * m[2][0] + p1.x * m[2][1] + p2.x * m[2][2] + p3.x * m[2][3]) * t + (p0.x * m[3][0] + p1.x * m[3][1] + p2.x * m[3][2] + p3.x * m[3][3]));
                spline.y = S * ((p0.y * m[0][0] + p1.y * m[0][1] + p2.y * m[0][2] + p3.y * m[0][3]) * t3 + (p0.y * m[1][0] + p1.y * m[1][1] + p2.y * m[1][2] + p3.y * m[1][3]) * t2 + (p0.y * m[2][0] + p1.y * m[2][1] + p2.y * m[2][2] + p3.y * m[2][3]) * t + (p0.y * m[3][0] + p1.y * m[3][1] + p2.y * m[3][2] + p3.y * m[3][3]));
                return {
                        x: spline.x, y: spline.y
                    }
            };
        var mouseDown = function(evt)
            {
                if (canvas.spaceKey || evt.button === 1)
                {
                    return
                }
                var right_click = evt.button === 2;
                if (evt.altKey)
                {
                    svgCanvas.cloneSelectedElements(0, 0)
                }
                root_sctm = $('#svgcontent g')[0].getScreenCTM().inverse();
                var pt = svgedit.math.transformPoint(evt.pageX, evt.pageY, root_sctm),
                    mouse_x = pt.x * current_zoom - $('body').scrollLeft(),
                    mouse_y = pt.y * current_zoom - $('body').scrollTop();
                evt.preventDefault();
                if (right_click)
                {
                    current_mode = "select";
                    lastClickPoint = pt
                }
                var x = mouse_x / current_zoom,
                    y = mouse_y / current_zoom,
                    mouse_target = getMouseTarget(evt);
                if (mouse_target.tagName === 'a' && mouse_target.childNodes.length === 1)
                {
                    mouse_target = mouse_target.firstChild
                }
                var real_x = x;
                r_start_x = start_x = x;
                var real_y = y;
                r_start_y = start_y = y;
                if (curConfig.gridSnapping)
                {
                    x = svgedit.utilities.snapToGrid(x);
                    y = svgedit.utilities.snapToGrid(y);
                    start_x = svgedit.utilities.snapToGrid(start_x);
                    start_y = svgedit.utilities.snapToGrid(start_y)
                }
                if (mouse_target == selectorManager.selectorParentGroup && selectedElements[0] != null)
                {
                    var grip = evt.target;
                    var griptype = elData(grip, "type");
                    if (griptype == "rotate")
                    {
                        current_mode = "rotate"
                    }
                    else if (griptype == "resize")
                    {
                        current_mode = "resize";
                        current_resize_mode = elData(grip, "dir")
                    }
                    mouse_target = selectedElements[0]
                }
                startTransform = mouse_target.getAttribute("transform");
                var i,
                    stroke_w,
                    tlist = svgedit.transformlist.getTransformList(mouse_target);
                switch (current_mode)
                {
                    case"select":
                        started = true;
                        current_resize_mode = "none";
                        if (right_click)
                        {
                            started = false
                        }
                        if (mouse_target != svgroot)
                        {
                            if (selectedElements.indexOf(mouse_target) == -1)
                            {
                                if (!evt.shiftKey)
                                {
                                    clearSelection(true)
                                }
                                addToSelection([mouse_target]);
                                justSelected = mouse_target;
                                pathActions.clear()
                            }
                            if (!right_click)
                            {
                                for (i = 0; i < selectedElements.length; ++i)
                                {
                                    if (selectedElements[i] == null)
                                    {
                                        continue
                                    }
                                    var slist = svgedit.transformlist.getTransformList(selectedElements[i]);
                                    if (slist.numberOfItems)
                                    {
                                        slist.insertItemBefore(svgroot.createSVGTransform(), 0)
                                    }
                                    else
                                    {
                                        slist.appendItem(svgroot.createSVGTransform())
                                    }
                                }
                            }
                        }
                        else if (!right_click)
                        {
                            clearSelection();
                            current_mode = "multiselect";
                            if (rubberBox == null)
                            {
                                rubberBox = selectorManager.getRubberBandBox()
                            }
                            r_start_x *= current_zoom;
                            r_start_y *= current_zoom;
                            svgedit.utilities.assignAttributes(rubberBox, {
                                x: r_start_x, y: r_start_y, width: 0, height: 0, display: 'inline'
                            }, 100)
                        }
                        break;
                    case"zoom":
                        started = true;
                        if (rubberBox == null)
                        {
                            rubberBox = selectorManager.getRubberBandBox()
                        }
                        svgedit.utilities.assignAttributes(rubberBox, {
                            x: real_x * current_zoom, y: real_x * current_zoom, width: 0, height: 0, display: 'inline'
                        }, 100);
                        break;
                    case"resize":
                        started = true;
                        start_x = x;
                        start_y = y;
                        init_bbox = svgedit.utilities.getBBox($('#selectedBox0')[0]);
                        var bb = {};
                        $.each(init_bbox, function(key, val)
                        {
                            bb[key] = val / current_zoom
                        });
                        init_bbox = bb;
                        var pos = svgedit.utilities.getRotationAngle(mouse_target) ? 1 : 0;
                        if (svgedit.math.hasMatrixTransform(tlist))
                        {
                            tlist.insertItemBefore(svgroot.createSVGTransform(), pos);
                            tlist.insertItemBefore(svgroot.createSVGTransform(), pos);
                            tlist.insertItemBefore(svgroot.createSVGTransform(), pos)
                        }
                        else
                        {
                            tlist.appendItem(svgroot.createSVGTransform());
                            tlist.appendItem(svgroot.createSVGTransform());
                            tlist.appendItem(svgroot.createSVGTransform());
                            if (svgedit.browser.supportsNonScalingStroke())
                            {
                                var isWebkit = svgedit.browser.isWebkit();
                                if (isWebkit)
                                {
                                    var delayedStroke = function(ele)
                                        {
                                            var _stroke = ele.getAttributeNS(null, 'stroke');
                                            ele.removeAttributeNS(null, 'stroke');
                                            setTimeout(function()
                                            {
                                                ele.setAttributeNS(null, 'stroke', _stroke)
                                            }, 0)
                                        }
                                }
                                mouse_target.style.vectorEffect = 'non-scaling-stroke';
                                if (isWebkit)
                                {
                                    delayedStroke(mouse_target)
                                }
                                var all = mouse_target.getElementsByTagName('*'),
                                    len = all.length;
                                for (i = 0; i < len; i++)
                                {
                                    all[i].style.vectorEffect = 'non-scaling-stroke';
                                    if (isWebkit)
                                    {
                                        delayedStroke(all[i])
                                    }
                                }
                            }
                        }
                        break;
                    case"fhellipse":
                    case"fhrect":
                    case"fhpath":
                        start.x = real_x;
                        start.y = real_y;
                        started = true;
                        d_attr = real_x + "," + real_y + " ";
                        stroke_w = cur_shape.stroke_width == 0 ? 1 : cur_shape.stroke_width;
                        addSvgElementFromJson({
                            element: "polyline", curStyles: true, attr: {
                                    points: d_attr, id: getNextId(), fill: "none", opacity: cur_shape.opacity / 2, "stroke-linecap": "round", style: "pointer-events:none"
                                }
                        });
                        freehand.minx = real_x;
                        freehand.maxx = real_x;
                        freehand.miny = real_y;
                        freehand.maxy = real_y;
                        break;
                    case"image":
                        started = true;
                        var newImage = addSvgElementFromJson({
                                element: "image", attr: {
                                        x: x, y: y, width: 0, height: 0, id: getNextId(), opacity: cur_shape.opacity / 2, style: "pointer-events:inherit"
                                    }
                            });
                        setHref(newImage, last_good_img_url);
                        preventClickDefault(newImage);
                        break;
                    case"square":
                    case"rect":
                        started = true;
                        start_x = x;
                        start_y = y;
                        addSvgElementFromJson({
                            element: "rect", curStyles: true, attr: {
                                    x: x, y: y, width: 0, height: 0, id: getNextId(), opacity: cur_shape.opacity / 2
                                }
                        });
                        break;
                    case"line":
                        started = true;
                        stroke_w = cur_shape.stroke_width == 0 ? 1 : cur_shape.stroke_width;
                        addSvgElementFromJson({
                            element: "line", curStyles: true, attr: {
                                    x1: x, y1: y, x2: x, y2: y, id: getNextId(), stroke: cur_shape.stroke, "stroke-width": stroke_w, "stroke-dasharray": cur_shape.stroke_dasharray, "stroke-linejoin": cur_shape.stroke_linejoin, "stroke-linecap": cur_shape.stroke_linecap, "stroke-opacity": cur_shape.stroke_opacity, fill: "none", opacity: cur_shape.opacity / 2, style: "pointer-events:none"
                                }
                        });
                        break;
                    case"circle":
                        started = true;
                        addSvgElementFromJson({
                            element: "circle", curStyles: true, attr: {
                                    cx: x, cy: y, r: 0, id: getNextId(), opacity: cur_shape.opacity / 2
                                }
                        });
                        break;
                    case"ellipse":
                        started = true;
                        addSvgElementFromJson({
                            element: "ellipse", curStyles: true, attr: {
                                    cx: x, cy: y, rx: 0, ry: 0, id: getNextId(), opacity: cur_shape.opacity / 2
                                }
                        });
                        break;
                    case"text":
                        started = true;
                        var newText = addSvgElementFromJson({
                                element: "text", curStyles: true, attr: {
                                        x: x, y: y, id: getNextId(), fill: cur_text.fill, "stroke-width": cur_text.stroke_width, "font-size": cur_text.font_size, "font-family": cur_text.font_family, "text-anchor": "middle", "xml:space": "preserve", opacity: cur_shape.opacity
                                    }
                            });
                        break;
                    case"path":
                    case"pathedit":
                        start_x *= current_zoom;
                        start_y *= current_zoom;
                        pathActions.mouseDown(evt, mouse_target, start_x, start_y);
                        started = true;
                        break;
                    case"textedit":
                        start_x *= current_zoom;
                        start_y *= current_zoom;
                        textActions.mouseDown(evt, mouse_target, start_x, start_y);
                        started = true;
                        break;
                    case"rotate":
                        started = true;
                        canvas.undoMgr.beginUndoableChange("transform", selectedElements);
                        break;
                    default:
                        break
                }
                var ext_result = runExtensions("mouseDown", {
                        event: evt, start_x: start_x, start_y: start_y, selectedElements: selectedElements
                    }, true);
                $.each(ext_result, function(i, r)
                {
                    if (r && r.started)
                    {
                        started = true
                    }
                })
            };
        var mouseMove = function(evt)
            {
                if (!started)
                {
                    return
                }
                if (evt.button === 1 || canvas.spaceKey)
                {
                    return
                }
                var i,
                    xya,
                    c,
                    cx,
                    cy,
                    dx,
                    dy,
                    len,
                    angle,
                    box,
                    selected = selectedElements[0],
                    pt = svgedit.math.transformPoint(evt.pageX, evt.pageY, root_sctm),
                    mouse_x = pt.x * current_zoom - $('body').scrollLeft(),
                    mouse_y = pt.y * current_zoom - $('body').scrollTop();
                shape = svgedit.utilities.getElem(getId());
                var real_x = mouse_x / current_zoom;
                x = real_x;
                var real_y = mouse_y / current_zoom;
                y = real_y;
                if (curConfig.gridSnapping)
                {
                    x = svgedit.utilities.snapToGrid(x);
                    y = svgedit.utilities.snapToGrid(y)
                }
                evt.preventDefault();
                var tlist;
                switch (current_mode)
                {
                    case"select":
                        if (selectedElements[0] !== null)
                        {
                            dx = x - start_x;
                            dy = y - start_y;
                            if (curConfig.gridSnapping)
                            {
                                dx = svgedit.utilities.snapToGrid(dx);
                                dy = svgedit.utilities.snapToGrid(dy)
                            }
                            if (evt.shiftKey)
                            {
                                xya = svgedit.math.snapToAngle(start_x, start_y, x, y);
                                x = xya.x;
                                y = xya.y
                            }
                            if (dx != 0 || dy != 0)
                            {
                                len = selectedElements.length;
                                for (i = 0; i < len; ++i)
                                {
                                    selected = selectedElements[i];
                                    if (selected == null)
                                    {
                                        break
                                    }
                                    var xform = svgroot.createSVGTransform();
                                    tlist = svgedit.transformlist.getTransformList(selected);
                                    xform.setTranslate(dx, dy);
                                    if (tlist.numberOfItems)
                                    {
                                        tlist.replaceItem(xform, 0)
                                    }
                                    else
                                    {
                                        tlist.appendItem(xform)
                                    }
                                    selectorManager.requestSelector(selected).resize()
                                }
                                call("transition", selectedElements)
                            }
                        }
                        break;
                    case"multiselect":
                        real_x *= current_zoom;
                        real_y *= current_zoom;
                        svgedit.utilities.assignAttributes(rubberBox, {
                            x: Math.min(r_start_x, real_x), y: Math.min(r_start_y, real_y), width: Math.abs(real_x - r_start_x), height: Math.abs(real_y - r_start_y)
                        }, 100);
                        var elemsToRemove = [],
                            elemsToAdd = [],
                            newList = getIntersectionList();
                        len = selectedElements.length;
                        for (i = 0; i < len; ++i)
                        {
                            var ind = newList.indexOf(selectedElements[i]);
                            if (ind == -1)
                            {
                                elemsToRemove.push(selectedElements[i])
                            }
                            else
                            {
                                newList[ind] = null
                            }
                        }
                        len = newList.length;
                        for (i = 0; i < len; ++i)
                        {
                            if (newList[i])
                            {
                                elemsToAdd.push(newList[i])
                            }
                        }
                        if (elemsToRemove.length > 0)
                        {
                            canvas.removeFromSelection(elemsToRemove)
                        }
                        if (elemsToAdd.length > 0)
                        {
                            addToSelection(elemsToAdd)
                        }
                        break;
                    case"resize":
                        tlist = svgedit.transformlist.getTransformList(selected);
                        var hasMatrix = svgedit.math.hasMatrixTransform(tlist);
                        box = hasMatrix ? init_bbox : svgedit.utilities.getBBox(selected);
                        var left = box.x,
                            top = box.y,
                            width = box.width,
                            height = box.height;
                        dx = (x - start_x);
                        dy = (y - start_y);
                        if (curConfig.gridSnapping)
                        {
                            dx = svgedit.utilities.snapToGrid(dx);
                            dy = svgedit.utilities.snapToGrid(dy);
                            height = svgedit.utilities.snapToGrid(height);
                            width = svgedit.utilities.snapToGrid(width)
                        }
                        angle = svgedit.utilities.getRotationAngle(selected);
                        if (angle)
                        {
                            var r = Math.sqrt(dx * dx + dy * dy),
                                theta = Math.atan2(dy, dx) - angle * Math.PI / 180.0;
                            dx = r * Math.cos(theta);
                            dy = r * Math.sin(theta)
                        }
                        if (current_resize_mode.indexOf("n") == -1 && current_resize_mode.indexOf("s") == -1)
                        {
                            dy = 0
                        }
                        if (current_resize_mode.indexOf("e") == -1 && current_resize_mode.indexOf("w") == -1)
                        {
                            dx = 0
                        }
                        var ts = null,
                            tx = 0,
                            ty = 0,
                            sy = height ? (height + dy) / height : 1,
                            sx = width ? (width + dx) / width : 1;
                        if (current_resize_mode.indexOf("n") >= 0)
                        {
                            sy = height ? (height - dy) / height : 1;
                            ty = height
                        }
                        if (current_resize_mode.indexOf("w") >= 0)
                        {
                            sx = width ? (width - dx) / width : 1;
                            tx = width
                        }
                        var translateOrigin = svgroot.createSVGTransform(),
                            scale = svgroot.createSVGTransform(),
                            translateBack = svgroot.createSVGTransform();
                        if (curConfig.gridSnapping)
                        {
                            left = svgedit.utilities.snapToGrid(left);
                            tx = svgedit.utilities.snapToGrid(tx);
                            top = svgedit.utilities.snapToGrid(top);
                            ty = svgedit.utilities.snapToGrid(ty)
                        }
                        translateOrigin.setTranslate(-(left + tx), -(top + ty));
                        if (evt.shiftKey)
                        {
                            if (sx == 1)
                            {
                                sx = sy
                            }
                            else
                            {
                                sy = sx
                            }
                        }
                        scale.setScale(sx, sy);
                        translateBack.setTranslate(left + tx, top + ty);
                        if (hasMatrix)
                        {
                            var diff = angle ? 1 : 0;
                            tlist.replaceItem(translateOrigin, 2 + diff);
                            tlist.replaceItem(scale, 1 + diff);
                            tlist.replaceItem(translateBack, Number(diff))
                        }
                        else
                        {
                            var N = tlist.numberOfItems;
                            tlist.replaceItem(translateBack, N - 3);
                            tlist.replaceItem(scale, N - 2);
                            tlist.replaceItem(translateOrigin, N - 1)
                        }
                        selectorManager.requestSelector(selected).resize();
                        call("transition", selectedElements);
                        break;
                    case"zoom":
                        real_x *= current_zoom;
                        real_y *= current_zoom;
                        svgedit.utilities.assignAttributes(rubberBox, {
                            x: Math.min(r_start_x * current_zoom, real_x), y: Math.min(r_start_y * current_zoom, real_y), width: Math.abs(real_x - r_start_x * current_zoom), height: Math.abs(real_y - r_start_y * current_zoom)
                        }, 100);
                        break;
                    case"text":
                        svgedit.utilities.assignAttributes(shape, {
                            x: x, y: y
                        }, 1000);
                        break;
                    case"line":
                        var handle = null;
                        if (!window.opera)
                        {
                            svgroot.suspendRedraw(1000)
                        }
                        if (curConfig.gridSnapping)
                        {
                            x = svgedit.utilities.snapToGrid(x);
                            y = svgedit.utilities.snapToGrid(y)
                        }
                        var x2 = x;
                        var y2 = y;
                        if (evt.shiftKey)
                        {
                            xya = svgedit.math.snapToAngle(start_x, start_y, x2, y2);
                            x2 = xya.x;
                            y2 = xya.y
                        }
                        shape.setAttributeNS(null, "x2", x2);
                        shape.setAttributeNS(null, "y2", y2);
                        if (!window.opera)
                        {
                            svgroot.unsuspendRedraw(handle)
                        }
                        break;
                    case"foreignObject":
                    case"square":
                    case"rect":
                    case"image":
                        var square = (current_mode == 'square') || evt.shiftKey,
                            w = Math.abs(x - start_x),
                            h = Math.abs(y - start_y),
                            new_x,
                            new_y;
                        if (square)
                        {
                            w = h = Math.max(w, h);
                            new_x = start_x < x ? start_x : start_x - w;
                            new_y = start_y < y ? start_y : start_y - h
                        }
                        else
                        {
                            new_x = Math.min(start_x, x);
                            new_y = Math.min(start_y, y)
                        }
                        if (curConfig.gridSnapping)
                        {
                            w = svgedit.utilities.snapToGrid(w);
                            h = svgedit.utilities.snapToGrid(h);
                            new_x = svgedit.utilities.snapToGrid(new_x);
                            new_y = svgedit.utilities.snapToGrid(new_y)
                        }
                        svgedit.utilities.assignAttributes(shape, {
                            width: w, height: h, x: new_x, y: new_y
                        }, 1000);
                        break;
                    case"circle":
                        c = $(shape).attr(["cx", "cy"]);
                        cx = c.cx;
                        cy = c.cy;
                        var rad = Math.sqrt((x - cx) * (x - cx) + (y - cy) * (y - cy));
                        if (curConfig.gridSnapping)
                        {
                            rad = svgedit.utilities.snapToGrid(rad)
                        }
                        shape.setAttributeNS(null, "r", rad);
                        break;
                    case"ellipse":
                        c = $(shape).attr(["cx", "cy"]);
                        cx = c.cx;
                        cy = c.cy;
                        handle = null;
                        if (!window.opera)
                        {
                            svgroot.suspendRedraw(1000)
                        }
                        if (curConfig.gridSnapping)
                        {
                            x = svgedit.utilities.snapToGrid(x);
                            cx = svgedit.utilities.snapToGrid(cx);
                            y = svgedit.utilities.snapToGrid(y);
                            cy = svgedit.utilities.snapToGrid(cy)
                        }
                        shape.setAttributeNS(null, "rx", Math.abs(x - cx));
                        var ry = Math.abs(evt.shiftKey ? (x - cx) : (y - cy));
                        shape.setAttributeNS(null, "ry", ry);
                        if (!window.opera)
                        {
                            svgroot.unsuspendRedraw(handle)
                        }
                        break;
                    case"fhellipse":
                    case"fhrect":
                        freehand.minx = Math.min(real_x, freehand.minx);
                        freehand.maxx = Math.max(real_x, freehand.maxx);
                        freehand.miny = Math.min(real_y, freehand.miny);
                        freehand.maxy = Math.max(real_y, freehand.maxy);
                    case"fhpath":
                        end.x = real_x;
                        end.y = real_y;
                        if (controllPoint2.x && controllPoint2.y)
                        {
                            for (i = 0; i < STEP_COUNT - 1; i++)
                            {
                                parameter = i / STEP_COUNT;
                                nextParameter = (i + 1) / STEP_COUNT;
                                bSpline = getBsplinePoint(nextParameter);
                                nextPos = bSpline;
                                bSpline = getBsplinePoint(parameter);
                                sumDistance += Math.sqrt((nextPos.x - bSpline.x) * (nextPos.x - bSpline.x) + (nextPos.y - bSpline.y) * (nextPos.y - bSpline.y));
                                if (sumDistance > THRESHOLD_DIST)
                                {
                                    d_attr += +bSpline.x + "," + bSpline.y + " ";
                                    shape.setAttributeNS(null, "points", d_attr);
                                    sumDistance -= THRESHOLD_DIST
                                }
                            }
                        }
                        controllPoint2 = {
                            x: controllPoint1.x, y: controllPoint1.y
                        };
                        controllPoint1 = {
                            x: start.x, y: start.y
                        };
                        start = {
                            x: end.x, y: end.y
                        };
                        break;
                    case"path":
                    case"pathedit":
                        x *= current_zoom;
                        y *= current_zoom;
                        if (curConfig.gridSnapping)
                        {
                            x = svgedit.utilities.snapToGrid(x);
                            y = svgedit.utilities.snapToGrid(y);
                            start_x = svgedit.utilities.snapToGrid(start_x);
                            start_y = svgedit.utilities.snapToGrid(start_y)
                        }
                        if (evt.shiftKey)
                        {
                            var path = svgedit.path.path;
                            var x1,
                                y1;
                            if (path)
                            {
                                x1 = path.dragging ? path.dragging[0] : start_x;
                                y1 = path.dragging ? path.dragging[1] : start_y
                            }
                            else
                            {
                                x1 = start_x;
                                y1 = start_y
                            }
                            xya = svgedit.math.snapToAngle(x1, y1, x, y);
                            x = xya.x;
                            y = xya.y
                        }
                        if (rubberBox && rubberBox.getAttribute('display') !== 'none')
                        {
                            real_x *= current_zoom;
                            real_y *= current_zoom;
                            svgedit.utilities.assignAttributes(rubberBox, {
                                x: Math.min(r_start_x * current_zoom, real_x), y: Math.min(r_start_y * current_zoom, real_y), width: Math.abs(real_x - r_start_x * current_zoom), height: Math.abs(real_y - r_start_y * current_zoom)
                            }, 100)
                        }
                        pathActions.mouseMove(x, y);
                        break;
                    case"textedit":
                        x *= current_zoom;
                        y *= current_zoom;
                        textActions.mouseMove(mouse_x, mouse_y);
                        break;
                    case"rotate":
                        box = svgedit.utilities.getBBox(selected);
                        cx = box.x + box.width / 2;
                        cy = box.y + box.height / 2;
                        var m = svgedit.math.getMatrix(selected),
                            center = svgedit.math.transformPoint(cx, cy, m);
                        cx = center.x;
                        cy = center.y;
                        angle = ((Math.atan2(cy - y, cx - x) * (180 / Math.PI)) - 90) % 360;
                        if (curConfig.gridSnapping)
                        {
                            angle = svgedit.utilities.snapToGrid(angle)
                        }
                        if (evt.shiftKey)
                        {
                            var snap = 45;
                            angle = Math.round(angle / snap) * snap
                        }
                        canvas.setRotationAngle(angle < -180 ? (360 + angle) : angle, true);
                        call("transition", selectedElements);
                        break;
                    default:
                        break
                }
                runExtensions("mouseMove", {
                    event: evt, mouse_x: mouse_x, mouse_y: mouse_y, selected: selected
                })
            };
        var mouseUp = function(evt)
            {
                if (evt.button === 2)
                {
                    return
                }
                var tempJustSelected = justSelected;
                justSelected = null;
                if (!started)
                {
                    return
                }
                var pt = svgedit.math.transformPoint(evt.pageX, evt.pageY, root_sctm),
                    mouse_x = pt.x * current_zoom - $('body').scrollLeft(),
                    mouse_y = pt.y * current_zoom - $('body').scrollTop(),
                    x = mouse_x / current_zoom,
                    y = mouse_y / current_zoom,
                    element = svgedit.utilities.getElem(getId()),
                    keep = false;
                var real_x = x;
                var real_y = y;
                var useUnit = false;
                started = false;
                var attrs,
                    t;
                switch (current_mode)
                {
                    case"resize":
                    case"multiselect":
                        if (rubberBox != null)
                        {
                            rubberBox.setAttribute("display", "none");
                            curBBoxes = []
                        }
                        current_mode = "select";
                    case"select":
                        if (selectedElements[0] != null)
                        {
                            if (selectedElements[1] == null)
                            {
                                var selected = selectedElements[0];
                                switch (selected.tagName)
                                {
                                    case"g":
                                    case"use":
                                    case"image":
                                    case"foreignObject":
                                        break;
                                    default:
                                        cur_properties.fill = selected.getAttribute("fill");
                                        cur_properties.fill_opacity = selected.getAttribute("fill-opacity");
                                        cur_properties.stroke = selected.getAttribute("stroke");
                                        cur_properties.stroke_opacity = selected.getAttribute("stroke-opacity");
                                        cur_properties.stroke_width = selected.getAttribute("stroke-width");
                                        cur_properties.stroke_dasharray = selected.getAttribute("stroke-dasharray");
                                        cur_properties.stroke_linejoin = selected.getAttribute("stroke-linejoin");
                                        cur_properties.stroke_linecap = selected.getAttribute("stroke-linecap")
                                }
                                if (selected.tagName == "text")
                                {
                                    cur_text.font_size = selected.getAttribute("font-size");
                                    cur_text.font_family = selected.getAttribute("font-family")
                                }
                                selectorManager.requestSelector(selected).showGrips(true)
                            }
                            recalculateAllSelectedDimensions();
                            if (real_x != r_start_x || real_y != r_start_y)
                            {
                                var i,
                                    len = selectedElements.length;
                                for (i = 0; i < len; ++i)
                                {
                                    if (selectedElements[i] == null)
                                    {
                                        break
                                    }
                                    if (!selectedElements[i].firstChild)
                                    {
                                        selectorManager.requestSelector(selectedElements[i]).resize()
                                    }
                                }
                            }
                            else
                            {
                                t = evt.target;
                                if (selectedElements[0].nodeName === "path" && selectedElements[1] == null)
                                {
                                    pathActions.select(selectedElements[0])
                                }
                                else if (evt.shiftKey)
                                {
                                    if (tempJustSelected != t)
                                    {
                                        canvas.removeFromSelection([t])
                                    }
                                }
                            }
                            if (svgedit.browser.supportsNonScalingStroke())
                            {
                                var elem = selectedElements[0];
                                if (elem)
                                {
                                    elem.removeAttribute('style');
                                    svgedit.utilities.walkTree(elem, function(elem)
                                    {
                                        elem.removeAttribute('style')
                                    })
                                }
                            }
                        }
                        return;
                    case"zoom":
                        if (rubberBox != null)
                        {
                            rubberBox.setAttribute("display", "none")
                        }
                        var factor = evt.shiftKey ? 0.5 : 2;
                        call("zoomed", {
                            x: Math.min(r_start_x, real_x), y: Math.min(r_start_y, real_y), width: Math.abs(real_x - r_start_x), height: Math.abs(real_y - r_start_y), factor: factor
                        });
                        return;
                    case"fhpath":
                        sumDistance = 0;
                        controllPoint2 = {
                            x: 0, y: 0
                        };
                        controllPoint1 = {
                            x: 0, y: 0
                        };
                        start = {
                            x: 0, y: 0
                        };
                        end = {
                            x: 0, y: 0
                        };
                        var coords = element.getAttribute('points');
                        var commaIndex = coords.indexOf(',');
                        if (commaIndex >= 0)
                        {
                            keep = coords.indexOf(',', commaIndex + 1) >= 0
                        }
                        else
                        {
                            keep = coords.indexOf(' ', coords.indexOf(' ') + 1) >= 0
                        }
                        if (keep)
                        {
                            element = pathActions.smoothPolylineIntoPath(element)
                        }
                        break;
                    case"line":
                        attrs = $(element).attr(["x1", "x2", "y1", "y2"]);
                        keep = (attrs.x1 != attrs.x2 || attrs.y1 != attrs.y2);
                        break;
                    case"foreignObject":
                    case"square":
                    case"rect":
                    case"image":
                        attrs = $(element).attr(["width", "height"]);
                        keep = (attrs.width != 0 || attrs.height != 0) || current_mode === "image";
                        break;
                    case"circle":
                        keep = (element.getAttribute('r') != 0);
                        break;
                    case"ellipse":
                        attrs = $(element).attr(["rx", "ry"]);
                        keep = (attrs.rx != null || attrs.ry != null);
                        break;
                    case"fhellipse":
                        if ((freehand.maxx - freehand.minx) > 0 && (freehand.maxy - freehand.miny) > 0)
                        {
                            element = addSvgElementFromJson({
                                element: "ellipse", curStyles: true, attr: {
                                        cx: (freehand.minx + freehand.maxx) / 2, cy: (freehand.miny + freehand.maxy) / 2, rx: (freehand.maxx - freehand.minx) / 2, ry: (freehand.maxy - freehand.miny) / 2, id: getId()
                                    }
                            });
                            call("changed", [element]);
                            keep = true
                        }
                        break;
                    case"fhrect":
                        if ((freehand.maxx - freehand.minx) > 0 && (freehand.maxy - freehand.miny) > 0)
                        {
                            element = addSvgElementFromJson({
                                element: "rect", curStyles: true, attr: {
                                        x: freehand.minx, y: freehand.miny, width: (freehand.maxx - freehand.minx), height: (freehand.maxy - freehand.miny), id: getId()
                                    }
                            });
                            call("changed", [element]);
                            keep = true
                        }
                        break;
                    case"text":
                        keep = true;
                        selectOnly([element]);
                        textActions.start(element);
                        break;
                    case"path":
                        element = null;
                        started = true;
                        var res = pathActions.mouseUp(evt, element, mouse_x, mouse_y);
                        element = res.element;
                        keep = res.keep;
                        break;
                    case"pathedit":
                        keep = true;
                        element = null;
                        pathActions.mouseUp(evt);
                        break;
                    case"textedit":
                        keep = false;
                        element = null;
                        textActions.mouseUp(evt, mouse_x, mouse_y);
                        break;
                    case"rotate":
                        keep = true;
                        element = null;
                        current_mode = "select";
                        var batchCmd = canvas.undoMgr.finishUndoableChange();
                        if (!batchCmd.isEmpty())
                        {
                            addCommandToHistory(batchCmd)
                        }
                        recalculateAllSelectedDimensions();
                        call("changed", selectedElements);
                        break;
                    default:
                        break
                }
                var ext_result = runExtensions("mouseUp", {
                        event: evt, mouse_x: mouse_x, mouse_y: mouse_y
                    }, true);
                $.each(ext_result, function(i, r)
                {
                    if (r)
                    {
                        keep = r.keep || keep;
                        element = r.element;
                        started = r.started || started
                    }
                });
                if (!keep && element != null)
                {
                    getCurrentDrawing().releaseId(getId());
                    element.parentNode.removeChild(element);
                    element = null;
                    t = evt.target;
                    while (t.parentNode.parentNode.tagName == "g")
                    {
                        t = t.parentNode
                    }
                    if ((current_mode != "path" || !drawn_path) && t.parentNode.id != "selectorParentGroup" && t.id != "svgcanvas" && t.id != "svgroot")
                    {
                        canvas.setMode("select");
                        selectOnly([t], true)
                    }
                }
                else if (element != null)
                {
                    canvas.addedNew = true;
                    if (useUnit)
                    {
                        svgedit.units.convertAttrs(element)
                    }
                    var ani_dur = 0.2,
                        c_ani;
                    if (opac_ani.beginElement && element.getAttribute('opacity') != cur_shape.opacity)
                    {
                        c_ani = $(opac_ani).clone().attr({
                            to: cur_shape.opacity, dur: ani_dur
                        }).appendTo(element);
                        try
                        {
                            c_ani[0].beginElement()
                        }
                        catch(e) {}
                    }
                    else
                    {
                        ani_dur = 0
                    }
                    setTimeout(function()
                    {
                        if (c_ani)
                        {
                            c_ani.remove()
                        }
                        element.setAttribute("opacity", cur_shape.opacity);
                        element.setAttribute("style", "pointer-events:inherit");
                        cleanupElement(element);
                        if (current_mode === "path")
                        {
                            pathActions.toEditMode(element)
                        }
                        else if (curConfig.selectNew)
                        {
                            selectOnly([element], true)
                        }
                        addCommandToHistory(new svgedit.history.InsertElementCommand(element));
                        call("changed", [element])
                    }, ani_dur * 1000)
                }
                startTransform = null
            };
        var dblClick = function(evt)
            {
                var evt_target = evt.target;
                var parent = evt_target.parentNode;
                if (parent === current_group)
                {
                    return
                }
                var mouse_target = getMouseTarget(evt);
                var tagName = mouse_target.tagName;
                if (tagName === 'text' && current_mode !== 'textedit')
                {
                    var pt = svgedit.math.transformPoint(evt.pageX, evt.pageY, root_sctm);
                    textActions.select(mouse_target, pt.x, pt.y)
                }
                if ((tagName === "g" || tagName === "a") && svgedit.utilities.getRotationAngle(mouse_target))
                {
                    pushGroupProperties(mouse_target);
                    mouse_target = selectedElements[0];
                    clearSelection(true)
                }
                if (current_group)
                {
                    leaveContext()
                }
                if ((parent.tagName !== 'g' && parent.tagName !== 'a') || parent === getCurrentDrawing().getCurrentLayer() || mouse_target === selectorManager.selectorParentGroup)
                {
                    return
                }
                setContext(mouse_target)
            };
        var handleLinkInCanvas = function(e)
            {
                e.preventDefault();
                return false
            };
        $(container).mousedown(mouseDown).mousemove(mouseMove).click(handleLinkInCanvas).dblclick(dblClick).mouseup(mouseUp);
        $(container).bind("mousewheel DOMMouseScroll", function(e)
        {
            e.preventDefault();
            var evt = e.originalEvent;
            root_sctm = $('#svgcontent g')[0].getScreenCTM().inverse();
            var pt = svgedit.math.transformPoint(evt.pageX, evt.pageY, root_sctm);
            var bbox = {
                    x: pt.x, y: pt.y, width: 0, height: 0
                };
            var delta = (evt.wheelDelta) ? evt.wheelDelta : (evt.detail) ? -evt.detail : 0;
            if (!delta)
            {
                return
            }
            bbox.factor = Math.max(3 / 4, Math.min(4 / 3, (delta)));
            call("zoomed", bbox)
        })
    }());
    var preventClickDefault = function(img)
        {
            $(img).click(function(e)
            {
                e.preventDefault()
            })
        };
    textActions = canvas.textActions = (function()
    {
        var curtext;
        var textinput;
        var cursor;
        var selblock;
        var blinker;
        var chardata = [];
        var textbb,
            transbb;
        var matrix;
        var last_x,
            last_y;
        var allow_dbl;
        function setCursor(index)
        {
            var empty = (textinput.value === "");
            $(textinput).focus();
            if (!arguments.length)
            {
                if (empty)
                {
                    index = 0
                }
                else
                {
                    if (textinput.selectionEnd !== textinput.selectionStart)
                    {
                        return
                    }
                    index = textinput.selectionEnd
                }
            }
            var charbb;
            charbb = chardata[index];
            if (!empty)
            {
                textinput.setSelectionRange(index, index)
            }
            cursor = svgedit.utilities.getElem("text_cursor");
            if (!cursor)
            {
                cursor = document.createElementNS(NS.SVG, "line");
                svgedit.utilities.assignAttributes(cursor, {
                    id: "text_cursor", stroke: "#333", 'stroke-width': 1
                });
                cursor = svgedit.utilities.getElem("selectorParentGroup").appendChild(cursor)
            }
            if (!blinker)
            {
                blinker = setInterval(function()
                {
                    var show = (cursor.getAttribute('display') === 'none');
                    cursor.setAttribute('display', show ? 'inline' : 'none')
                }, 600)
            }
            var start_pt = ptToScreen(charbb.x, textbb.y);
            var end_pt = ptToScreen(charbb.x, (textbb.y + textbb.height));
            svgedit.utilities.assignAttributes(cursor, {
                x1: start_pt.x, y1: start_pt.y, x2: end_pt.x, y2: end_pt.y, visibility: 'visible', display: 'inline'
            });
            if (selblock)
            {
                selblock.setAttribute('d', '')
            }
        }
        function setSelection(start, end, skipInput)
        {
            if (start === end)
            {
                setCursor(end);
                return
            }
            if (!skipInput)
            {
                textinput.setSelectionRange(start, end)
            }
            selblock = svgedit.utilities.getElem("text_selectblock");
            if (!selblock)
            {
                selblock = document.createElementNS(NS.SVG, "path");
                svgedit.utilities.assignAttributes(selblock, {
                    id: "text_selectblock", fill: "green", opacity: 0.5, style: "pointer-events:none"
                });
                svgedit.utilities.getElem("selectorParentGroup").appendChild(selblock)
            }
            var startbb = chardata[start];
            var endbb = chardata[end];
            cursor.setAttribute('visibility', 'hidden');
            var tl = ptToScreen(startbb.x, textbb.y),
                tr = ptToScreen(startbb.x + (endbb.x - startbb.x), textbb.y),
                bl = ptToScreen(startbb.x, textbb.y + textbb.height),
                br = ptToScreen(startbb.x + (endbb.x - startbb.x), textbb.y + textbb.height);
            var dstr = "M" + tl.x + "," + tl.y + " L" + tr.x + "," + tr.y + " " + br.x + "," + br.y + " " + bl.x + "," + bl.y + "z";
            svgedit.utilities.assignAttributes(selblock, {
                d: dstr, display: 'inline'
            })
        }
        function getIndexFromPoint(mouse_x, mouse_y)
        {
            var pt = svgroot.createSVGPoint();
            pt.x = mouse_x;
            pt.y = mouse_y;
            if (chardata.length == 1)
            {
                return 0
            }
            var charpos = curtext.getCharNumAtPosition(pt);
            if (charpos < 0)
            {
                charpos = chardata.length - 2;
                if (mouse_x <= chardata[0].x)
                {
                    charpos = 0
                }
            }
            else if (charpos >= chardata.length - 2)
            {
                charpos = chardata.length - 2
            }
            var charbb = chardata[charpos];
            var mid = charbb.x + (charbb.width / 2);
            if (mouse_x > mid)
            {
                charpos++
            }
            return charpos
        }
        function setCursorFromPoint(mouse_x, mouse_y)
        {
            setCursor(getIndexFromPoint(mouse_x, mouse_y))
        }
        function setEndSelectionFromPoint(x, y, apply)
        {
            var i1 = textinput.selectionStart;
            var i2 = getIndexFromPoint(x, y);
            var start = Math.min(i1, i2);
            var end = Math.max(i1, i2);
            setSelection(start, end, !apply)
        }
        function screenToPt(x_in, y_in)
        {
            var out = {
                    x: x_in, y: y_in
                };
            out.x /= current_zoom;
            out.y /= current_zoom;
            if (matrix)
            {
                var pt = svgedit.math.transformPoint(out.x, out.y, matrix.inverse());
                out.x = pt.x;
                out.y = pt.y
            }
            return out
        }
        function ptToScreen(x_in, y_in)
        {
            var out = {
                    x: x_in, y: y_in
                };
            if (matrix)
            {
                var pt = svgedit.math.transformPoint(out.x, out.y, matrix);
                out.x = pt.x;
                out.y = pt.y
            }
            out.x *= current_zoom;
            out.y *= current_zoom;
            return out
        }
        function hideCursor()
        {
            if (cursor)
            {
                cursor.setAttribute('visibility', 'hidden')
            }
        }
        function selectAll(evt)
        {
            setSelection(0, curtext.textContent.length);
            $(this).unbind(evt)
        }
        function selectWord(evt)
        {
            if (!allow_dbl || !curtext)
            {
                return
            }
            var ept = svgedit.math.transformPoint(evt.pageX, evt.pageY, root_sctm),
                mouse_x = ept.x * current_zoom,
                mouse_y = ept.y * current_zoom;
            var pt = screenToPt(mouse_x, mouse_y);
            var index = getIndexFromPoint(pt.x, pt.y);
            var str = curtext.textContent;
            var first = str.substr(0, index).replace(/[a-z0-9]+$/i, '').length;
            var m = str.substr(index).match(/^[a-z0-9]+/i);
            var last = (m ? m[0].length : 0) + index;
            setSelection(first, last);
            $(evt.target).click(selectAll);
            setTimeout(function()
            {
                $(evt.target).unbind('click', selectAll)
            }, 300)
        }
        return {
                select: function(target, x, y)
                {
                    curtext = target;
                    textActions.toEditMode(x, y)
                }, start: function(elem)
                    {
                        curtext = elem;
                        textActions.toEditMode()
                    }, mouseDown: function(evt, mouse_target, start_x, start_y)
                    {
                        var pt = screenToPt(start_x, start_y);
                        textinput.focus();
                        setCursorFromPoint(pt.x, pt.y);
                        last_x = start_x;
                        last_y = start_y
                    }, mouseMove: function(mouse_x, mouse_y)
                    {
                        var pt = screenToPt(mouse_x, mouse_y);
                        setEndSelectionFromPoint(pt.x, pt.y)
                    }, mouseUp: function(evt, mouse_x, mouse_y)
                    {
                        var pt = screenToPt(mouse_x, mouse_y);
                        setEndSelectionFromPoint(pt.x, pt.y, true);
                        if (evt.target !== curtext && mouse_x < last_x + 2 && mouse_x > last_x - 2 && mouse_y < last_y + 2 && mouse_y > last_y - 2)
                        {
                            textActions.toSelectMode(true)
                        }
                    }, setCursor: setCursor, toEditMode: function(x, y)
                    {
                        allow_dbl = false;
                        current_mode = "textedit";
                        selectorManager.requestSelector(curtext).showGrips(false);
                        var sel = selectorManager.requestSelector(curtext).selectorRect;
                        textActions.init();
                        $(curtext).css('cursor', 'text');
                        if (!arguments.length)
                        {
                            setCursor()
                        }
                        else
                        {
                            var pt = screenToPt(x, y);
                            setCursorFromPoint(pt.x, pt.y)
                        }
                        setTimeout(function()
                        {
                            allow_dbl = true
                        }, 300)
                    }, toSelectMode: function(selectElem)
                    {
                        current_mode = "select";
                        clearInterval(blinker);
                        blinker = null;
                        if (selblock)
                        {
                            $(selblock).attr('display', 'none')
                        }
                        if (cursor)
                        {
                            $(cursor).attr('visibility', 'hidden')
                        }
                        $(curtext).css('cursor', 'move');
                        if (selectElem)
                        {
                            clearSelection();
                            $(curtext).css('cursor', 'move');
                            call("selected", [curtext]);
                            addToSelection([curtext], true)
                        }
                        if (curtext && !curtext.textContent.length)
                        {
                            canvas.deleteSelectedElements()
                        }
                        $(textinput).blur();
                        curtext = false
                    }, setInputElem: function(elem)
                    {
                        textinput = elem
                    }, clear: function()
                    {
                        if (current_mode == "textedit")
                        {
                            textActions.toSelectMode()
                        }
                    }, init: function(inputElem)
                    {
                        if (!curtext)
                        {
                            return
                        }
                        var i,
                            end;
                        if (!curtext.parentNode)
                        {
                            curtext = selectedElements[0];
                            selectorManager.requestSelector(curtext).showGrips(false)
                        }
                        var str = curtext.textContent;
                        var len = str.length;
                        var xform = curtext.getAttribute('transform');
                        textbb = svgedit.utilities.getBBox(curtext);
                        matrix = xform ? svgedit.math.getMatrix(curtext) : null;
                        chardata = new Array(len);
                        textinput.focus();
                        $(curtext).unbind('dblclick', selectWord).dblclick(selectWord);
                        if (!len)
                        {
                            end = {
                                x: textbb.x + (textbb.width / 2), width: 0
                            }
                        }
                        for (i = 0; i < len; i++)
                        {
                            var start = curtext.getStartPositionOfChar(i);
                            end = curtext.getEndPositionOfChar(i);
                            if (!svgedit.browser.supportsGoodTextCharPos())
                            {
                                var offset = canvas.contentW * current_zoom;
                                start.x -= offset;
                                end.x -= offset;
                                start.x /= current_zoom;
                                end.x /= current_zoom
                            }
                            chardata[i] = {
                                x: start.x, y: textbb.y, width: end.x - start.x, height: textbb.height
                            }
                        }
                        chardata.push({
                            x: end.x, width: 0
                        });
                        setSelection(textinput.selectionStart, textinput.selectionEnd, true)
                    }
            }
    }());
    pathActions = canvas.pathActions = function()
    {
        var subpath = false;
        var current_path;
        var newPoint,
            firstCtrl;
        function resetD(p)
        {
            p.setAttribute("d", pathActions.convertPath(p))
        }
        svgedit.path.Path.prototype.endChanges = function(text)
        {
            if (svgedit.browser.isWebkit())
            {
                resetD(this.elem)
            }
            var cmd = new svgedit.history.ChangeElementCommand(this.elem, {d: this.last_d}, text);
            addCommandToHistory(cmd);
            call("changed", [this.elem])
        };
        svgedit.path.Path.prototype.addPtsToSelection = function(indexes)
        {
            var i,
                seg;
            if (!$.isArray(indexes))
            {
                indexes = [indexes]
            }
            for (i = 0; i < indexes.length; i++)
            {
                var index = indexes[i];
                seg = this.segs[index];
                if (seg.ptgrip)
                {
                    if (this.selected_pts.indexOf(index) == -1 && index >= 0)
                    {
                        this.selected_pts.push(index)
                    }
                }
            }
            this.selected_pts.sort();
            i = this.selected_pts.length;
            var grips = new Array(i);
            while (i--)
            {
                var pt = this.selected_pts[i];
                seg = this.segs[pt];
                seg.select(true);
                grips[i] = seg.ptgrip
            }
            pathActions.canDeleteNodes = true;
            pathActions.closed_subpath = this.subpathIsClosed(this.selected_pts[0]);
            call("selected", grips)
        };
        current_path = null;
        var drawn_path = null,
            hasMoved = false;
        var smoothPolylineIntoPath = function(element)
            {
                var i,
                    points = element.points;
                var N = points.numberOfItems;
                if (N >= 4)
                {
                    var curpos = points.getItem(0),
                        prevCtlPt = null;
                    var d = [];
                    d.push(["M", curpos.x, ",", curpos.y, " C"].join(""));
                    for (i = 1; i <= (N - 4); i += 3)
                    {
                        var ct1 = points.getItem(i);
                        var ct2 = points.getItem(i + 1);
                        var end = points.getItem(i + 2);
                        if (prevCtlPt)
                        {
                            var newpts = svgedit.path.smoothControlPoints(prevCtlPt, ct1, curpos);
                            if (newpts && newpts.length == 2)
                            {
                                var prevArr = d[d.length - 1].split(',');
                                prevArr[2] = newpts[0].x;
                                prevArr[3] = newpts[0].y;
                                d[d.length - 1] = prevArr.join(',');
                                ct1 = newpts[1]
                            }
                        }
                        d.push([ct1.x, ct1.y, ct2.x, ct2.y, end.x, end.y].join(','));
                        curpos = end;
                        prevCtlPt = ct2
                    }
                    d.push("L");
                    while (i < N)
                    {
                        var pt = points.getItem(i);
                        d.push([pt.x, pt.y].join(","));
                        i++
                    }
                    d = d.join(" ");
                    element = addSvgElementFromJson({
                        element: "path", curStyles: true, attr: {
                                id: getId(), d: d, fill: "none"
                            }
                    })
                }
                return element
            };
        return {
                mouseDown: function(evt, mouse_target, start_x, start_y)
                {
                    var id;
                    if (current_mode === "path")
                    {
                        mouse_x = start_x;
                        mouse_y = start_y;
                        var x = mouse_x / current_zoom,
                            y = mouse_y / current_zoom,
                            stretchy = svgedit.utilities.getElem("path_stretch_line");
                        newPoint = [x, y];
                        if (curConfig.gridSnapping)
                        {
                            x = svgedit.utilities.snapToGrid(x);
                            y = svgedit.utilities.snapToGrid(y);
                            mouse_x = svgedit.utilities.snapToGrid(mouse_x);
                            mouse_y = svgedit.utilities.snapToGrid(mouse_y)
                        }
                        if (!stretchy)
                        {
                            stretchy = document.createElementNS(NS.SVG, "path");
                            svgedit.utilities.assignAttributes(stretchy, {
                                id: "path_stretch_line", stroke: "#22C", 'stroke-width': "0.5", fill: 'none'
                            });
                            stretchy = svgedit.utilities.getElem("selectorParentGroup").appendChild(stretchy)
                        }
                        stretchy.setAttribute("display", "inline");
                        var keep = null;
                        var index;
                        if (!drawn_path)
                        {
                            d_attr = "M" + x + "," + y + " ";
                            drawn_path = addSvgElementFromJson({
                                element: "path", curStyles: true, attr: {
                                        d: d_attr, id: getNextId(), opacity: cur_shape.opacity / 2
                                    }
                            });
                            stretchy.setAttribute('d', ['M', mouse_x, mouse_y, mouse_x, mouse_y].join(' '));
                            index = subpath ? svgedit.path.path.segs.length : 0;
                            svgedit.path.addPointGrip(index, mouse_x, mouse_y)
                        }
                        else
                        {
                            var seglist = drawn_path.pathSegList;
                            var i = seglist.numberOfItems;
                            var FUZZ = 6 / current_zoom;
                            var clickOnPoint = false;
                            while (i)
                            {
                                i--;
                                var item = seglist.getItem(i);
                                var px = item.x,
                                    py = item.y;
                                if (x >= (px - FUZZ) && x <= (px + FUZZ) && y >= (py - FUZZ) && y <= (py + FUZZ))
                                {
                                    clickOnPoint = true;
                                    break
                                }
                            }
                            id = getId();
                            svgedit.path.removePath_(id);
                            var newpath = svgedit.utilities.getElem(id);
                            var newseg;
                            var s_seg;
                            var len = seglist.numberOfItems;
                            if (clickOnPoint)
                            {
                                if (i <= 1 && len >= 2)
                                {
                                    var abs_x = seglist.getItem(0).x;
                                    var abs_y = seglist.getItem(0).y;
                                    s_seg = stretchy.pathSegList.getItem(1);
                                    if (s_seg.pathSegType === 4)
                                    {
                                        newseg = drawn_path.createSVGPathSegLinetoAbs(abs_x, abs_y)
                                    }
                                    else
                                    {
                                        newseg = drawn_path.createSVGPathSegCurvetoCubicAbs(abs_x, abs_y, s_seg.x1 / current_zoom, s_seg.y1 / current_zoom, abs_x, abs_y)
                                    }
                                    var endseg = drawn_path.createSVGPathSegClosePath();
                                    seglist.appendItem(newseg);
                                    seglist.appendItem(endseg)
                                }
                                else if (len < 3)
                                {
                                    keep = false;
                                    return keep
                                }
                                $(stretchy).remove();
                                element = newpath;
                                drawn_path = null;
                                started = false;
                                if (subpath)
                                {
                                    if (svgedit.path.path.matrix)
                                    {
                                        svgedit.coords.remapElement(newpath, {}, svgedit.path.path.matrix.inverse())
                                    }
                                    var new_d = newpath.getAttribute("d");
                                    var orig_d = $(svgedit.path.path.elem).attr("d");
                                    $(svgedit.path.path.elem).attr("d", orig_d + new_d);
                                    $(newpath).remove();
                                    if (svgedit.path.path.matrix)
                                    {
                                        svgedit.path.recalcRotatedPath()
                                    }
                                    svgedit.path.path.init();
                                    pathActions.toEditMode(svgedit.path.path.elem);
                                    svgedit.path.path.selectPt();
                                    return false
                                }
                            }
                            else
                            {
                                if (!$.contains(container, getMouseTarget(evt)))
                                {
                                    console.log("Clicked outside canvas");
                                    return false
                                }
                                var num = drawn_path.pathSegList.numberOfItems;
                                var last = drawn_path.pathSegList.getItem(num - 1);
                                var lastx = last.x,
                                    lasty = last.y;
                                if (evt.shiftKey)
                                {
                                    var xya = svgedit.math.snapToAngle(lastx, lasty, x, y);
                                    x = xya.x;
                                    y = xya.y
                                }
                                s_seg = stretchy.pathSegList.getItem(1);
                                if (s_seg.pathSegType === 4)
                                {
                                    newseg = drawn_path.createSVGPathSegLinetoAbs(round(x), round(y))
                                }
                                else
                                {
                                    newseg = drawn_path.createSVGPathSegCurvetoCubicAbs(round(x), round(y), s_seg.x1 / current_zoom, s_seg.y1 / current_zoom, s_seg.x2 / current_zoom, s_seg.y2 / current_zoom)
                                }
                                drawn_path.pathSegList.appendItem(newseg);
                                x *= current_zoom;
                                y *= current_zoom;
                                stretchy.setAttribute('d', ['M', x, y, x, y].join(' '));
                                index = num;
                                if (subpath)
                                {
                                    index += svgedit.path.path.segs.length
                                }
                                svgedit.path.addPointGrip(index, x, y)
                            }
                        }
                        return
                    }
                    if (!svgedit.path.path)
                    {
                        return
                    }
                    svgedit.path.path.storeD();
                    id = evt.target.id;
                    var cur_pt;
                    if (id.substr(0, 14) == "pathpointgrip_")
                    {
                        cur_pt = svgedit.path.path.cur_pt = parseInt(id.substr(14));
                        svgedit.path.path.dragging = [start_x, start_y];
                        var seg = svgedit.path.path.segs[cur_pt];
                        if (!evt.shiftKey)
                        {
                            if (svgedit.path.path.selected_pts.length <= 1 || !seg.selected)
                            {
                                svgedit.path.path.clearSelection()
                            }
                            svgedit.path.path.addPtsToSelection(cur_pt)
                        }
                        else if (seg.selected)
                        {
                            svgedit.path.path.removePtFromSelection(cur_pt)
                        }
                        else
                        {
                            svgedit.path.path.addPtsToSelection(cur_pt)
                        }
                    }
                    else if (id.indexOf("ctrlpointgrip_") == 0)
                    {
                        svgedit.path.path.dragging = [start_x, start_y];
                        var parts = id.split('_')[1].split('c');
                        cur_pt = Number(parts[0]);
                        var ctrl_num = Number(parts[1]);
                        svgedit.path.path.selectPt(cur_pt, ctrl_num)
                    }
                    if (!svgedit.path.path.dragging)
                    {
                        if (rubberBox == null)
                        {
                            rubberBox = selectorManager.getRubberBandBox()
                        }
                        svgedit.utilities.assignAttributes(rubberBox, {
                            x: start_x * current_zoom, y: start_y * current_zoom, width: 0, height: 0, display: 'inline'
                        }, 100)
                    }
                }, mouseMove: function(mouse_x, mouse_y)
                    {
                        hasMoved = true;
                        if (current_mode === "path")
                        {
                            if (!drawn_path)
                            {
                                return
                            }
                            var seglist = drawn_path.pathSegList;
                            var index = seglist.numberOfItems - 1;
                            if (newPoint)
                            {
                                var pointGrip1 = svgedit.path.addCtrlGrip('1c1');
                                var pointGrip2 = svgedit.path.addCtrlGrip('0c2');
                                pointGrip1.setAttribute('cx', mouse_x);
                                pointGrip1.setAttribute('cy', mouse_y);
                                pointGrip1.setAttribute('display', 'inline');
                                var pt_x = newPoint[0];
                                var pt_y = newPoint[1];
                                var seg = seglist.getItem(index);
                                var cur_x = mouse_x / current_zoom;
                                var cur_y = mouse_y / current_zoom;
                                var alt_x = (pt_x + (pt_x - cur_x));
                                var alt_y = (pt_y + (pt_y - cur_y));
                                pointGrip2.setAttribute('cx', alt_x * current_zoom);
                                pointGrip2.setAttribute('cy', alt_y * current_zoom);
                                pointGrip2.setAttribute('display', 'inline');
                                var ctrlLine = svgedit.path.getCtrlLine(1);
                                svgedit.utilities.assignAttributes(ctrlLine, {
                                    x1: mouse_x, y1: mouse_y, x2: alt_x * current_zoom, y2: alt_y * current_zoom, display: 'inline'
                                });
                                if (index === 0)
                                {
                                    firstCtrl = [mouse_x, mouse_y]
                                }
                                else
                                {
                                    var last = seglist.getItem(index - 1);
                                    var last_x = last.x;
                                    var last_y = last.y;
                                    if (last.pathSegType === 6)
                                    {
                                        last_x += (last_x - last.x2);
                                        last_y += (last_y - last.y2)
                                    }
                                    else if (firstCtrl)
                                    {
                                        last_x = firstCtrl[0] / current_zoom;
                                        last_y = firstCtrl[1] / current_zoom
                                    }
                                    svgedit.path.replacePathSeg(6, index, [pt_x, pt_y, last_x, last_y, alt_x, alt_y], drawn_path)
                                }
                            }
                            else
                            {
                                var stretchy = svgedit.utilities.getElem("path_stretch_line");
                                if (stretchy)
                                {
                                    var prev = seglist.getItem(index);
                                    if (prev.pathSegType === 6)
                                    {
                                        var prev_x = prev.x + (prev.x - prev.x2);
                                        var prev_y = prev.y + (prev.y - prev.y2);
                                        svgedit.path.replacePathSeg(6, 1, [mouse_x, mouse_y, prev_x * current_zoom, prev_y * current_zoom, mouse_x, mouse_y], stretchy)
                                    }
                                    else if (firstCtrl)
                                    {
                                        svgedit.path.replacePathSeg(6, 1, [mouse_x, mouse_y, firstCtrl[0], firstCtrl[1], mouse_x, mouse_y], stretchy)
                                    }
                                    else
                                    {
                                        svgedit.path.replacePathSeg(4, 1, [mouse_x, mouse_y], stretchy)
                                    }
                                }
                            }
                            return
                        }
                        if (svgedit.path.path.dragging)
                        {
                            var pt = svgedit.path.getPointFromGrip({
                                    x: svgedit.path.path.dragging[0], y: svgedit.path.path.dragging[1]
                                }, svgedit.path.path);
                            var mpt = svgedit.path.getPointFromGrip({
                                    x: mouse_x, y: mouse_y
                                }, svgedit.path.path);
                            var diff_x = mpt.x - pt.x;
                            var diff_y = mpt.y - pt.y;
                            svgedit.path.path.dragging = [mouse_x, mouse_y];
                            if (svgedit.path.path.dragctrl)
                            {
                                svgedit.path.path.moveCtrl(diff_x, diff_y)
                            }
                            else
                            {
                                svgedit.path.path.movePts(diff_x, diff_y)
                            }
                        }
                        else
                        {
                            svgedit.path.path.selected_pts = [];
                            svgedit.path.path.eachSeg(function(i)
                            {
                                var seg = this;
                                if (!seg.next && !seg.prev)
                                {
                                    return
                                }
                                var item = seg.item;
                                var rbb = rubberBox.getBBox();
                                var pt = svgedit.path.getGripPt(seg);
                                var pt_bb = {
                                        x: pt.x, y: pt.y, width: 0, height: 0
                                    };
                                var sel = svgedit.math.rectsIntersect(rbb, pt_bb);
                                this.select(sel);
                                if (sel)
                                {
                                    svgedit.path.path.selected_pts.push(seg.index)
                                }
                            })
                        }
                    }, mouseUp: function(evt, element, mouse_x, mouse_y)
                    {
                        if (current_mode === "path")
                        {
                            newPoint = null;
                            if (!drawn_path)
                            {
                                element = svgedit.utilities.getElem(getId());
                                started = false;
                                firstCtrl = null
                            }
                            return {
                                    keep: true, element: element
                                }
                        }
                        if (svgedit.path.path.dragging)
                        {
                            var last_pt = svgedit.path.path.cur_pt;
                            svgedit.path.path.dragging = false;
                            svgedit.path.path.dragctrl = false;
                            svgedit.path.path.update();
                            if (hasMoved)
                            {
                                svgedit.path.path.endChanges("Move path point(s)")
                            }
                            if (!evt.shiftKey && !hasMoved)
                            {
                                svgedit.path.path.selectPt(last_pt)
                            }
                        }
                        else if (rubberBox && rubberBox.getAttribute('display') != 'none')
                        {
                            rubberBox.setAttribute("display", "none");
                            if (rubberBox.getAttribute('width') <= 2 && rubberBox.getAttribute('height') <= 2)
                            {
                                pathActions.toSelectMode(evt.target)
                            }
                        }
                        else
                        {
                            pathActions.toSelectMode(evt.target)
                        }
                        hasMoved = false
                    }, toEditMode: function(element)
                    {
                        svgedit.path.path = svgedit.path.getPath_(element);
                        current_mode = "pathedit";
                        clearSelection();
                        svgedit.path.path.show(true).update();
                        svgedit.path.path.oldbbox = svgedit.utilities.getBBox(svgedit.path.path.elem);
                        subpath = false
                    }, toSelectMode: function(elem)
                    {
                        var selPath = (elem == svgedit.path.path.elem);
                        current_mode = "select";
                        svgedit.path.path.show(false);
                        current_path = false;
                        clearSelection();
                        if (svgedit.path.path.matrix)
                        {
                            svgedit.path.recalcRotatedPath()
                        }
                        if (selPath)
                        {
                            call("selected", [elem]);
                            addToSelection([elem], true)
                        }
                    }, addSubPath: function(on)
                    {
                        if (on)
                        {
                            current_mode = "path";
                            subpath = true
                        }
                        else
                        {
                            pathActions.clear(true);
                            pathActions.toEditMode(svgedit.path.path.elem)
                        }
                    }, select: function(target)
                    {
                        if (current_path === target)
                        {
                            pathActions.toEditMode(target);
                            current_mode = "pathedit"
                        }
                        else
                        {
                            current_path = target
                        }
                    }, reorient: function()
                    {
                        var elem = selectedElements[0];
                        if (!elem)
                        {
                            return
                        }
                        var angle = svgedit.utilities.getRotationAngle(elem);
                        if (angle == 0)
                        {
                            return
                        }
                        var batchCmd = new svgedit.history.BatchCommand("Reorient path");
                        var changes = {
                                d: elem.getAttribute('d'), transform: elem.getAttribute('transform')
                            };
                        batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(elem, changes));
                        clearSelection();
                        this.resetOrientation(elem);
                        addCommandToHistory(batchCmd);
                        svgedit.path.getPath_(elem).show(false).matrix = null;
                        this.clear();
                        addToSelection([elem], true);
                        call("changed", selectedElements)
                    }, clear: function(remove)
                    {
                        current_path = null;
                        if (drawn_path)
                        {
                            var elem = svgedit.utilities.getElem(getId());
                            $(svgedit.utilities.getElem("path_stretch_line")).remove();
                            $(elem).remove();
                            $(svgedit.utilities.getElem("pathpointgrip_container")).find('*').attr('display', 'none');
                            drawn_path = firstCtrl = null;
                            started = false
                        }
                        else if (current_mode == "pathedit")
                        {
                            this.toSelectMode()
                        }
                        if (svgedit.path.path)
                        {
                            svgedit.path.path.init().show(false)
                        }
                    }, resetOrientation: function(path)
                    {
                        if (path == null || path.nodeName != 'path')
                        {
                            return false
                        }
                        var tlist = svgedit.transformlist.getTransformList(path);
                        var m = svgedit.math.transformListToTransform(tlist).matrix;
                        tlist.clear();
                        path.removeAttribute("transform");
                        var segList = path.pathSegList;
                        var len = segList.numberOfItems;
                        var i,
                            last_x,
                            last_y;
                        for (i = 0; i < len; ++i)
                        {
                            var seg = segList.getItem(i);
                            var type = seg.pathSegType;
                            if (type == 1)
                            {
                                continue
                            }
                            var pts = [];
                            $.each(['', 1, 2], function(j, n)
                            {
                                var x = seg['x' + n],
                                    y = seg['y' + n];
                                if (x !== undefined && y !== undefined)
                                {
                                    var pt = svgedit.math.transformPoint(x, y, m);
                                    pts.splice(pts.length, 0, pt.x, pt.y)
                                }
                            });
                            svgedit.path.replacePathSeg(type, i, pts, path)
                        }
                        reorientGrads(path, m)
                    }, zoomChange: function()
                    {
                        if (current_mode == "pathedit")
                        {
                            svgedit.path.path.update()
                        }
                    }, getNodePoint: function()
                    {
                        var sel_pt = svgedit.path.path.selected_pts.length ? svgedit.path.path.selected_pts[0] : 1;
                        var seg = svgedit.path.path.segs[sel_pt];
                        return {
                                x: seg.item.x, y: seg.item.y, type: seg.type
                            }
                    }, linkControlPoints: function(linkPoints)
                    {
                        svgedit.path.setLinkControlPoints(linkPoints)
                    }, clonePathNode: function()
                    {
                        svgedit.path.path.storeD();
                        var sel_pts = svgedit.path.path.selected_pts;
                        var segs = svgedit.path.path.segs;
                        var i = sel_pts.length;
                        var nums = [];
                        while (i--)
                        {
                            var pt = sel_pts[i];
                            svgedit.path.path.addSeg(pt);
                            nums.push(pt + i);
                            nums.push(pt + i + 1)
                        }
                        svgedit.path.path.init().addPtsToSelection(nums);
                        svgedit.path.path.endChanges("Clone path node(s)")
                    }, opencloseSubPath: function()
                    {
                        var sel_pts = svgedit.path.path.selected_pts;
                        if (sel_pts.length !== 1)
                        {
                            return
                        }
                        var elem = svgedit.path.path.elem;
                        var list = elem.pathSegList;
                        var len = list.numberOfItems;
                        var index = sel_pts[0];
                        var open_pt = null;
                        var start_item = null;
                        svgedit.path.path.eachSeg(function(i)
                        {
                            if (this.type === 2 && i <= index)
                            {
                                start_item = this.item
                            }
                            if (i <= index)
                            {
                                return true
                            }
                            if (this.type === 2)
                            {
                                open_pt = i;
                                return false
                            }
                            if (this.type === 1)
                            {
                                open_pt = false;
                                return false
                            }
                        });
                        if (open_pt == null)
                        {
                            open_pt = svgedit.path.path.segs.length - 1
                        }
                        if (open_pt !== false)
                        {
                            var newseg = elem.createSVGPathSegLinetoAbs(start_item.x, start_item.y);
                            var closer = elem.createSVGPathSegClosePath();
                            if (open_pt == svgedit.path.path.segs.length - 1)
                            {
                                list.appendItem(newseg);
                                list.appendItem(closer)
                            }
                            else
                            {
                                svgedit.path.insertItemBefore(elem, closer, open_pt);
                                svgedit.path.insertItemBefore(elem, newseg, open_pt)
                            }
                            svgedit.path.path.init().selectPt(open_pt + 1);
                            return
                        }
                        var seg = svgedit.path.path.segs[index];
                        if (seg.mate)
                        {
                            list.removeItem(index);
                            list.removeItem(index);
                            svgedit.path.path.init().selectPt(index - 1);
                            return
                        }
                        var i,
                            last_m,
                            z_seg;
                        for (i = 0; i < list.numberOfItems; i++)
                        {
                            var item = list.getItem(i);
                            if (item.pathSegType === 2)
                            {
                                last_m = i
                            }
                            else if (i === index)
                            {
                                list.removeItem(last_m)
                            }
                            else if (item.pathSegType === 1 && index < i)
                            {
                                z_seg = i - 1;
                                list.removeItem(i);
                                break
                            }
                        }
                        var num = (index - last_m) - 1;
                        while (num--)
                        {
                            svgedit.path.insertItemBefore(elem, list.getItem(last_m), z_seg)
                        }
                        var pt = list.getItem(last_m);
                        svgedit.path.replacePathSeg(2, last_m, [pt.x, pt.y]);
                        i = index;
                        svgedit.path.path.init().selectPt(0)
                    }, deletePathNode: function()
                    {
                        if (!pathActions.canDeleteNodes)
                        {
                            return
                        }
                        svgedit.path.path.storeD();
                        var sel_pts = svgedit.path.path.selected_pts;
                        var i = sel_pts.length;
                        while (i--)
                        {
                            var pt = sel_pts[i];
                            svgedit.path.path.deleteSeg(pt)
                        }
                        var cleanup = function()
                            {
                                var segList = svgedit.path.path.elem.pathSegList;
                                var len = segList.numberOfItems;
                                var remItems = function(pos, count)
                                    {
                                        while (count--)
                                        {
                                            segList.removeItem(pos)
                                        }
                                    };
                                if (len <= 1)
                                {
                                    return true
                                }
                                while (len--)
                                {
                                    var item = segList.getItem(len);
                                    if (item.pathSegType === 1)
                                    {
                                        var prev = segList.getItem(len - 1);
                                        var nprev = segList.getItem(len - 2);
                                        if (prev.pathSegType === 2)
                                        {
                                            remItems(len - 1, 2);
                                            cleanup();
                                            break
                                        }
                                        else if (nprev.pathSegType === 2)
                                        {
                                            remItems(len - 2, 3);
                                            cleanup();
                                            break
                                        }
                                    }
                                    else if (item.pathSegType === 2)
                                    {
                                        if (len > 0)
                                        {
                                            var prev_type = segList.getItem(len - 1).pathSegType;
                                            if (prev_type === 2)
                                            {
                                                remItems(len - 1, 1);
                                                cleanup();
                                                break
                                            }
                                            else if (prev_type === 1 && segList.numberOfItems - 1 === len)
                                            {
                                                remItems(len, 1);
                                                cleanup();
                                                break
                                            }
                                        }
                                    }
                                }
                                return false
                            };
                        cleanup();
                        if (svgedit.path.path.elem.pathSegList.numberOfItems <= 1)
                        {
                            pathActions.toSelectMode(svgedit.path.path.elem);
                            canvas.deleteSelectedElements();
                            return
                        }
                        svgedit.path.path.init();
                        svgedit.path.path.clearSelection();
                        if (window.opera)
                        {
                            var cp = $(svgedit.path.path.elem);
                            cp.attr('d', cp.attr('d'))
                        }
                        svgedit.path.path.endChanges("Delete path node(s)")
                    }, smoothPolylineIntoPath: smoothPolylineIntoPath, setSegType: function(v)
                    {
                        svgedit.path.path.setSegType(v)
                    }, moveNode: function(attr, newValue)
                    {
                        var sel_pts = svgedit.path.path.selected_pts;
                        if (!sel_pts.length)
                        {
                            return
                        }
                        svgedit.path.path.storeD();
                        var seg = svgedit.path.path.segs[sel_pts[0]];
                        var diff = {
                                x: 0, y: 0
                            };
                        diff[attr] = newValue - seg.item[attr];
                        seg.move(diff.x, diff.y);
                        svgedit.path.path.endChanges("Move path point")
                    }, fixEnd: function(elem)
                    {
                        var segList = elem.pathSegList;
                        var len = segList.numberOfItems;
                        var i,
                            last_m;
                        for (i = 0; i < len; ++i)
                        {
                            var item = segList.getItem(i);
                            if (item.pathSegType === 2)
                            {
                                last_m = item
                            }
                            if (item.pathSegType === 1)
                            {
                                var prev = segList.getItem(i - 1);
                                if (prev.x != last_m.x || prev.y != last_m.y)
                                {
                                    var newseg = elem.createSVGPathSegLinetoAbs(last_m.x, last_m.y);
                                    svgedit.path.insertItemBefore(elem, newseg, i);
                                    pathActions.fixEnd(elem);
                                    break
                                }
                            }
                        }
                        if (svgedit.browser.isWebkit())
                        {
                            resetD(elem)
                        }
                    }, convertPath: function(path, toRel)
                    {
                        var i;
                        var segList = path.pathSegList;
                        var len = segList.numberOfItems;
                        var curx = 0,
                            cury = 0;
                        var d = "";
                        var last_m = null;
                        for (i = 0; i < len; ++i)
                        {
                            var seg = segList.getItem(i);
                            var x = seg.x || 0,
                                y = seg.y || 0,
                                x1 = seg.x1 || 0,
                                y1 = seg.y1 || 0,
                                x2 = seg.x2 || 0,
                                y2 = seg.y2 || 0;
                            var type = seg.pathSegType;
                            var letter = pathMap[type]['to' + (toRel ? 'Lower' : 'Upper') + 'Case']();
                            var addToD = function(pnts, more, last)
                                {
                                    var str = '';
                                    more = more ? ' ' + more.join(' ') : '';
                                    last = last ? ' ' + svgedit.units.shortFloat(last) : '';
                                    $.each(pnts, function(i, pnt)
                                    {
                                        pnts[i] = svgedit.units.shortFloat(pnt)
                                    });
                                    d += letter + pnts.join(' ') + more + last
                                };
                            switch (type)
                            {
                                case 1:
                                    d += "z";
                                    break;
                                case 12:
                                    x -= curx;
                                case 13:
                                    if (toRel)
                                    {
                                        curx += x;
                                        letter = 'l'
                                    }
                                    else
                                    {
                                        x += curx;
                                        curx = x;
                                        letter = 'L'
                                    }
                                    addToD([[x, cury]]);
                                    break;
                                case 14:
                                    y -= cury;
                                case 15:
                                    if (toRel)
                                    {
                                        cury += y;
                                        letter = 'l'
                                    }
                                    else
                                    {
                                        y += cury;
                                        cury = y;
                                        letter = 'L'
                                    }
                                    addToD([[curx, y]]);
                                    break;
                                case 2:
                                case 4:
                                case 18:
                                    x -= curx;
                                    y -= cury;
                                case 5:
                                case 3:
                                    if (last_m && segList.getItem(i - 1).pathSegType === 1 && !toRel)
                                    {
                                        curx = last_m[0];
                                        cury = last_m[1]
                                    }
                                case 19:
                                    if (toRel)
                                    {
                                        curx += x;
                                        cury += y
                                    }
                                    else
                                    {
                                        x += curx;
                                        y += cury;
                                        curx = x;
                                        cury = y
                                    }
                                    if (type === 3)
                                    {
                                        last_m = [curx, cury]
                                    }
                                    addToD([[x, y]]);
                                    break;
                                case 6:
                                    x -= curx;
                                    x1 -= curx;
                                    x2 -= curx;
                                    y -= cury;
                                    y1 -= cury;
                                    y2 -= cury;
                                case 7:
                                    if (toRel)
                                    {
                                        curx += x;
                                        cury += y
                                    }
                                    else
                                    {
                                        x += curx;
                                        x1 += curx;
                                        x2 += curx;
                                        y += cury;
                                        y1 += cury;
                                        y2 += cury;
                                        curx = x;
                                        cury = y
                                    }
                                    addToD([[x1, y1], [x2, y2], [x, y]]);
                                    break;
                                case 8:
                                    x -= curx;
                                    x1 -= curx;
                                    y -= cury;
                                    y1 -= cury;
                                case 9:
                                    if (toRel)
                                    {
                                        curx += x;
                                        cury += y
                                    }
                                    else
                                    {
                                        x += curx;
                                        x1 += curx;
                                        y += cury;
                                        y1 += cury;
                                        curx = x;
                                        cury = y
                                    }
                                    addToD([[x1, y1], [x, y]]);
                                    break;
                                case 10:
                                    x -= curx;
                                    y -= cury;
                                case 11:
                                    if (toRel)
                                    {
                                        curx += x;
                                        cury += y
                                    }
                                    else
                                    {
                                        x += curx;
                                        y += cury;
                                        curx = x;
                                        cury = y
                                    }
                                    addToD([[seg.r1, seg.r2]], [seg.angle, (seg.largeArcFlag ? 1 : 0), (seg.sweepFlag ? 1 : 0)], [x, y]);
                                    break;
                                case 16:
                                    x -= curx;
                                    x2 -= curx;
                                    y -= cury;
                                    y2 -= cury;
                                case 17:
                                    if (toRel)
                                    {
                                        curx += x;
                                        cury += y
                                    }
                                    else
                                    {
                                        x += curx;
                                        x2 += curx;
                                        y += cury;
                                        y2 += cury;
                                        curx = x;
                                        cury = y
                                    }
                                    addToD([[x2, y2], [x, y]]);
                                    break
                            }
                        }
                        return d
                    }
            }
    }();
    var removeUnusedDefElems = this.removeUnusedDefElems = function()
        {
            var defs = svgcontent.getElementsByTagNameNS(NS.SVG, "defs");
            if (!defs || !defs.length)
            {
                return 0
            }
            var defelem_uses = [],
                numRemoved = 0;
            var attrs = ['fill', 'stroke', 'filter', 'marker-start', 'marker-mid', 'marker-end'];
            var alen = attrs.length;
            var all_els = svgcontent.getElementsByTagNameNS(NS.SVG, '*');
            var all_len = all_els.length;
            var i,
                j;
            for (i = 0; i < all_len; i++)
            {
                var el = all_els[i];
                for (j = 0; j < alen; j++)
                {
                    var ref = svgedit.utilities.getUrlFromAttr(el.getAttribute(attrs[j]));
                    if (ref)
                    {
                        defelem_uses.push(ref.substr(1))
                    }
                }
                var href = getHref(el);
                if (href && href.indexOf('#') === 0)
                {
                    defelem_uses.push(href.substr(1))
                }
            }
            var defelems = $(defs).find("linearGradient, radialGradient, filter, marker, svg, symbol");
            i = defelems.length;
            while (i--)
            {
                var defelem = defelems[i];
                var id = defelem.id;
                if (defelem_uses.indexOf(id) < 0)
                {
                    removedElements[id] = defelem;
                    defelem.parentNode.removeChild(defelem);
                    numRemoved++
                }
            }
            return numRemoved
        };
    this.svgCanvasToString = function()
    {
        while (removeUnusedDefElems() > 0)
        {}
        pathActions.clear(true);
        $.each(svgcontent.childNodes, function(i, node)
        {
            if (i && node.nodeType === 8 && node.data.indexOf('Created with') >= 0)
            {
                svgcontent.insertBefore(node, svgcontent.firstChild)
            }
        });
        if (current_group)
        {
            leaveContext();
            selectOnly([current_group])
        }
        var naked_svgs = [];
        $(svgcontent).find('g:data(gsvg)').each(function()
        {
            var attrs = this.attributes;
            var len = attrs.length;
            var i;
            for (i = 0; i < len; i++)
            {
                if (attrs[i].nodeName == 'id' || attrs[i].nodeName == 'style')
                {
                    len--
                }
            }
            if (len <= 0)
            {
                var svg = this.firstChild;
                naked_svgs.push(svg);
                $(this).replaceWith(svg)
            }
        });
        var output = this.svgToString(svgcontent, 0);
        if (naked_svgs.length)
        {
            $(naked_svgs).each(function()
            {
                groupSvgElem(this)
            })
        }
        return output
    };
    this.svgToString = function(elem, indent)
    {
        var out = [],
            toXml = svgedit.utilities.toXml;
        var unit = curConfig.baseUnit;
        var unit_re = new RegExp('^-?[\\d\\.]+' + unit + '$');
        if (elem)
        {
            cleanupElement(elem);
            var attrs = elem.attributes,
                attr,
                i,
                childs = elem.childNodes;
            for (i = 0; i < indent; i++)
            {
                out.push(' ')
            }
            out.push("<");
            out.push(elem.nodeName);
            if (elem.id === 'svgcontent')
            {
                var res = getResolution();
                var vb = "";
                if (unit !== "px")
                {
                    res.w = svgedit.units.convertUnit(res.w, unit) + unit;
                    res.h = svgedit.units.convertUnit(res.h, unit) + unit
                }
                out.push(' width="' + res.w + '" height="' + res.h + '"' + vb + ' xmlns="' + NS.SVG + '"');
                var nsuris = {};
                $(elem).find('*').andSelf().each(function()
                {
                    var el = this;
                    var uri = this.namespaceURI;
                    if (uri && !nsuris[uri] && nsMap[uri] && nsMap[uri] !== 'xmlns' && nsMap[uri] !== 'xml')
                    {
                        nsuris[uri] = true;
                        out.push(" xmlns:" + nsMap[uri] + '="' + uri + '"')
                    }
                    $.each(this.attributes, function(i, attr)
                    {
                        var uri = attr.namespaceURI;
                        if (uri && !nsuris[uri] && nsMap[uri] !== 'xmlns' && nsMap[uri] !== 'xml')
                        {
                            nsuris[uri] = true;
                            out.push(" xmlns:" + nsMap[uri] + '="' + uri + '"')
                        }
                    })
                });
                i = attrs.length;
                var attr_names = ['width', 'height', 'xmlns', 'x', 'y', 'viewBox', 'id', 'overflow'];
                while (i--)
                {
                    attr = attrs.item(i);
                    var attrVal = toXml(attr.nodeValue);
                    if (attr.nodeName.indexOf('xmlns:') === 0)
                    {
                        continue
                    }
                    if (attrVal != "" && attr_names.indexOf(attr.localName) == -1)
                    {
                        if (!attr.namespaceURI || nsMap[attr.namespaceURI])
                        {
                            out.push(' ');
                            out.push(attr.nodeName);
                            out.push("=\"");
                            out.push(attrVal);
                            out.push("\"")
                        }
                    }
                }
            }
            else
            {
                if (elem.nodeName === 'defs' && !elem.firstChild)
                {
                    return
                }
                var moz_attrs = ['-moz-math-font-style', '_moz-math-font-style'];
                for (i = attrs.length - 1; i >= 0; i--)
                {
                    attr = attrs.item(i);
                    var attrVal = toXml(attr.nodeValue);
                    if (moz_attrs.indexOf(attr.localName) >= 0)
                    {
                        continue
                    }
                    if (attrVal != "")
                    {
                        if (attrVal.indexOf('pointer-events') === 0)
                        {
                            continue
                        }
                        if (attr.localName === "class" && attrVal.indexOf('se_') === 0)
                        {
                            continue
                        }
                        out.push(" ");
                        if (attr.localName === 'd')
                        {
                            attrVal = pathActions.convertPath(elem, true)
                        }
                        if (!isNaN(attrVal))
                        {
                            attrVal = svgedit.units.shortFloat(attrVal)
                        }
                        else if (unit_re.test(attrVal))
                        {
                            attrVal = svgedit.units.shortFloat(attrVal) + unit
                        }
                        if (save_options.apply && elem.nodeName === 'image' && attr.localName === 'href' && save_options.images && save_options.images === 'embed')
                        {
                            var img = encodableImages[attrVal];
                            if (img)
                            {
                                attrVal = img
                            }
                        }
                        if (!attr.namespaceURI || attr.namespaceURI == NS.SVG || nsMap[attr.namespaceURI])
                        {
                            out.push(attr.nodeName);
                            out.push("=\"");
                            out.push(attrVal);
                            out.push("\"")
                        }
                    }
                }
            }
            if (elem.hasChildNodes())
            {
                out.push(">");
                indent++;
                var bOneLine = false;
                for (i = 0; i < childs.length; i++)
                {
                    var child = childs.item(i);
                    switch (child.nodeType)
                    {
                        case 1:
                            out.push("\n");
                            out.push(this.svgToString(childs.item(i), indent));
                            break;
                        case 3:
                            var str = child.nodeValue.replace(/^\s+|\s+$/g, "");
                            if (str != "")
                            {
                                bOneLine = true;
                                out.push(String(toXml(str)))
                            }
                            break;
                        case 4:
                            out.push("\n");
                            out.push(new Array(indent + 1).join(" "));
                            out.push("<![CDATA[");
                            out.push(child.nodeValue);
                            out.push("]]>");
                            break;
                        case 8:
                            out.push("\n");
                            out.push(new Array(indent + 1).join(" "));
                            out.push("<!--");
                            out.push(child.data);
                            out.push("-->");
                            break
                    }
                }
                indent--;
                if (!bOneLine)
                {
                    out.push("\n");
                    for (i = 0; i < indent; i++)
                    {
                        out.push(' ')
                    }
                }
                out.push("</");
                out.push(elem.nodeName);
                out.push(">")
            }
            else
            {
                out.push("/>")
            }
        }
        return out.join('')
    };
    this.embedImage = function(val, callback)
    {
        $(new Image).load(function()
        {
            var canvas = document.createElement("canvas");
            canvas.width = this.width;
            canvas.height = this.height;
            canvas.getContext("2d").drawImage(this, 0, 0);
            try
            {
                var urldata = ';svgedit_url=' + encodeURIComponent(val);
                urldata = canvas.toDataURL().replace(';base64', urldata + ';base64');
                encodableImages[val] = urldata
            }
            catch(e)
            {
                encodableImages[val] = false
            }
            last_good_img_url = val;
            if (callback)
            {
                callback(encodableImages[val])
            }
        }).attr('src', val)
    };
    this.setGoodImage = function(val)
    {
        last_good_img_url = val
    };
    this.open = function(){};
    this.save = function(opts)
    {
        clearSelection();
        if (opts)
        {
            $.extend(save_options, opts)
        }
        save_options.apply = true;
        var str = this.svgCanvasToString();
        call("saved", str)
    };
    this.rasterExport = function(imgType, quality)
    {
        var mimeType = 'image/' + imgType.toLowerCase();
        clearSelection();
        var issues = [];
        var issue_list = {
                feGaussianBlur: uiStrings.exportNoBlur, foreignObject: uiStrings.exportNoforeignObject, '[stroke-dasharray]': uiStrings.exportNoDashArray
            };
        var content = $(svgcontent);
        if (!("font" in $('<canvas>')[0].getContext('2d')))
        {
            issue_list.text = uiStrings.exportNoText
        }
        $.each(issue_list, function(sel, descr)
        {
            if (content.find(sel).length)
            {
                issues.push(descr)
            }
        });
        var str = this.svgCanvasToString();
        call("exported", {
            svg: str, issues: issues, type: imgType, mimeType: mimeType, quality: quality
        })
    };
    this.getSvgString = function()
    {
        save_options.apply = false;
        return this.svgCanvasToString()
    };
    this.randomizeIds = function(enableRandomization)
    {
        if (arguments.length > 0 && enableRandomization == false)
        {
            svgedit.draw.randomizeIds(false, getCurrentDrawing())
        }
        else
        {
            svgedit.draw.randomizeIds(true, getCurrentDrawing())
        }
    };
    var uniquifyElems = this.uniquifyElems = function(g)
        {
            var ids = {};
            var ref_elems = ["filter", "linearGradient", "pattern", "radialGradient", "symbol", "textPath", "use"];
            svgedit.utilities.walkTree(g, function(n)
            {
                if (n.nodeType == 1)
                {
                    if (n.id)
                    {
                        if (!(n.id in ids))
                        {
                            ids[n.id] = {
                                elem: null, attrs: [], hrefs: []
                            }
                        }
                        ids[n.id].elem = n
                    }
                    $.each(ref_attrs, function(i, attr)
                    {
                        var attrnode = n.getAttributeNode(attr);
                        if (attrnode)
                        {
                            var url = svgedit.utilities.getUrlFromAttr(attrnode.value),
                                refid = url ? url.substr(1) : null;
                            if (refid)
                            {
                                if (!(refid in ids))
                                {
                                    ids[refid] = {
                                        elem: null, attrs: [], hrefs: []
                                    }
                                }
                                ids[refid].attrs.push(attrnode)
                            }
                        }
                    });
                    var href = svgedit.utilities.getHref(n);
                    if (href && ref_elems.indexOf(n.nodeName) >= 0)
                    {
                        var refid = href.substr(1);
                        if (refid)
                        {
                            if (!(refid in ids))
                            {
                                ids[refid] = {
                                    elem: null, attrs: [], hrefs: []
                                }
                            }
                            ids[refid].hrefs.push(n)
                        }
                    }
                }
            });
            var oldid;
            for (oldid in ids)
            {
                if (!oldid)
                {
                    continue
                }
                var elem = ids[oldid].elem;
                if (elem)
                {
                    var newid = getNextId();
                    elem.id = newid;
                    var attrs = ids[oldid].attrs;
                    var j = attrs.length;
                    while (j--)
                    {
                        var attr = attrs[j];
                        attr.ownerElement.setAttribute(attr.name, "url(#" + newid + ")")
                    }
                    var hreffers = ids[oldid].hrefs;
                    var k = hreffers.length;
                    while (k--)
                    {
                        var hreffer = hreffers[k];
                        svgedit.utilities.setHref(hreffer, "#" + newid)
                    }
                }
            }
        };
    var setUseData = this.setUseData = function(parent)
        {
            var elems = $(parent);
            if (parent.tagName !== 'use')
            {
                elems = elems.find('use')
            }
            elems.each(function()
            {
                var id = getHref(this).substr(1);
                var ref_elem = svgedit.utilities.getElem(id);
                if (!ref_elem)
                {
                    return
                }
                $(this).data('ref', ref_elem);
                if (ref_elem.tagName == 'symbol' || ref_elem.tagName == 'svg')
                {
                    $(this).data('symbol', ref_elem).data('ref', ref_elem)
                }
            })
        };
    var convertGradients = this.convertGradients = function(elem)
        {
            var elems = $(elem).find('linearGradient, radialGradient');
            if (!elems.length && svgedit.browser.isWebkit())
            {
                elems = $(elem).find('*').filter(function()
                {
                    return (this.tagName.indexOf('Gradient') >= 0)
                })
            }
            elems.each(function()
            {
                var grad = this;
                if ($(grad).attr('gradientUnits') === 'userSpaceOnUse')
                {
                    var elems = $(svgcontent).find('[fill="url(#' + grad.id + ')"],[stroke="url(#' + grad.id + ')"]');
                    if (!elems.length)
                    {
                        return
                    }
                    var bb = svgedit.utilities.getBBox(elems[0]);
                    if (!bb)
                    {
                        return
                    }
                    if (grad.tagName === 'linearGradient')
                    {
                        var g_coords = $(grad).attr(['x1', 'y1', 'x2', 'y2']);
                        var tlist = grad.gradientTransform.baseVal;
                        if (tlist && tlist.numberOfItems > 0)
                        {
                            var m = svgedit.math.transformListToTransform(tlist).matrix;
                            var pt1 = svgedit.math.transformPoint(g_coords.x1, g_coords.y1, m);
                            var pt2 = svgedit.math.transformPoint(g_coords.x2, g_coords.y2, m);
                            g_coords.x1 = pt1.x;
                            g_coords.y1 = pt1.y;
                            g_coords.x2 = pt2.x;
                            g_coords.y2 = pt2.y;
                            grad.removeAttribute('gradientTransform')
                        }
                        $(grad).attr({
                            x1: (g_coords.x1 - bb.x) / bb.width, y1: (g_coords.y1 - bb.y) / bb.height, x2: (g_coords.x2 - bb.x) / bb.width, y2: (g_coords.y2 - bb.y) / bb.height
                        });
                        grad.removeAttribute('gradientUnits')
                    }
                }
            })
        };
    var convertToGroup = this.convertToGroup = function(elem)
        {
            if (!elem)
            {
                elem = selectedElements[0]
            }
            var $elem = $(elem);
            var batchCmd = new svgedit.history.BatchCommand;
            var ts;
            if ($elem.data('gsvg'))
            {
                var svg = elem.firstChild;
                var pt = $(svg).attr(['x', 'y']);
                $(elem.firstChild.firstChild).unwrap();
                $(elem).removeData('gsvg');
                var tlist = svgedit.transformlist.getTransformList(elem);
                var xform = svgroot.createSVGTransform();
                xform.setTranslate(pt.x, pt.y);
                tlist.appendItem(xform);
                svgedit.recalculate.recalculateDimensions(elem);
                call("selected", [elem])
            }
            else if ($elem.data('symbol'))
            {
                elem = $elem.data('symbol');
                ts = $elem.attr('transform');
                var pos = $elem.attr(['x', 'y']);
                var vb = elem.getAttribute('viewBox');
                if (vb)
                {
                    var nums = vb.split(' ');
                    pos.x -= +nums[0];
                    pos.y -= +nums[1]
                }
                ts += " translate(" + (pos.x || 0) + "," + (pos.y || 0) + ")";
                var prev = $elem.prev();
                batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand($elem[0], $elem[0].nextSibling, $elem[0].parentNode));
                $elem.remove();
                var has_more = $(svgcontent).find('use:data(symbol)').length;
                var g = svgdoc.createElementNS(NS.SVG, "g");
                var childs = elem.childNodes;
                var i;
                for (i = 0; i < childs.length; i++)
                {
                    g.appendChild(childs[i].cloneNode(true))
                }
                if (svgedit.browser.isGecko())
                {
                    var dupeGrads = $(svgedit.utilities.findDefs()).children('linearGradient,radialGradient,pattern').clone();
                    $(g).append(dupeGrads)
                }
                if (ts)
                {
                    g.setAttribute("transform", ts)
                }
                var parent = elem.parentNode;
                uniquifyElems(g);
                if (svgedit.browser.isGecko())
                {
                    $(findDefs()).append($(g).find('linearGradient,radialGradient,pattern'))
                }
                g.id = getNextId();
                prev.after(g);
                if (parent)
                {
                    if (!has_more)
                    {
                        var nextSibling = elem.nextSibling;
                        parent.removeChild(elem);
                        batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(elem, nextSibling, parent))
                    }
                    batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(g))
                }
                setUseData(g);
                if (svgedit.browser.isGecko())
                {
                    convertGradients(svgedit.utilities.findDefs())
                }
                else
                {
                    convertGradients(g)
                }
                svgedit.utilities.walkTreePost(g, function(n)
                {
                    try
                    {
                        svgedit.recalculate.recalculateDimensions(n)
                    }
                    catch(e)
                    {
                        console.log(e)
                    }
                });
                $(g).find(visElems).each(function()
                {
                    if (!this.id)
                    {
                        this.id = getNextId()
                    }
                });
                selectOnly([g]);
                var cm = pushGroupProperties(g, true);
                if (cm)
                {
                    batchCmd.addSubCommand(cm)
                }
                addCommandToHistory(batchCmd)
            }
            else
            {
                console.log('Unexpected element to ungroup:', elem)
            }
        };
    this.setSvgString = function(xmlString)
    {
        try
        {
            var newDoc = svgedit.utilities.text2xml(xmlString);
            this.prepareSvg(newDoc);
            var batchCmd = new svgedit.history.BatchCommand("Change Source");
            var nextSibling = svgcontent.nextSibling;
            var oldzoom = svgroot.removeChild(svgcontent);
            batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(oldzoom, nextSibling, svgroot));
            if (svgdoc.adoptNode)
            {
                svgcontent = svgdoc.adoptNode(newDoc.documentElement)
            }
            else
            {
                svgcontent = svgdoc.importNode(newDoc.documentElement, true)
            }
            svgroot.appendChild(svgcontent);
            var content = $(svgcontent);
            canvas.current_drawing_ = new svgedit.draw.Drawing(svgcontent, idprefix);
            var nonce = getCurrentDrawing().getNonce();
            if (nonce)
            {
                call("setnonce", nonce)
            }
            else
            {
                call("unsetnonce")
            }
            content.find('image').each(function()
            {
                var image = this;
                preventClickDefault(image);
                var val = getHref(this);
                if (val)
                {
                    if (val.indexOf('data:') === 0)
                    {
                        var m = val.match(/svgedit_url=(.*?);/);
                        if (m)
                        {
                            var url = decodeURIComponent(m[1]);
                            $(new Image).load(function()
                            {
                                image.setAttributeNS(NS.XLINK, 'xlink:href', url)
                            }).attr('src', url)
                        }
                    }
                    canvas.embedImage(val)
                }
            });
            content.find('svg').each(function()
            {
                if ($(this).closest('defs').length)
                {
                    return
                }
                uniquifyElems(this);
                var pa = this.parentNode;
                if (pa.childNodes.length === 1 && pa.nodeName === 'g')
                {
                    $(pa).data('gsvg', this);
                    pa.id = pa.id || getNextId()
                }
                else
                {
                    groupSvgElem(this)
                }
            });
            if (svgedit.browser.isGecko())
            {
                content.find('linearGradient, radialGradient, pattern').appendTo(svgedit.utilities.findDefs())
            }
            setUseData(content);
            convertGradients(content[0]);
            svgedit.utilities.walkTreePost(svgcontent, function(n)
            {
                try
                {
                    svgedit.recalculate.recalculateDimensions(n)
                }
                catch(e)
                {
                    console.log(e)
                }
            });
            var attrs = {
                    id: 'svgcontent', overflow: curConfig.show_outside_canvas ? 'visible' : 'hidden'
                };
            var percs = false;
            if (content.attr("viewBox"))
            {
                var vb = content.attr("viewBox").split(' ');
                attrs.width = vb[2];
                attrs.height = vb[3]
            }
            else
            {
                $.each(['width', 'height'], function(i, dim)
                {
                    var val = content.attr(dim);
                    if (!val)
                    {
                        val = '100%'
                    }
                    if (String(val).substr(-1) === "%")
                    {
                        percs = true
                    }
                    else
                    {
                        attrs[dim] = svgedit.units.convertToNum(dim, val)
                    }
                })
            }
            identifyLayers();
            content.children().find(visElems).each(function()
            {
                if (!this.id)
                {
                    this.id = getNextId()
                }
            });
            if (percs)
            {
                var bb = getStrokedBBox();
                attrs.width = bb.width + bb.x;
                attrs.height = bb.height + bb.y
            }
            if (attrs.width <= 0)
            {
                attrs.width = 100
            }
            if (attrs.height <= 0)
            {
                attrs.height = 100
            }
            content.attr(attrs);
            this.contentW = attrs.width;
            this.contentH = attrs.height;
            batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(svgcontent));
            var changes = content.attr(["width", "height"]);
            batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(svgroot, changes));
            current_zoom = 1;
            svgedit.transformlist.resetListMap();
            clearSelection();
            svgedit.path.clearData();
            svgroot.appendChild(selectorManager.selectorParentGroup);
            addCommandToHistory(batchCmd);
            call("changed", [svgcontent])
        }
        catch(e)
        {
            console.log(e);
            return false
        }
        return true
    };
    this.importSvgString = function(xmlString)
    {
        var j,
            ts;
        try
        {
            var uid = svgedit.utilities.encode64(xmlString.length + xmlString).substr(0, 32);
            var useExisting = false;
            if (import_ids[uid])
            {
                if ($(import_ids[uid].symbol).parents('#svgroot').length)
                {
                    useExisting = true
                }
            }
            var batchCmd = new svgedit.history.BatchCommand("Import SVG");
            var symbol;
            if (useExisting)
            {
                symbol = import_ids[uid].symbol;
                ts = import_ids[uid].xform
            }
            else
            {
                var newDoc = svgedit.utilities.text2xml(xmlString);
                this.prepareSvg(newDoc);
                var svg;
                if (svgdoc.adoptNode)
                {
                    svg = svgdoc.adoptNode(newDoc.documentElement)
                }
                else
                {
                    svg = svgdoc.importNode(newDoc.documentElement, true)
                }
                uniquifyElems(svg);
                var innerw = svgedit.units.convertToNum('width', svg.getAttribute("width")),
                    innerh = svgedit.units.convertToNum('height', svg.getAttribute("height")),
                    innervb = svg.getAttribute("viewBox"),
                    vb = innervb ? innervb.split(" ") : [0, 0, innerw, innerh];
                for (j = 0; j < 4; ++j)
                {
                    vb[j] = +(vb[j])
                }
                var canvasw = +svgcontent.getAttribute("width"),
                    canvash = +svgcontent.getAttribute("height");
                if (innerh > innerw)
                {
                    ts = "scale(" + (canvash / 3) / vb[3] + ")"
                }
                else
                {
                    ts = "scale(" + (canvash / 3) / vb[2] + ")"
                }
                ts = "translate(0) " + ts + " translate(0)";
                symbol = svgdoc.createElementNS(NS.SVG, "symbol");
                var defs = svgedit.utilities.findDefs();
                if (svgedit.browser.isGecko())
                {
                    $(svg).find('linearGradient, radialGradient, pattern').appendTo(defs)
                }
                while (svg.firstChild)
                {
                    var first = svg.firstChild;
                    symbol.appendChild(first)
                }
                var attrs = svg.attributes;
                var i;
                for (i = 0; i < attrs.length; i++)
                {
                    var attr = attrs[i];
                    symbol.setAttribute(attr.nodeName, attr.nodeValue)
                }
                symbol.id = getNextId();
                import_ids[uid] = {
                    symbol: symbol, xform: ts
                };
                svgedit.utilities.findDefs().appendChild(symbol);
                batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(symbol))
            }
            var use_el = svgdoc.createElementNS(NS.SVG, "use");
            use_el.id = getNextId();
            setHref(use_el, "#" + symbol.id);
            (current_group || getCurrentDrawing().getCurrentLayer()).appendChild(use_el);
            batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(use_el));
            clearSelection();
            use_el.setAttribute("transform", ts);
            svgedit.recalculate.recalculateDimensions(use_el);
            $(use_el).data('symbol', symbol).data('ref', symbol);
            addToSelection([use_el]);
            addCommandToHistory(batchCmd);
            call("changed", [svgcontent])
        }
        catch(e)
        {
            console.log(e);
            return false
        }
        return true
    };
    var identifyLayers = canvas.identifyLayers = function()
        {
            leaveContext();
            getCurrentDrawing().identifyLayers()
        };
    this.createLayer = function(name)
    {
        var batchCmd = new svgedit.history.BatchCommand("Create Layer");
        var new_layer = getCurrentDrawing().createLayer(name);
        batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(new_layer));
        addCommandToHistory(batchCmd);
        clearSelection();
        call("changed", [new_layer])
    };
    this.cloneLayer = function(name)
    {
        var batchCmd = new svgedit.history.BatchCommand("Duplicate Layer");
        var new_layer = svgdoc.createElementNS(NS.SVG, "g");
        var layer_title = svgdoc.createElementNS(NS.SVG, "title");
        layer_title.textContent = name;
        new_layer.appendChild(layer_title);
        var current_layer = getCurrentDrawing().getCurrentLayer();
        $(current_layer).after(new_layer);
        var childs = current_layer.childNodes;
        var i;
        for (i = 0; i < childs.length; i++)
        {
            var ch = childs[i];
            if (ch.localName == 'title')
            {
                continue
            }
            new_layer.appendChild(copyElem(ch))
        }
        clearSelection();
        identifyLayers();
        batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(new_layer));
        addCommandToHistory(batchCmd);
        canvas.setCurrentLayer(name);
        call("changed", [new_layer])
    };
    this.deleteCurrentLayer = function()
    {
        var current_layer = getCurrentDrawing().getCurrentLayer();
        var nextSibling = current_layer.nextSibling;
        var parent = current_layer.parentNode;
        current_layer = getCurrentDrawing().deleteCurrentLayer();
        if (current_layer)
        {
            var batchCmd = new svgedit.history.BatchCommand("Delete Layer");
            batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(current_layer, nextSibling, parent));
            addCommandToHistory(batchCmd);
            clearSelection();
            call("changed", [parent]);
            return true
        }
        return false
    };
    this.setCurrentLayer = function(name)
    {
        var result = getCurrentDrawing().setCurrentLayer(svgedit.utilities.toXml(name));
        if (result)
        {
            clearSelection()
        }
        return result
    };
    this.renameCurrentLayer = function(newname)
    {
        var i;
        var drawing = getCurrentDrawing();
        if (drawing.current_layer)
        {
            var oldLayer = drawing.current_layer;
            if (!canvas.setCurrentLayer(newname))
            {
                var batchCmd = new svgedit.history.BatchCommand("Rename Layer");
                for (i = 0; i < drawing.getNumLayers(); ++i)
                {
                    if (drawing.all_layers[i][1] == oldLayer)
                    {
                        break
                    }
                }
                var oldname = drawing.getLayerName(i);
                drawing.all_layers[i][0] = svgedit.utilities.toXml(newname);
                var len = oldLayer.childNodes.length;
                for (i = 0; i < len; ++i)
                {
                    var child = oldLayer.childNodes.item(i);
                    if (child && child.tagName == "title")
                    {
                        while (child.firstChild)
                        {
                            child.removeChild(child.firstChild)
                        }
                        child.textContent = newname;
                        batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(child, {"#text": oldname}));
                        addCommandToHistory(batchCmd);
                        call("changed", [oldLayer]);
                        return true
                    }
                }
            }
            drawing.current_layer = oldLayer
        }
        return false
    };
    this.setCurrentLayerPosition = function(newpos)
    {
        var oldpos,
            drawing = getCurrentDrawing();
        if (drawing.current_layer && newpos >= 0 && newpos < drawing.getNumLayers())
        {
            for (oldpos = 0; oldpos < drawing.getNumLayers(); ++oldpos)
            {
                if (drawing.all_layers[oldpos][1] == drawing.current_layer)
                {
                    break
                }
            }
            if (oldpos == drawing.getNumLayers())
            {
                return false
            }
            if (oldpos != newpos)
            {
                var refLayer = null;
                var oldNextSibling = drawing.current_layer.nextSibling;
                if (newpos > oldpos)
                {
                    if (newpos < drawing.getNumLayers() - 1)
                    {
                        refLayer = drawing.all_layers[newpos + 1][1]
                    }
                }
                else
                {
                    refLayer = drawing.all_layers[newpos][1]
                }
                svgcontent.insertBefore(drawing.current_layer, refLayer);
                addCommandToHistory(new svgedit.history.MoveElementCommand(drawing.current_layer, oldNextSibling, svgcontent));
                identifyLayers();
                canvas.setCurrentLayer(drawing.getLayerName(newpos));
                return true
            }
        }
        return false
    };
    this.setLayerVisibility = function(layername, bVisible)
    {
        var drawing = getCurrentDrawing();
        var prevVisibility = drawing.getLayerVisibility(layername);
        var layer = drawing.setLayerVisibility(layername, bVisible);
        if (layer)
        {
            var oldDisplay = prevVisibility ? 'inline' : 'none';
            addCommandToHistory(new svgedit.history.ChangeElementCommand(layer, {display: oldDisplay}, 'Layer Visibility'))
        }
        else
        {
            return false
        }
        if (layer == drawing.getCurrentLayer())
        {
            clearSelection();
            pathActions.clear()
        }
        return true
    };
    this.moveSelectedToLayer = function(layername)
    {
        var i;
        var layer = null;
        var drawing = getCurrentDrawing();
        for (i = 0; i < drawing.getNumLayers(); ++i)
        {
            if (drawing.getLayerName(i) == layername)
            {
                layer = drawing.all_layers[i][1];
                break
            }
        }
        if (!layer)
        {
            return false
        }
        var batchCmd = new svgedit.history.BatchCommand("Move Elements to Layer");
        var selElems = selectedElements;
        i = selElems.length;
        while (i--)
        {
            var elem = selElems[i];
            if (!elem)
            {
                continue
            }
            var oldNextSibling = elem.nextSibling;
            var oldLayer = elem.parentNode;
            layer.appendChild(elem);
            batchCmd.addSubCommand(new svgedit.history.MoveElementCommand(elem, oldNextSibling, oldLayer))
        }
        addCommandToHistory(batchCmd);
        return true
    };
    this.mergeLayer = function(skipHistory)
    {
        var batchCmd = new svgedit.history.BatchCommand("Merge Layer");
        var drawing = getCurrentDrawing();
        var prev = $(drawing.current_layer).prev()[0];
        if (!prev)
        {
            return
        }
        var childs = drawing.current_layer.childNodes;
        var len = childs.length;
        var layerNextSibling = drawing.current_layer.nextSibling;
        batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(drawing.current_layer, layerNextSibling, svgcontent));
        while (drawing.current_layer.firstChild)
        {
            var ch = drawing.current_layer.firstChild;
            if (ch.localName == 'title')
            {
                var chNextSibling = ch.nextSibling;
                batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(ch, chNextSibling, drawing.current_layer));
                drawing.current_layer.removeChild(ch);
                continue
            }
            var oldNextSibling = ch.nextSibling;
            prev.appendChild(ch);
            batchCmd.addSubCommand(new svgedit.history.MoveElementCommand(ch, oldNextSibling, drawing.current_layer))
        }
        svgcontent.removeChild(drawing.current_layer);
        if (!skipHistory)
        {
            clearSelection();
            identifyLayers();
            call("changed", [svgcontent]);
            addCommandToHistory(batchCmd)
        }
        drawing.current_layer = prev;
        return batchCmd
    };
    this.mergeAllLayers = function()
    {
        var batchCmd = new svgedit.history.BatchCommand("Merge all Layers");
        var drawing = getCurrentDrawing();
        drawing.current_layer = drawing.all_layers[drawing.getNumLayers() - 1][1];
        while ($(svgcontent).children('g').length > 1)
        {
            batchCmd.addSubCommand(canvas.mergeLayer(true))
        }
        clearSelection();
        identifyLayers();
        call("changed", [svgcontent]);
        addCommandToHistory(batchCmd)
    };
    var leaveContext = this.leaveContext = function()
        {
            var i,
                len = disabled_elems.length;
            if (len)
            {
                for (i = 0; i < len; i++)
                {
                    var elem = disabled_elems[i];
                    var orig = elData(elem, 'orig_opac');
                    if (orig !== 1)
                    {
                        elem.setAttribute('opacity', orig)
                    }
                    else
                    {
                        elem.removeAttribute('opacity')
                    }
                    elem.setAttribute('style', 'pointer-events: inherit')
                }
                disabled_elems = [];
                clearSelection(true);
                call("contextset", null)
            }
            current_group = null
        };
    var setContext = this.setContext = function(elem)
        {
            leaveContext();
            if (typeof elem === 'string')
            {
                elem = svgedit.utilities.getElem(elem)
            }
            current_group = elem;
            $(elem).parentsUntil('#svgcontent').andSelf().siblings().each(function()
            {
                var opac = this.getAttribute('opacity') || 1;
                elData(this, 'orig_opac', opac);
                this.setAttribute('opacity', opac * 0.33);
                this.setAttribute('style', 'pointer-events: none');
                disabled_elems.push(this)
            });
            clearSelection();
            call("contextset", current_group)
        };
    this.clear = function()
    {
        pathActions.clear();
        clearSelection();
        canvas.clearSvgContentElement();
        canvas.current_drawing_ = new svgedit.draw.Drawing(svgcontent);
        canvas.createLayer("Layer 1");
        canvas.undoMgr.resetUndoStack();
        selectorManager.initGroup();
        rubberBox = selectorManager.getRubberBandBox();
        call("cleared")
    };
    this.linkControlPoints = pathActions.linkControlPoints;
    this.getContentElem = function()
    {
        return svgcontent
    };
    this.getRootElem = function()
    {
        return svgroot
    };
    this.getSelectedElems = function()
    {
        return selectedElements
    };
    var getResolution = this.getResolution = function()
        {
            var width = svgcontent.getAttribute("width") / current_zoom;
            var height = svgcontent.getAttribute("height") / current_zoom;
            return {
                    w: width, h: height, zoom: current_zoom
                }
        };
    this.getZoom = function()
    {
        return current_zoom
    };
    this.getVersion = function()
    {
        return "svgcanvas.js ($Rev: 2705 $)"
    };
    this.setUiStrings = function(strs)
    {
        $.extend(uiStrings, strs.notification)
    };
    this.setConfig = function(opts)
    {
        $.extend(curConfig, opts)
    };
    this.getTitle = function(elem)
    {
        var i;
        elem = elem || selectedElements[0];
        if (!elem)
        {
            return
        }
        elem = $(elem).data('gsvg') || $(elem).data('symbol') || elem;
        var childs = elem.childNodes;
        for (i = 0; i < childs.length; i++)
        {
            if (childs[i].nodeName == 'title')
            {
                return childs[i].textContent
            }
        }
        return ''
    };
    this.setGroupTitle = function(val)
    {
        var elem = selectedElements[0];
        elem = $(elem).data('gsvg') || elem;
        var ts = $(elem).children('title');
        var batchCmd = new svgedit.history.BatchCommand("Set Label");
        if (!val.length)
        {
            var tsNextSibling = ts.nextSibling;
            batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(ts[0], tsNextSibling, elem));
            ts.remove()
        }
        else if (ts.length)
        {
            var title = ts[0];
            batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(title, {'#text': title.textContent}));
            title.textContent = val
        }
        else
        {
            title = svgdoc.createElementNS(NS.SVG, "title");
            title.textContent = val;
            $(elem).prepend(title);
            batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(title))
        }
        addCommandToHistory(batchCmd)
    };
    this.getDocumentTitle = function()
    {
        return canvas.getTitle(svgcontent)
    };
    this.setDocumentTitle = function(newtitle)
    {
        var i;
        var childs = svgcontent.childNodes,
            doc_title = false,
            old_title = '';
        var batchCmd = new svgedit.history.BatchCommand("Change Image Title");
        for (i = 0; i < childs.length; i++)
        {
            if (childs[i].nodeName == 'title')
            {
                doc_title = childs[i];
                old_title = doc_title.textContent;
                break
            }
        }
        if (!doc_title)
        {
            doc_title = svgdoc.createElementNS(NS.SVG, "title");
            svgcontent.insertBefore(doc_title, svgcontent.firstChild)
        }
        if (newtitle.length)
        {
            doc_title.textContent = newtitle
        }
        else
        {
            doc_title.parentNode.removeChild(doc_title)
        }
        batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(doc_title, {'#text': old_title}));
        addCommandToHistory(batchCmd)
    };
    this.getEditorNS = function(add)
    {
        if (add)
        {
            svgcontent.setAttribute('xmlns:se', NS.SE)
        }
        return NS.SE
    };
    this.setResolution = function(x, y)
    {
        var res = getResolution();
        var w = res.w,
            h = res.h;
        var batchCmd;
        if (x == 'fit')
        {
            var bbox = getStrokedBBox();
            if (bbox)
            {
                batchCmd = new svgedit.history.BatchCommand("Fit Canvas to Content");
                var visEls = getVisibleElements();
                addToSelection(visEls);
                var dx = [],
                    dy = [];
                $.each(visEls, function(i, item)
                {
                    dx.push(bbox.x * -1);
                    dy.push(bbox.y * -1)
                });
                var cmd = canvas.moveSelectedElements(dx, dy, true);
                batchCmd.addSubCommand(cmd);
                clearSelection();
                x = Math.round(bbox.width);
                y = Math.round(bbox.height)
            }
            else
            {
                return false
            }
        }
        if (x != w || y != h)
        {
            var handle = svgroot.suspendRedraw(1000);
            if (!batchCmd)
            {
                batchCmd = new svgedit.history.BatchCommand("Change Image Dimensions")
            }
            x = svgedit.units.convertToNum('width', x);
            y = svgedit.units.convertToNum('height', y);
            svgcontent.setAttribute('width', x);
            svgcontent.setAttribute('height', y);
            this.contentW = x;
            this.contentH = y;
            batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(svgcontent, {
                width: w, height: h
            }));
            svgcontent.setAttribute("viewBox", [0, 0, x / current_zoom, y / current_zoom].join(' '));
            batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(svgcontent, {viewBox: ["0 0", w, h].join(' ')}));
            addCommandToHistory(batchCmd);
            svgroot.unsuspendRedraw(handle);
            call("changed", [svgcontent])
        }
        return true
    };
    this.getOffset = function()
    {
        return $(svgcontent).attr(['x', 'y'])
    };
    this.setBBoxZoom = function(val, editor_w, editor_h)
    {
        var spacer = 0.85;
        var bb;
        var calcZoom = function(bb)
            {
                if (!bb)
                {
                    return false
                }
                var w_zoom = Math.round((editor_w / bb.width) * 100 * spacer) / 100;
                var h_zoom = Math.round((editor_h / bb.height) * 100 * spacer) / 100;
                var zoomlevel = Math.min(w_zoom, h_zoom);
                canvas.setZoom(zoomlevel);
                return {
                        zoom: zoomlevel, bbox: bb
                    }
            };
        if (typeof val == 'object')
        {
            bb = val;
            if (bb.width == 0 || bb.height == 0)
            {
                var newzoom = bb.zoom ? bb.zoom : current_zoom * bb.factor;
                canvas.setZoom(newzoom);
                return {
                        zoom: current_zoom, bbox: bb
                    }
            }
            return calcZoom(bb)
        }
        switch (val)
        {
            case'selection':
                if (!selectedElements[0])
                {
                    return
                }
                var sel_elems = $.map(selectedElements, function(n)
                    {
                        if (n)
                        {
                            return n
                        }
                    });
                bb = getStrokedBBox(sel_elems);
                break;
            case'canvas':
                var res = getResolution();
                spacer = 0.95;
                bb = {
                    width: res.w, height: res.h, x: 0, y: 0
                };
                break;
            case'content':
                bb = getStrokedBBox();
                break;
            case'layer':
                bb = getStrokedBBox(getVisibleElements(getCurrentDrawing().getCurrentLayer()));
                break;
            default:
                return
        }
        return calcZoom(bb)
    };
    this.setZoom = function(zoomlevel)
    {
        var res = getResolution();
        svgcontent.setAttribute("viewBox", "0 0 " + res.w / zoomlevel + " " + res.h / zoomlevel);
        current_zoom = zoomlevel;
        $.each(selectedElements, function(i, elem)
        {
            if (!elem)
            {
                return
            }
            selectorManager.requestSelector(elem).resize()
        });
        pathActions.zoomChange();
        runExtensions("zoomChanged", zoomlevel)
    };
    this.getMode = function()
    {
        return current_mode
    };
    this.setMode = function(name)
    {
        pathActions.clear(true);
        textActions.clear();
        cur_properties = (selectedElements[0] && selectedElements[0].nodeName == 'text') ? cur_text : cur_shape;
        current_mode = name
    };
    this.getColor = function(type)
    {
        return cur_properties[type]
    };
    this.setColor = function(type, val, preventUndo)
    {
        cur_shape[type] = val;
        cur_properties[type + '_paint'] = {type: "solidColor"};
        var elems = [];
        function addNonG(e)
        {
            if (e.nodeName != "g")
            {
                elems.push(e)
            }
        }
        var i = selectedElements.length;
        while (i--)
        {
            var elem = selectedElements[i];
            if (elem)
            {
                if (elem.tagName == "g")
                {
                    svgedit.utilities.walkTree(elem, addNonG)
                }
                else
                {
                    if (type == 'fill')
                    {
                        if (elem.tagName != "polyline" && elem.tagName != "line")
                        {
                            elems.push(elem)
                        }
                    }
                    else
                    {
                        elems.push(elem)
                    }
                }
            }
        }
        if (elems.length > 0)
        {
            if (!preventUndo)
            {
                changeSelectedAttribute(type, val, elems);
                call("changed", elems)
            }
            else
            {
                changeSelectedAttributeNoUndo(type, val, elems)
            }
        }
    };
    var setGradient = this.setGradient = function(type)
        {
            if (!cur_properties[type + '_paint'] || cur_properties[type + '_paint'].type == "solidColor")
            {
                return
            }
            var grad = canvas[type + 'Grad'];
            var duplicate_grad = findDuplicateGradient(grad);
            var defs = svgedit.utilities.findDefs();
            if (!duplicate_grad)
            {
                var orig_grad = grad;
                grad = defs.appendChild(svgdoc.importNode(grad, true));
                grad.id = getNextId()
            }
            else
            {
                grad = duplicate_grad
            }
            canvas.setColor(type, "url(#" + grad.id + ")")
        };
    var findDuplicateGradient = function(grad)
        {
            var defs = svgedit.utilities.findDefs();
            var existing_grads = $(defs).find("linearGradient, radialGradient");
            var i = existing_grads.length;
            var rad_attrs = ['r', 'cx', 'cy', 'fx', 'fy'];
            while (i--)
            {
                var og = existing_grads[i];
                if (grad.tagName == "linearGradient")
                {
                    if (grad.getAttribute('x1') != og.getAttribute('x1') || grad.getAttribute('y1') != og.getAttribute('y1') || grad.getAttribute('x2') != og.getAttribute('x2') || grad.getAttribute('y2') != og.getAttribute('y2'))
                    {
                        continue
                    }
                }
                else
                {
                    var grad_attrs = $(grad).attr(rad_attrs);
                    var og_attrs = $(og).attr(rad_attrs);
                    var diff = false;
                    $.each(rad_attrs, function(i, attr)
                    {
                        if (grad_attrs[attr] != og_attrs[attr])
                        {
                            diff = true
                        }
                    });
                    if (diff)
                    {
                        continue
                    }
                }
                var stops = grad.getElementsByTagNameNS(NS.SVG, "stop");
                var ostops = og.getElementsByTagNameNS(NS.SVG, "stop");
                if (stops.length != ostops.length)
                {
                    continue
                }
                var j = stops.length;
                while (j--)
                {
                    var stop = stops[j];
                    var ostop = ostops[j];
                    if (stop.getAttribute('offset') != ostop.getAttribute('offset') || stop.getAttribute('stop-opacity') != ostop.getAttribute('stop-opacity') || stop.getAttribute('stop-color') != ostop.getAttribute('stop-color'))
                    {
                        break
                    }
                }
                if (j == -1)
                {
                    return og
                }
            }
            return null
        };
    function reorientGrads(elem, m)
    {
        var i;
        var bb = svgedit.utilities.getBBox(elem);
        for (i = 0; i < 2; i++)
        {
            var type = i === 0 ? 'fill' : 'stroke';
            var attrVal = elem.getAttribute(type);
            if (attrVal && attrVal.indexOf('url(') === 0)
            {
                var grad = svgedit.utilities.getRefElem(attrVal);
                if (grad.tagName === 'linearGradient')
                {
                    var x1 = grad.getAttribute('x1') || 0;
                    var y1 = grad.getAttribute('y1') || 0;
                    var x2 = grad.getAttribute('x2') || 1;
                    var y2 = grad.getAttribute('y2') || 0;
                    x1 = (bb.width * x1) + bb.x;
                    y1 = (bb.height * y1) + bb.y;
                    x2 = (bb.width * x2) + bb.x;
                    y2 = (bb.height * y2) + bb.y;
                    var pt1 = svgedit.math.transformPoint(x1, y1, m);
                    var pt2 = svgedit.math.transformPoint(x2, y2, m);
                    var g_coords = {};
                    g_coords.x1 = (pt1.x - bb.x) / bb.width;
                    g_coords.y1 = (pt1.y - bb.y) / bb.height;
                    g_coords.x2 = (pt2.x - bb.x) / bb.width;
                    g_coords.y2 = (pt2.y - bb.y) / bb.height;
                    var newgrad = grad.cloneNode(true);
                    $(newgrad).attr(g_coords);
                    newgrad.id = getNextId();
                    svgedit.utilities.findDefs().appendChild(newgrad);
                    elem.setAttribute(type, 'url(#' + newgrad.id + ')')
                }
            }
        }
    }
    this.setPaint = function(type, paint)
    {
        var p = new $.jGraduate.Paint(paint);
        this.setPaintOpacity(type, p.alpha / 100, true);
        cur_properties[type + '_paint'] = p;
        switch (p.type)
        {
            case'solidColor':
                this.setColor(type, p.solidColor != 'none' ? '#' + p.solidColor : 'none');
                break;
            case'linearGradient':
            case'radialGradient':
                canvas[type + 'Grad'] = p[p.type];
                setGradient(type);
                break
        }
    };
    this.setStrokePaint = function(paint)
    {
        this.setPaint('stroke', paint)
    };
    this.setFillPaint = function(paint)
    {
        this.setPaint('fill', paint)
    };
    this.getStrokeWidth = function()
    {
        return cur_properties.stroke_width
    };
    this.setStrokeWidth = function(val)
    {
        if (val == 0 && ['line', 'path'].indexOf(current_mode) >= 0)
        {
            canvas.setStrokeWidth(1);
            return
        }
        cur_properties.stroke_width = val;
        var elems = [];
        function addNonG(e)
        {
            if (e.nodeName != 'g')
            {
                elems.push(e)
            }
        }
        var i = selectedElements.length;
        while (i--)
        {
            var elem = selectedElements[i];
            if (elem)
            {
                if (elem.tagName == "g")
                {
                    svgedit.utilities.walkTree(elem, addNonG)
                }
                else
                {
                    elems.push(elem)
                }
            }
        }
        if (elems.length > 0)
        {
            changeSelectedAttribute("stroke-width", val, elems);
            call("changed", selectedElements)
        }
    };
    this.setStrokeAttr = function(attr, val)
    {
        cur_shape[attr.replace('-', '_')] = val;
        var elems = [];
        function addNonG(e)
        {
            if (e.nodeName != 'g')
            {
                elems.push(e)
            }
        }
        var i = selectedElements.length;
        while (i--)
        {
            var elem = selectedElements[i];
            if (elem)
            {
                if (elem.tagName == "g")
                {
                    svgedit.utilities.walkTree(elem, function(e)
                    {
                        if (e.nodeName != "g")
                        {
                            elems.push(e)
                        }
                    })
                }
                else
                {
                    elems.push(elem)
                }
            }
        }
        if (elems.length > 0)
        {
            changeSelectedAttribute(attr, val, elems);
            call("changed", selectedElements)
        }
    };
    this.getStyle = function()
    {
        return cur_shape
    };
    this.getOpacity = function()
    {
        return cur_shape.opacity
    };
    this.setOpacity = function(val)
    {
        cur_shape.opacity = val;
        changeSelectedAttribute("opacity", val)
    };
    this.getFillOpacity = function()
    {
        return cur_shape.fill_opacity
    };
    this.getStrokeOpacity = function()
    {
        return cur_shape.stroke_opacity
    };
    this.setPaintOpacity = function(type, val, preventUndo)
    {
        cur_shape[type + '_opacity'] = val;
        if (!preventUndo)
        {
            changeSelectedAttribute(type + "-opacity", val)
        }
        else
        {
            changeSelectedAttributeNoUndo(type + "-opacity", val)
        }
    };
    this.getPaintOpacity = function(type)
    {
        return type === 'fill' ? this.getFillOpacity() : this.getStrokeOpacity()
    };
    this.getBlur = function(elem)
    {
        var val = 0;
        if (elem)
        {
            var filter_url = elem.getAttribute('filter');
            if (filter_url)
            {
                var blur = svgedit.utilities.getElem(elem.id + '_blur');
                if (blur)
                {
                    val = blur.firstChild.getAttribute('stdDeviation')
                }
            }
        }
        return val
    };
    (function()
    {
        var cur_command = null;
        var filter = null;
        var filterHidden = false;
        canvas.setBlurNoUndo = function(val)
        {
            if (!filter)
            {
                canvas.setBlur(val);
                return
            }
            if (val === 0)
            {
                changeSelectedAttributeNoUndo("filter", "");
                filterHidden = true
            }
            else
            {
                var elem = selectedElements[0];
                if (filterHidden)
                {
                    changeSelectedAttributeNoUndo("filter", 'url(#' + elem.id + '_blur)')
                }
                if (svgedit.browser.isWebkit())
                {
                    console.log('e', elem);
                    elem.removeAttribute('filter');
                    elem.setAttribute('filter', 'url(#' + elem.id + '_blur)')
                }
                changeSelectedAttributeNoUndo("stdDeviation", val, [filter.firstChild]);
                canvas.setBlurOffsets(filter, val)
            }
        };
        function finishChange()
        {
            var bCmd = canvas.undoMgr.finishUndoableChange();
            cur_command.addSubCommand(bCmd);
            addCommandToHistory(cur_command);
            cur_command = null;
            filter = null
        }
        canvas.setBlurOffsets = function(filter, stdDev)
        {
            if (stdDev > 3)
            {
                svgedit.utilities.assignAttributes(filter, {
                    x: '-50%', y: '-50%', width: '200%', height: '200%'
                }, 100)
            }
            else
            {
                if (!svgedit.browser.isWebkit())
                {
                    filter.removeAttribute('x');
                    filter.removeAttribute('y');
                    filter.removeAttribute('width');
                    filter.removeAttribute('height')
                }
            }
        };
        canvas.setBlur = function(val, complete)
        {
            if (cur_command)
            {
                finishChange();
                return
            }
            var elem = selectedElements[0];
            var elem_id = elem.id;
            filter = svgedit.utilities.getElem(elem_id + '_blur');
            val -= 0;
            var batchCmd = new svgedit.history.BatchCommand;
            if (filter)
            {
                if (val === 0)
                {
                    filter = null
                }
            }
            else
            {
                var newblur = addSvgElementFromJson({
                        element: "feGaussianBlur", attr: {
                                "in": 'SourceGraphic', stdDeviation: val
                            }
                    });
                filter = addSvgElementFromJson({
                    element: "filter", attr: {id: elem_id + '_blur'}
                });
                filter.appendChild(newblur);
                svgedit.utilities.findDefs().appendChild(filter);
                batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(filter))
            }
            var changes = {filter: elem.getAttribute('filter')};
            if (val === 0)
            {
                elem.removeAttribute("filter");
                batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(elem, changes));
                return
            }
            changeSelectedAttribute("filter", 'url(#' + elem_id + '_blur)');
            batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(elem, changes));
            canvas.setBlurOffsets(filter, val);
            cur_command = batchCmd;
            canvas.undoMgr.beginUndoableChange("stdDeviation", [filter ? filter.firstChild : null]);
            if (complete)
            {
                canvas.setBlurNoUndo(val);
                finishChange()
            }
        }
    }());
    this.getBold = function()
    {
        var selected = selectedElements[0];
        if (selected != null && selected.tagName == "text" && selectedElements[1] == null)
        {
            return (selected.getAttribute("font-weight") == "bold")
        }
        return false
    };
    this.setBold = function(b)
    {
        var selected = selectedElements[0];
        if (selected != null && selected.tagName == "text" && selectedElements[1] == null)
        {
            changeSelectedAttribute("font-weight", b ? "bold" : "normal")
        }
        if (!selectedElements[0].textContent)
        {
            textActions.setCursor()
        }
    };
    this.getItalic = function()
    {
        var selected = selectedElements[0];
        if (selected != null && selected.tagName == "text" && selectedElements[1] == null)
        {
            return (selected.getAttribute("font-style") == "italic")
        }
        return false
    };
    this.setItalic = function(i)
    {
        var selected = selectedElements[0];
        if (selected != null && selected.tagName == "text" && selectedElements[1] == null)
        {
            changeSelectedAttribute("font-style", i ? "italic" : "normal")
        }
        if (!selectedElements[0].textContent)
        {
            textActions.setCursor()
        }
    };
    this.getFontFamily = function()
    {
        return cur_text.font_family
    };
    this.setFontFamily = function(val)
    {
        cur_text.font_family = val;
        changeSelectedAttribute("font-family", val);
        if (selectedElements[0] && !selectedElements[0].textContent)
        {
            textActions.setCursor()
        }
    };
    this.setFontColor = function(val)
    {
        cur_text.fill = val;
        changeSelectedAttribute("fill", val)
    };
    this.getFontColor = function()
    {
        return cur_text.fill
    };
    this.getFontSize = function()
    {
        return cur_text.font_size
    };
    this.setFontSize = function(val)
    {
        cur_text.font_size = val;
        changeSelectedAttribute("font-size", val);
        if (!selectedElements[0].textContent)
        {
            textActions.setCursor()
        }
    };
    this.getText = function()
    {
        var selected = selectedElements[0];
        if (selected == null)
        {
            return ""
        }
        return selected.textContent
    };
    this.setTextContent = function(val)
    {
        changeSelectedAttribute("#text", val);
        textActions.init(val);
        textActions.setCursor()
    };
    this.setImageURL = function(val)
    {
        var elem = selectedElements[0];
        if (!elem)
        {
            return
        }
        var attrs = $(elem).attr(['width', 'height']);
        var setsize = (!attrs.width || !attrs.height);
        var cur_href = getHref(elem);
        if (cur_href !== val)
        {
            setsize = true
        }
        else if (!setsize)
        {
            return
        }
        var batchCmd = new svgedit.history.BatchCommand("Change Image URL");
        setHref(elem, val);
        batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(elem, {"#href": cur_href}));
        if (setsize)
        {
            $(new Image).load(function()
            {
                var changes = $(elem).attr(['width', 'height']);
                $(elem).attr({
                    width: this.width, height: this.height
                });
                selectorManager.requestSelector(elem).resize();
                batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(elem, changes));
                addCommandToHistory(batchCmd);
                call("changed", [elem])
            }).attr('src', val)
        }
        else
        {
            addCommandToHistory(batchCmd)
        }
    };
    this.setLinkURL = function(val)
    {
        var elem = selectedElements[0];
        if (!elem)
        {
            return
        }
        if (elem.tagName !== 'a')
        {
            var parents_a = $(elem).parents('a');
            if (parents_a.length)
            {
                elem = parents_a[0]
            }
            else
            {
                return
            }
        }
        var cur_href = getHref(elem);
        if (cur_href === val)
        {
            return
        }
        var batchCmd = new svgedit.history.BatchCommand("Change Link URL");
        setHref(elem, val);
        batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(elem, {"#href": cur_href}));
        addCommandToHistory(batchCmd)
    };
    this.setRectRadius = function(val)
    {
        var selected = selectedElements[0];
        if (selected != null && selected.tagName == "rect")
        {
            var r = selected.getAttribute("rx");
            if (r != val)
            {
                selected.setAttribute("rx", val);
                selected.setAttribute("ry", val);
                addCommandToHistory(new svgedit.history.ChangeElementCommand(selected, {
                    rx: r, ry: r
                }, "Radius"));
                call("changed", [selected])
            }
        }
    };
    this.makeHyperlink = function(url)
    {
        canvas.groupSelectedElements('a', url)
    };
    this.removeHyperlink = function()
    {
        canvas.ungroupSelectedElement()
    };
    this.setSegType = function(new_type)
    {
        pathActions.setSegType(new_type)
    };
    this.convertToPath = function(elem, getBBox)
    {
        if (elem == null)
        {
            var elems = selectedElements;
            $.each(selectedElements, function(i, elem)
            {
                if (elem)
                {
                    canvas.convertToPath(elem)
                }
            });
            return
        }
        if (!getBBox)
        {
            var batchCmd = new svgedit.history.BatchCommand("Convert element to Path")
        }
        var attrs = getBBox ? {} : {
                fill: cur_shape.fill, "fill-opacity": cur_shape.fill_opacity, stroke: cur_shape.stroke, "stroke-width": cur_shape.stroke_width, "stroke-dasharray": cur_shape.stroke_dasharray, "stroke-linejoin": cur_shape.stroke_linejoin, "stroke-linecap": cur_shape.stroke_linecap, "stroke-opacity": cur_shape.stroke_opacity, opacity: cur_shape.opacity, visibility: "hidden"
            };
        $.each(['marker-start', 'marker-end', 'marker-mid', 'filter', 'clip-path'], function()
        {
            if (elem.getAttribute(this))
            {
                attrs[this] = elem.getAttribute(this)
            }
        });
        var path = addSvgElementFromJson({
                element: "path", attr: attrs
            });
        var eltrans = elem.getAttribute("transform");
        if (eltrans)
        {
            path.setAttribute("transform", eltrans)
        }
        var id = elem.id;
        var parent = elem.parentNode;
        if (elem.nextSibling)
        {
            parent.insertBefore(path, elem)
        }
        else
        {
            parent.appendChild(path)
        }
        var d = '';
        var joinSegs = function(segs)
            {
                $.each(segs, function(j, seg)
                {
                    var i;
                    var l = seg[0],
                        pts = seg[1];
                    d += l;
                    for (i = 0; i < pts.length; i += 2)
                    {
                        d += (pts[i] + ',' + pts[i + 1]) + ' '
                    }
                })
            };
        var num = 1.81;
        var a,
            rx;
        switch (elem.tagName)
        {
            case'ellipse':
            case'circle':
                a = $(elem).attr(['rx', 'ry', 'cx', 'cy']);
                var cx = a.cx,
                    cy = a.cy;
                rx = a.rx;
                ry = a.ry;
                if (elem.tagName == 'circle')
                {
                    rx = ry = $(elem).attr('r')
                }
                joinSegs([['M', [(cx - rx), (cy)]], ['C', [(cx - rx), (cy - ry / num), (cx - rx / num), (cy - ry), (cx), (cy - ry)]], ['C', [(cx + rx / num), (cy - ry), (cx + rx), (cy - ry / num), (cx + rx), (cy)]], ['C', [(cx + rx), (cy + ry / num), (cx + rx / num), (cy + ry), (cx), (cy + ry)]], ['C', [(cx - rx / num), (cy + ry), (cx - rx), (cy + ry / num), (cx - rx), (cy)]], ['Z', []]]);
                break;
            case'path':
                d = elem.getAttribute('d');
                break;
            case'line':
                a = $(elem).attr(["x1", "y1", "x2", "y2"]);
                d = "M" + a.x1 + "," + a.y1 + "L" + a.x2 + "," + a.y2;
                break;
            case'polyline':
            case'polygon':
                d = "M" + elem.getAttribute('points');
                break;
            case'rect':
                var r = $(elem).attr(['rx', 'ry']);
                rx = r.rx;
                ry = r.ry;
                var b = elem.getBBox();
                var x = b.x,
                    y = b.y,
                    w = b.width,
                    h = b.height;
                num = 4 - num;
                if (!rx && !ry)
                {
                    joinSegs([['M', [x, y]], ['L', [x + w, y]], ['L', [x + w, y + h]], ['L', [x, y + h]], ['L', [x, y]], ['Z', []]])
                }
                else
                {
                    joinSegs([['M', [x, y + ry]], ['C', [x, y + ry / num, x + rx / num, y, x + rx, y]], ['L', [x + w - rx, y]], ['C', [x + w - rx / num, y, x + w, y + ry / num, x + w, y + ry]], ['L', [x + w, y + h - ry]], ['C', [x + w, y + h - ry / num, x + w - rx / num, y + h, x + w - rx, y + h]], ['L', [x + rx, y + h]], ['C', [x + rx / num, y + h, x, y + h - ry / num, x, y + h - ry]], ['L', [x, y + ry]], ['Z', []]])
                }
                break;
            default:
                path.parentNode.removeChild(path);
                break
        }
        if (d)
        {
            path.setAttribute('d', d)
        }
        if (!getBBox)
        {
            if (eltrans)
            {
                var tlist = svgedit.transformlist.getTransformList(path);
                if (svgedit.math.hasMatrixTransform(tlist))
                {
                    pathActions.resetOrientation(path)
                }
            }
            var nextSibling = elem.nextSibling;
            batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(elem, nextSibling, parent));
            batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(path));
            clearSelection();
            elem.parentNode.removeChild(elem);
            path.setAttribute('id', id);
            path.removeAttribute("visibility");
            addToSelection([path], true);
            addCommandToHistory(batchCmd)
        }
        else
        {
            pathActions.resetOrientation(path);
            var bb = false;
            try
            {
                bb = path.getBBox()
            }
            catch(e) {}
            path.parentNode.removeChild(path);
            return bb
        }
    };
    var changeSelectedAttributeNoUndo = function(attr, newValue, elems)
        {
            var handle = svgroot.suspendRedraw(1000);
            if (current_mode == 'pathedit')
            {
                pathActions.moveNode(attr, newValue)
            }
            elems = elems || selectedElements;
            var i = elems.length;
            var no_xy_elems = ['g', 'polyline', 'path'];
            var good_g_attrs = ['transform', 'opacity', 'filter'];
            while (i--)
            {
                var elem = elems[i];
                if (elem == null)
                {
                    continue
                }
                if ((attr === 'x' || attr === 'y') && no_xy_elems.indexOf(elem.tagName) >= 0)
                {
                    var bbox = getStrokedBBox([elem]);
                    var diff_x = attr === 'x' ? newValue - bbox.x : 0;
                    var diff_y = attr === 'y' ? newValue - bbox.y : 0;
                    canvas.moveSelectedElements(diff_x * current_zoom, diff_y * current_zoom, true);
                    continue
                }
                if (elem.tagName === "g" && good_g_attrs.indexOf(attr) >= 0)
                {}
                var oldval = attr === "#text" ? elem.textContent : elem.getAttribute(attr);
                if (oldval == null)
                {
                    oldval = ""
                }
                if (oldval !== String(newValue))
                {
                    if (attr == "#text")
                    {
                        var old_w = svgedit.utilities.getBBox(elem).width;
                        elem.textContent = newValue;
                        if (/rotate/.test(elem.getAttribute('transform')))
                        {
                            elem = ffClone(elem)
                        }
                    }
                    else if (attr == "#href")
                    {
                        setHref(elem, newValue)
                    }
                    else
                    {
                        elem.setAttribute(attr, newValue)
                    }
                    if (current_mode === "textedit" && attr !== "#text" && elem.textContent.length)
                    {
                        textActions.toSelectMode(elem)
                    }
                    if (svgedit.browser.isGecko() && elem.nodeName === 'text' && /rotate/.test(elem.getAttribute('transform')))
                    {
                        if (String(newValue).indexOf('url') === 0 || (['font-size', 'font-family', 'x', 'y'].indexOf(attr) >= 0 && elem.textContent))
                        {
                            elem = ffClone(elem)
                        }
                    }
                    if (selectedElements.indexOf(elem) >= 0)
                    {
                        setTimeout(function()
                        {
                            if (!elem.parentNode)
                            {
                                return
                            }
                            selectorManager.requestSelector(elem).resize()
                        }, 0)
                    }
                    var angle = svgedit.utilities.getRotationAngle(elem);
                    if (angle != 0 && attr != "transform")
                    {
                        var tlist = svgedit.transformlist.getTransformList(elem);
                        var n = tlist.numberOfItems;
                        while (n--)
                        {
                            var xform = tlist.getItem(n);
                            if (xform.type == 4)
                            {
                                tlist.removeItem(n);
                                var box = svgedit.utilities.getBBox(elem);
                                var center = svgedit.math.transformPoint(box.x + box.width / 2, box.y + box.height / 2, svgedit.math.transformListToTransform(tlist).matrix);
                                var cx = center.x,
                                    cy = center.y;
                                var newrot = svgroot.createSVGTransform();
                                newrot.setRotate(angle, cx, cy);
                                tlist.insertItemBefore(newrot, n);
                                break
                            }
                        }
                    }
                }
            }
            svgroot.unsuspendRedraw(handle)
        };
    var changeSelectedAttribute = this.changeSelectedAttribute = function(attr, val, elems)
        {
            elems = elems || selectedElements;
            canvas.undoMgr.beginUndoableChange(attr, elems);
            var i = elems.length;
            changeSelectedAttributeNoUndo(attr, val, elems);
            var batchCmd = canvas.undoMgr.finishUndoableChange();
            if (!batchCmd.isEmpty())
            {
                addCommandToHistory(batchCmd)
            }
        };
    this.deleteSelectedElements = function()
    {
        var i;
        var batchCmd = new svgedit.history.BatchCommand("Delete Elements");
        var len = selectedElements.length;
        var selectedCopy = [];
        for (i = 0; i < len; ++i)
        {
            var selected = selectedElements[i];
            if (selected == null)
            {
                break
            }
            var parent = selected.parentNode;
            var t = selected;
            selectorManager.releaseSelector(t);
            svgedit.path.removePath_(t.id);
            if (parent.tagName === 'a' && parent.childNodes.length === 1)
            {
                t = parent;
                parent = parent.parentNode
            }
            var nextSibling = t.nextSibling;
            var elem = parent.removeChild(t);
            selectedCopy.push(selected);
            selectedElements[i] = null;
            batchCmd.addSubCommand(new RemoveElementCommand(elem, nextSibling, parent))
        }
        if (!batchCmd.isEmpty())
        {
            addCommandToHistory(batchCmd)
        }
        call("changed", selectedCopy);
        clearSelection()
    };
    this.cutSelectedElements = function()
    {
        var i;
        var batchCmd = new svgedit.history.BatchCommand("Cut Elements");
        var len = selectedElements.length;
        var selectedCopy = [];
        for (i = 0; i < len; ++i)
        {
            var selected = selectedElements[i];
            if (selected == null)
            {
                break
            }
            var parent = selected.parentNode;
            var t = selected;
            selectorManager.releaseSelector(t);
            svgedit.path.removePath_(t.id);
            var nextSibling = t.nextSibling;
            var elem = parent.removeChild(t);
            selectedCopy.push(selected);
            selectedElements[i] = null;
            batchCmd.addSubCommand(new RemoveElementCommand(elem, nextSibling, parent))
        }
        if (!batchCmd.isEmpty())
        {
            addCommandToHistory(batchCmd)
        }
        call("changed", selectedCopy);
        clearSelection();
        canvas.clipBoard = selectedCopy
    };
    this.copySelectedElements = function()
    {
        canvas.clipBoard = $.merge([], selectedElements)
    };
    this.pasteElements = function(type, x, y)
    {
        var cb = canvas.clipBoard;
        var len = cb.length;
        if (!len)
        {
            return
        }
        var pasted = [];
        var batchCmd = new svgedit.history.BatchCommand('Paste elements');
        while (len--)
        {
            var elem = cb[len];
            if (!elem)
            {
                continue
            }
            var copy = copyElem(elem);
            if (!svgedit.utilities.getElem(elem.id))
            {
                copy.id = elem.id
            }
            pasted.push(copy);
            (current_group || getCurrentDrawing().getCurrentLayer()).appendChild(copy);
            batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(copy))
        }
        selectOnly(pasted);
        if (type !== 'in_place')
        {
            var ctr_x,
                ctr_y;
            if (!type)
            {
                ctr_x = lastClickPoint.x;
                ctr_y = lastClickPoint.y
            }
            else if (type === 'point')
            {
                ctr_x = x;
                ctr_y = y
            }
            var bbox = getStrokedBBox(pasted);
            var cx = ctr_x - (bbox.x + bbox.width / 2),
                cy = ctr_y - (bbox.y + bbox.height / 2),
                dx = [],
                dy = [];
            $.each(pasted, function(i, item)
            {
                dx.push(cx);
                dy.push(cy)
            });
            var cmd = canvas.moveSelectedElements(dx, dy, false);
            batchCmd.addSubCommand(cmd)
        }
        addCommandToHistory(batchCmd);
        call("changed", pasted)
    };
    this.groupSelectedElements = function(type, urlArg)
    {
        if (!type)
        {
            type = 'g'
        }
        var cmd_str = '';
        switch (type)
        {
            case"a":
                cmd_str = "Make hyperlink";
                var url = '';
                if (arguments.length > 1)
                {
                    url = urlArg
                }
                break;
            default:
                type = 'g';
                cmd_str = "Group Elements";
                break
        }
        var batchCmd = new svgedit.history.BatchCommand(cmd_str);
        var g = addSvgElementFromJson({
                element: type, attr: {id: getNextId()}
            });
        if (type === 'a')
        {
            setHref(g, url)
        }
        batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(g));
        var i = selectedElements.length;
        while (i--)
        {
            var elem = selectedElements[i];
            if (elem == null)
            {
                continue
            }
            if (elem.parentNode.tagName === 'a' && elem.parentNode.childNodes.length === 1)
            {
                elem = elem.parentNode
            }
            var oldNextSibling = elem.nextSibling;
            var oldParent = elem.parentNode;
            g.appendChild(elem);
            batchCmd.addSubCommand(new svgedit.history.MoveElementCommand(elem, oldNextSibling, oldParent))
        }
        if (!batchCmd.isEmpty())
        {
            addCommandToHistory(batchCmd)
        }
        selectOnly([g], true)
    };
    var pushGroupProperties = this.pushGroupProperties = function(g, undoable)
        {
            var children = g.childNodes;
            var len = children.length;
            var xform = g.getAttribute("transform");
            var glist = svgedit.transformlist.getTransformList(g);
            var m = svgedit.math.transformListToTransform(glist).matrix;
            var batchCmd = new svgedit.history.BatchCommand("Push group properties");
            var i = 0;
            var gangle = svgedit.utilities.getRotationAngle(g);
            var gattrs = $(g).attr(['filter', 'opacity']);
            var gfilter,
                gblur,
                changes;
            for (i = 0; i < len; i++)
            {
                var elem = children[i];
                if (elem.nodeType !== 1)
                {
                    continue
                }
                if (gattrs.opacity !== null && gattrs.opacity !== 1)
                {
                    var c_opac = elem.getAttribute('opacity') || 1;
                    var new_opac = Math.round((elem.getAttribute('opacity') || 1) * gattrs.opacity * 100) / 100;
                    changeSelectedAttribute('opacity', new_opac, [elem])
                }
                if (gattrs.filter)
                {
                    var cblur = this.getBlur(elem);
                    var orig_cblur = cblur;
                    if (!gblur)
                    {
                        gblur = this.getBlur(g)
                    }
                    if (cblur)
                    {
                        cblur = Number(gblur) + Number(cblur)
                    }
                    else if (cblur === 0)
                    {
                        cblur = gblur
                    }
                    if (!orig_cblur)
                    {
                        if (!gfilter)
                        {
                            gfilter = svgedit.utilities.getRefElem(gattrs.filter)
                        }
                        else
                        {
                            gfilter = copyElem(gfilter);
                            svgedit.utilities.findDefs().appendChild(gfilter)
                        }
                    }
                    else
                    {
                        gfilter = svgedit.utilities.getRefElem(elem.getAttribute('filter'))
                    }
                    var suffix = (gfilter.firstChild.tagName === 'feGaussianBlur') ? 'blur' : 'filter';
                    gfilter.id = elem.id + '_' + suffix;
                    changeSelectedAttribute('filter', 'url(#' + gfilter.id + ')', [elem]);
                    if (cblur)
                    {
                        changeSelectedAttribute('stdDeviation', cblur, [gfilter.firstChild]);
                        canvas.setBlurOffsets(gfilter, cblur)
                    }
                }
                var chtlist = svgedit.transformlist.getTransformList(elem);
                if (~elem.tagName.indexOf('Gradient'))
                {
                    chtlist = null
                }
                if (!chtlist)
                {
                    continue
                }
                if (elem.tagName === 'defs')
                {
                    continue
                }
                if (glist.numberOfItems)
                {
                    if (gangle && glist.numberOfItems == 1)
                    {
                        var rgm = glist.getItem(0).matrix;
                        var rcm = svgroot.createSVGMatrix();
                        var cangle = svgedit.utilities.getRotationAngle(elem);
                        if (cangle)
                        {
                            rcm = chtlist.getItem(0).matrix
                        }
                        var cbox = svgedit.utilities.getBBox(elem);
                        var ceqm = svgedit.math.transformListToTransform(chtlist).matrix;
                        var coldc = svgedit.math.transformPoint(cbox.x + cbox.width / 2, cbox.y + cbox.height / 2, ceqm);
                        var sangle = gangle + cangle;
                        var r2 = svgroot.createSVGTransform();
                        r2.setRotate(sangle, coldc.x, coldc.y);
                        var trm = svgedit.math.matrixMultiply(rgm, rcm, r2.matrix.inverse());
                        if (cangle)
                        {
                            chtlist.removeItem(0)
                        }
                        if (sangle)
                        {
                            if (chtlist.numberOfItems)
                            {
                                chtlist.insertItemBefore(r2, 0)
                            }
                            else
                            {
                                chtlist.appendItem(r2)
                            }
                        }
                        if (trm.e || trm.f)
                        {
                            var tr = svgroot.createSVGTransform();
                            tr.setTranslate(trm.e, trm.f);
                            if (chtlist.numberOfItems)
                            {
                                chtlist.insertItemBefore(tr, 0)
                            }
                            else
                            {
                                chtlist.appendItem(tr)
                            }
                        }
                    }
                    else
                    {
                        var oldxform = elem.getAttribute("transform");
                        changes = {};
                        changes.transform = oldxform || '';
                        var newxform = svgroot.createSVGTransform();
                        var chm = svgedit.math.transformListToTransform(chtlist).matrix,
                            chm_inv = chm.inverse();
                        var gm = svgedit.math.matrixMultiply(chm_inv, m, chm);
                        newxform.setMatrix(gm);
                        chtlist.appendItem(newxform)
                    }
                    var cmd = svgedit.recalculate.recalculateDimensions(elem);
                    if (cmd)
                    {
                        batchCmd.addSubCommand(cmd)
                    }
                }
            }
            if (xform)
            {
                changes = {};
                changes["transform"] = xform;
                g.setAttribute("transform", "");
                g.removeAttribute("transform");
                batchCmd.addSubCommand(new svgedit.history.ChangeElementCommand(g, changes))
            }
            if (undoable && !batchCmd.isEmpty())
            {
                return batchCmd
            }
        };
    this.ungroupSelectedElement = function()
    {
        var g = selectedElements[0];
        if ($(g).data('gsvg') || $(g).data('symbol'))
        {
            convertToGroup(g);
            return
        }
        if (g.tagName === 'use')
        {
            var symbol = svgedit.utilities.getElem(getHref(g).substr(1));
            $(g).data('symbol', symbol).data('ref', symbol);
            convertToGroup(g);
            return
        }
        var parents_a = $(g).parents('a');
        if (parents_a.length)
        {
            g = parents_a[0]
        }
        if (g.tagName === "g" || g.tagName === "a")
        {
            var batchCmd = new svgedit.history.BatchCommand("Ungroup Elements");
            var cmd = pushGroupProperties(g, true);
            if (cmd)
            {
                batchCmd.addSubCommand(cmd)
            }
            var parent = g.parentNode;
            var anchor = g.nextSibling;
            var children = new Array(g.childNodes.length);
            var i = 0;
            while (g.firstChild)
            {
                var elem = g.firstChild;
                var oldNextSibling = elem.nextSibling;
                var oldParent = elem.parentNode;
                if (elem.tagName === 'title')
                {
                    var nextSibling = elem.nextSibling;
                    batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(elem, nextSibling, oldParent));
                    oldParent.removeChild(elem);
                    continue
                }
                children[i++] = elem = parent.insertBefore(elem, anchor);
                batchCmd.addSubCommand(new svgedit.history.MoveElementCommand(elem, oldNextSibling, oldParent))
            }
            clearSelection();
            var gNextSibling = g.nextSibling;
            g = parent.removeChild(g);
            batchCmd.addSubCommand(new svgedit.history.RemoveElementCommand(g, gNextSibling, parent));
            if (!batchCmd.isEmpty())
            {
                addCommandToHistory(batchCmd)
            }
            addToSelection(children)
        }
    };
    this.moveToTopSelectedElement = function()
    {
        var selected = selectedElements[0];
        if (selected != null)
        {
            var t = selected;
            var oldParent = t.parentNode;
            var oldNextSibling = t.nextSibling;
            t = t.parentNode.appendChild(t);
            if (oldNextSibling != t.nextSibling)
            {
                addCommandToHistory(new svgedit.history.MoveElementCommand(t, oldNextSibling, oldParent, "top"));
                call("changed", [t])
            }
        }
    };
    this.moveToBottomSelectedElement = function()
    {
        var selected = selectedElements[0];
        if (selected != null)
        {
            var t = selected;
            var oldParent = t.parentNode;
            var oldNextSibling = t.nextSibling;
            var firstChild = t.parentNode.firstChild;
            if (firstChild.tagName == 'title')
            {
                firstChild = firstChild.nextSibling
            }
            if (firstChild.tagName == 'defs')
            {
                firstChild = firstChild.nextSibling
            }
            t = t.parentNode.insertBefore(t, firstChild);
            if (oldNextSibling != t.nextSibling)
            {
                addCommandToHistory(new svgedit.history.MoveElementCommand(t, oldNextSibling, oldParent, "bottom"));
                call("changed", [t])
            }
        }
    };
    this.moveUpDownSelected = function(dir)
    {
        var selected = selectedElements[0];
        if (!selected)
        {
            return
        }
        curBBoxes = [];
        var closest,
            found_cur;
        var list = $(getIntersectionList(getStrokedBBox([selected]))).toArray();
        if (dir == 'Down')
        {
            list.reverse()
        }
        $.each(list, function()
        {
            if (!found_cur)
            {
                if (this == selected)
                {
                    found_cur = true
                }
                return
            }
            closest = this;
            return false
        });
        if (!closest)
        {
            return
        }
        var t = selected;
        var oldParent = t.parentNode;
        var oldNextSibling = t.nextSibling;
        $(closest)[dir == 'Down' ? 'before' : 'after'](t);
        if (oldNextSibling != t.nextSibling)
        {
            addCommandToHistory(new svgedit.history.MoveElementCommand(t, oldNextSibling, oldParent, "Move " + dir));
            call("changed", [t])
        }
    };
    this.moveSelectedElements = function(dx, dy, undoable)
    {
        if (dx.constructor != Array)
        {
            dx /= current_zoom;
            dy /= current_zoom
        }
        undoable = undoable || true;
        var batchCmd = new svgedit.history.BatchCommand("position");
        var i = selectedElements.length;
        while (i--)
        {
            var selected = selectedElements[i];
            if (selected != null)
            {
                var xform = svgroot.createSVGTransform();
                var tlist = svgedit.transformlist.getTransformList(selected);
                if (dx.constructor == Array)
                {
                    xform.setTranslate(dx[i], dy[i])
                }
                else
                {
                    xform.setTranslate(dx, dy)
                }
                if (tlist.numberOfItems)
                {
                    tlist.insertItemBefore(xform, 0)
                }
                else
                {
                    tlist.appendItem(xform)
                }
                var cmd = svgedit.recalculate.recalculateDimensions(selected);
                if (cmd)
                {
                    batchCmd.addSubCommand(cmd)
                }
                selectorManager.requestSelector(selected).resize()
            }
        }
        if (!batchCmd.isEmpty())
        {
            if (undoable)
            {
                addCommandToHistory(batchCmd)
            }
            call("changed", selectedElements);
            return batchCmd
        }
    };
    this.cloneSelectedElements = function(x, y)
    {
        var i,
            elem;
        var batchCmd = new svgedit.history.BatchCommand("Clone Elements");
        var len = selectedElements.length;
        function sortfunction(a, b)
        {
            return ($(b).index() - $(a).index())
        }
        selectedElements.sort(sortfunction);
        for (i = 0; i < len; ++i)
        {
            elem = selectedElements[i];
            if (elem == null)
            {
                break
            }
        }
        var copiedElements = selectedElements.slice(0, i);
        this.clearSelection(true);
        i = copiedElements.length;
        while (i--)
        {
            elem = copiedElements[i] = copyElem(copiedElements[i]);
            (current_group || getCurrentDrawing().getCurrentLayer()).appendChild(elem);
            batchCmd.addSubCommand(new svgedit.history.InsertElementCommand(elem))
        }
        if (!batchCmd.isEmpty())
        {
            addToSelection(copiedElements.reverse());
            this.moveSelectedElements(x, y, false);
            addCommandToHistory(batchCmd)
        }
    };
    this.alignSelectedElements = function(type, relative_to)
    {
        var i,
            elem;
        var bboxes = [],
            angles = [];
        var minx = Number.MAX_VALUE,
            maxx = Number.MIN_VALUE,
            miny = Number.MAX_VALUE,
            maxy = Number.MIN_VALUE;
        var curwidth = Number.MIN_VALUE,
            curheight = Number.MIN_VALUE;
        var len = selectedElements.length;
        if (!len)
        {
            return
        }
        for (i = 0; i < len; ++i)
        {
            if (selectedElements[i] == null)
            {
                break
            }
            elem = selectedElements[i];
            bboxes[i] = getStrokedBBox([elem]);
            switch (relative_to)
            {
                case'smallest':
                    if ((type == 'l' || type == 'c' || type == 'r') && (curwidth == Number.MIN_VALUE || curwidth > bboxes[i].width) || (type == 't' || type == 'm' || type == 'b') && (curheight == Number.MIN_VALUE || curheight > bboxes[i].height))
                    {
                        minx = bboxes[i].x;
                        miny = bboxes[i].y;
                        maxx = bboxes[i].x + bboxes[i].width;
                        maxy = bboxes[i].y + bboxes[i].height;
                        curwidth = bboxes[i].width;
                        curheight = bboxes[i].height
                    }
                    break;
                case'largest':
                    if ((type == 'l' || type == 'c' || type == 'r') && (curwidth == Number.MIN_VALUE || curwidth < bboxes[i].width) || (type == 't' || type == 'm' || type == 'b') && (curheight == Number.MIN_VALUE || curheight < bboxes[i].height))
                    {
                        minx = bboxes[i].x;
                        miny = bboxes[i].y;
                        maxx = bboxes[i].x + bboxes[i].width;
                        maxy = bboxes[i].y + bboxes[i].height;
                        curwidth = bboxes[i].width;
                        curheight = bboxes[i].height
                    }
                    break;
                default:
                    if (bboxes[i].x < minx)
                    {
                        minx = bboxes[i].x
                    }
                    if (bboxes[i].y < miny)
                    {
                        miny = bboxes[i].y
                    }
                    if (bboxes[i].x + bboxes[i].width > maxx)
                    {
                        maxx = bboxes[i].x + bboxes[i].width
                    }
                    if (bboxes[i].y + bboxes[i].height > maxy)
                    {
                        maxy = bboxes[i].y + bboxes[i].height
                    }
                    break
            }
        }
        if (relative_to == 'page')
        {
            minx = 0;
            miny = 0;
            maxx = canvas.contentW;
            maxy = canvas.contentH
        }
        var dx = new Array(len);
        var dy = new Array(len);
        for (i = 0; i < len; ++i)
        {
            if (selectedElements[i] == null)
            {
                break
            }
            elem = selectedElements[i];
            var bbox = bboxes[i];
            dx[i] = 0;
            dy[i] = 0;
            switch (type)
            {
                case'l':
                    dx[i] = minx - bbox.x;
                    break;
                case'c':
                    dx[i] = (minx + maxx) / 2 - (bbox.x + bbox.width / 2);
                    break;
                case'r':
                    dx[i] = maxx - (bbox.x + bbox.width);
                    break;
                case't':
                    dy[i] = miny - bbox.y;
                    break;
                case'm':
                    dy[i] = (miny + maxy) / 2 - (bbox.y + bbox.height / 2);
                    break;
                case'b':
                    dy[i] = maxy - (bbox.y + bbox.height);
                    break
            }
        }
        this.moveSelectedElements(dx, dy)
    };
    this.contentW = getResolution().w;
    this.contentH = getResolution().h;
    this.updateCanvas = function(w, h)
    {
        svgroot.setAttribute("width", w);
        svgroot.setAttribute("height", h);
        var bg = $('#canvasBackground')[0];
        var old_x = svgcontent.getAttribute('x');
        var old_y = svgcontent.getAttribute('y');
        var x = (w / 2 - this.contentW * current_zoom / 2);
        var y = (h / 2 - this.contentH * current_zoom / 2);
        svgedit.utilities.assignAttributes(svgcontent, {
            width: this.contentW * current_zoom, height: this.contentH * current_zoom, x: x, y: y, viewBox: "0 0 " + this.contentW + " " + this.contentH
        });
        svgedit.utilities.assignAttributes(bg, {
            width: svgcontent.getAttribute('width'), height: svgcontent.getAttribute('height'), x: x, y: y
        });
        var bg_img = svgedit.utilities.getElem('background_image');
        if (bg_img)
        {
            svgedit.utilities.assignAttributes(bg_img, {
                width: '100%', height: '100%'
            })
        }
        selectorManager.selectorParentGroup.setAttribute("transform", "translate(" + x + "," + y + ")");
        runExtensions("canvasUpdated", {
            new_x: x, new_y: y, old_x: old_x, old_y: old_y, d_x: x - old_x, d_y: y - old_y
        });
        return {
                x: x, y: y, old_x: old_x, old_y: old_y, d_x: x - old_x, d_y: y - old_y
            }
    };
    this.setBackground = function(color, url)
    {
        var bg = svgedit.utilities.getElem('canvasBackground');
        var border = $(bg).find('rect')[0];
        var bg_img = svgedit.utilities.getElem('background_image');
        border.setAttribute('fill', color);
        if (url)
        {
            if (!bg_img)
            {
                bg_img = svgdoc.createElementNS(NS.SVG, "image");
                svgedit.utilities.assignAttributes(bg_img, {
                    id: 'background_image', width: '100%', height: '100%', preserveAspectRatio: 'xMinYMin', style: 'pointer-events:none'
                })
            }
            setHref(bg_img, url);
            bg.appendChild(bg_img)
        }
        else if (bg_img)
        {
            bg_img.parentNode.removeChild(bg_img)
        }
    };
    this.cycleElement = function(next)
    {
        var num;
        var cur_elem = selectedElements[0];
        var elem = false;
        var all_elems = getVisibleElements(current_group || getCurrentDrawing().getCurrentLayer());
        if (!all_elems.length)
        {
            return
        }
        if (cur_elem == null)
        {
            num = next ? all_elems.length - 1 : 0;
            elem = all_elems[num]
        }
        else
        {
            var i = all_elems.length;
            while (i--)
            {
                if (all_elems[i] == cur_elem)
                {
                    num = next ? i - 1 : i + 1;
                    if (num >= all_elems.length)
                    {
                        num = 0
                    }
                    else if (num < 0)
                    {
                        num = all_elems.length - 1
                    }
                    elem = all_elems[num];
                    break
                }
            }
        }
        selectOnly([elem], true);
        call("selected", selectedElements)
    };
    this.clear();
    this.getPrivateMethods = function()
    {
        var obj = {
                addCommandToHistory: addCommandToHistory, setGradient: setGradient, addSvgElementFromJson: addSvgElementFromJson, assignAttributes: assignAttributes, BatchCommand: BatchCommand, call: call, ChangeElementCommand: ChangeElementCommand, copyElem: copyElem, ffClone: ffClone, findDefs: findDefs, findDuplicateGradient: findDuplicateGradient, getElem: getElem, getId: getId, getIntersectionList: getIntersectionList, getMouseTarget: getMouseTarget, getNextId: getNextId, getPathBBox: getPathBBox, getUrlFromAttr: getUrlFromAttr, hasMatrixTransform: hasMatrixTransform, identifyLayers: identifyLayers, InsertElementCommand: InsertElementCommand, isIdentity: svgedit.math.isIdentity, logMatrix: logMatrix, matrixMultiply: matrixMultiply, MoveElementCommand: MoveElementCommand, preventClickDefault: preventClickDefault, recalculateAllSelectedDimensions: recalculateAllSelectedDimensions, recalculateDimensions: recalculateDimensions, remapElement: remapElement, RemoveElementCommand: RemoveElementCommand, removeUnusedDefElems: removeUnusedDefElems, round: round, runExtensions: runExtensions, sanitizeSvg: sanitizeSvg, SVGEditTransformList: svgedit.transformlist.SVGTransformList, toString: toString, transformBox: svgedit.math.transformBox, transformListToTransform: transformListToTransform, transformPoint: transformPoint, walkTree: svgedit.utilities.walkTree
            };
        return obj
    }
};
(function()
{
    if (window.svgEditor)
    {
        return
    }
    window.svgEditor = (function($)
    {
        var editor = {};
        editor.tool_scale = 1;
        editor.langChanged = false;
        editor.showSaveWarning = false;
        editor.storagePromptClosed = false;
        var svgCanvas,
            urldata,
            Utils = svgedit.utilities,
            isReady = false,
            callbacks = [],
            customHandlers = {},
            defaultPrefs = {
                lang: '', iconsize: '', bkgd_color: '#FFF', bkgd_url: '', img_save: 'embed', save_notice_done: false, export_notice_done: false
            },
            curPrefs = {},
            curConfig = {
                extensions: [], allowedOrigins: []
            },
            defaultExtensions = ['ext-overview_window.js', 'ext-markers.js', 'ext-connector.js', 'ext-eyedropper.js', 'ext-shapes.js', 'ext-imagelib.js', 'ext-grid.js', 'ext-polygon.js', 'ext-star.js', 'ext-panning.js', 'ext-storage.js'],
            defaultConfig = {
                canvasName: 'default', canvas_expansion: 3, initFill: {
                        color: 'FF0000', opacity: 1
                    }, initStroke: {
                        width: 5, color: '000000', opacity: 1
                    }, initOpacity: 1, colorPickerCSS: null, initTool: 'select', wireframe: false, showlayers: false, no_save_warning: false, imgPath: 'images/', langPath: 'locale/', extPath: 'extensions/', jGraduatePath: 'jgraduate/images/', dimensions: [640, 480], gridSnapping: false, gridColor: '#000', baseUnit: 'px', snappingStep: 10, showRulers: true, preventAllURLConfig: false, preventURLContentLoading: false, lockExtensions: false, noDefaultExtensions: false, showGrid: false, noStorageOnLoad: false, forceStorage: false, emptyStorageOnDecline: false
            },
            uiStrings = editor.uiStrings = {
                common: {
                    ok: 'OK', cancel: 'Cancel', key_up: 'Up', key_down: 'Down', key_backspace: 'Backspace', key_del: 'Del'
                }, layers: {layer: 'Layer'}, notification: {
                        invalidAttrValGiven: 'Invalid value given', noContentToFitTo: 'No content to fit to', dupeLayerName: 'There is already a layer named that!', enterUniqueLayerName: 'Please enter a unique layer name', enterNewLayerName: 'Please enter the new layer name', layerHasThatName: 'Layer already has that name', QmoveElemsToLayer: 'Move selected elements to layer \'%s\'?', QwantToClear: 'Do you want to clear the drawing?\nThis will also erase your undo history!', QwantToOpen: 'Do you want to open a new file?\nThis will also erase your undo history!', QerrorsRevertToSource: 'There were parsing errors in your SVG source.\nRevert back to original SVG source?', QignoreSourceChanges: 'Ignore changes made to SVG source?', featNotSupported: 'Feature not supported', enterNewImgURL: 'Enter the new image URL', defsFailOnSave: 'NOTE: Due to a bug in your browser, this image may appear wrong (missing gradients or elements). It will however appear correct once actually saved.', loadingImage: 'Loading image, please wait...', saveFromBrowser: 'Select \'Save As...\' in your browser to save this image as a %s file.', noteTheseIssues: 'Also note the following issues: ', unsavedChanges: 'There are unsaved changes.', enterNewLinkURL: 'Enter the new hyperlink URL', errorLoadingSVG: 'Error: Unable to load SVG data', URLloadFail: 'Unable to load from URL', retrieving: 'Retrieving \'%s\' ...'
                    }
            };
        function loadSvgString(str, callback)
        {
            var success = svgCanvas.setSvgString(str) !== false;
            callback = callback || $.noop;
            if (success)
            {
                callback(true)
            }
            else
            {
                $.alert(uiStrings.notification.errorLoadingSVG, function()
                {
                    callback(false)
                })
            }
        }
        $.pref = function(key, val)
        {
            if (val)
            {
                curPrefs[key] = val;
                editor.curPrefs = curPrefs;
                return
            }
            return (key in curPrefs) ? curPrefs[key] : defaultPrefs[key]
        };
        editor.loadContentAndPrefs = function()
        {
            if (!curConfig.forceStorage && (curConfig.noStorageOnLoad || !document.cookie.match(/(?:^|;\s*)store=(?:prefsAndContent|prefsOnly)/)))
            {
                return
            }
            if (editor.storage && (curConfig.forceStorage || (!curConfig.noStorageOnLoad && document.cookie.match(/(?:^|;\s*)store=prefsAndContent/))))
            {
                var name = 'svgedit-' + curConfig.canvasName;
                var cached = editor.storage.getItem(name);
                if (cached)
                {
                    editor.loadFromString(cached)
                }
            }
            var key;
            for (key in defaultPrefs)
            {
                if (defaultPrefs.hasOwnProperty(key))
                {
                    var storeKey = 'svg-edit-' + key;
                    if (editor.storage)
                    {
                        var val = editor.storage.getItem(storeKey);
                        if (val)
                        {
                            defaultPrefs[key] = String(val)
                        }
                    }
                    else if (window.widget)
                    {
                        defaultPrefs[key] = widget.preferenceForKey(storeKey)
                    }
                    else
                    {
                        var result = document.cookie.match(new RegExp('(?:^|;\\s*)' + Utils.preg_quote(encodeURIComponent(storeKey)) + '=([^;]+)'));
                        defaultPrefs[key] = result ? decodeURIComponent(result[1]) : ''
                    }
                }
            }
        };
        editor.setConfig = function(opts, cfgCfg)
        {
            cfgCfg = cfgCfg || {};
            function extendOrAdd(cfgObj, key, val)
            {
                if (cfgObj[key] && typeof cfgObj[key] === 'object')
                {
                    $.extend(true, cfgObj[key], val)
                }
                else
                {
                    cfgObj[key] = val
                }
                return
            }
            $.each(opts, function(key, val)
            {
                if (opts.hasOwnProperty(key))
                {
                    if (defaultPrefs.hasOwnProperty(key))
                    {
                        if (cfgCfg.overwrite === false && (curConfig.preventAllURLConfig || curPrefs.hasOwnProperty(key)))
                        {
                            return
                        }
                        if (cfgCfg.allowInitialUserOverride === true)
                        {
                            defaultPrefs[key] = val
                        }
                        else
                        {
                            $.pref(key, val)
                        }
                    }
                    else if (['extensions', 'allowedOrigins'].indexOf(key) > -1)
                    {
                        if (cfgCfg.overwrite === false && (curConfig.preventAllURLConfig || key === 'allowedOrigins' || (key === 'extensions' && curConfig.lockExtensions)))
                        {
                            return
                        }
                        curConfig[key] = curConfig[key].concat(val)
                    }
                    else if (defaultConfig.hasOwnProperty(key))
                    {
                        if (cfgCfg.overwrite === false && (curConfig.preventAllURLConfig || curConfig.hasOwnProperty(key)))
                        {
                            return
                        }
                        if (curConfig.hasOwnProperty(key))
                        {
                            if (cfgCfg.overwrite === false)
                            {
                                return
                            }
                            extendOrAdd(curConfig, key, val)
                        }
                        else
                        {
                            if (cfgCfg.allowInitialUserOverride === true)
                            {
                                extendOrAdd(defaultConfig, key, val)
                            }
                            else
                            {
                                if (defaultConfig[key] && typeof defaultConfig[key] === 'object')
                                {
                                    curConfig[key] = {};
                                    $.extend(true, curConfig[key], val)
                                }
                                else
                                {
                                    curConfig[key] = val
                                }
                            }
                        }
                    }
                }
            });
            editor.curConfig = curConfig
        };
        editor.setCustomHandlers = function(opts)
        {
            editor.ready(function()
            {
                if (opts.open)
                {
                    $('#tool_open > input[type="file"]').remove();
                    $('#tool_open').show();
                    svgCanvas.open = opts.open
                }
                if (opts.save)
                {
                    editor.showSaveWarning = false;
                    svgCanvas.bind('saved', opts.save)
                }
                if (opts.exportImage || opts.pngsave)
                {
                    svgCanvas.bind('exported', opts.exportImage || opts.pngsave)
                }
                customHandlers = opts
            })
        };
        editor.randomizeIds = function()
        {
            svgCanvas.randomizeIds(arguments)
        };
        editor.init = function()
        {
            try
            {
                if ('localStorage' in window)
                {
                    editor.storage = localStorage
                }
            }
            catch(err) {}
            var good_langs = [];
            $('#lang_select option').each(function()
            {
                good_langs.push(this.value)
            });
            function setupCurPrefs()
            {
                curPrefs = $.extend(true, {}, defaultPrefs, curPrefs);
                editor.curPrefs = curPrefs
            }
            function setupCurConfig()
            {
                curConfig = $.extend(true, {}, defaultConfig, curConfig);
                if (!curConfig.noDefaultExtensions)
                {
                    curConfig.extensions = curConfig.extensions.concat(defaultExtensions)
                }
                $.each(['extensions', 'allowedOrigins'], function(i, cfg)
                {
                    curConfig[cfg] = $.grep(curConfig[cfg], function(n, i)
                    {
                        return i === curConfig[cfg].indexOf(n)
                    })
                });
                editor.curConfig = curConfig
            }
            (function()
            {
                var src,
                    qstr;
                urldata = $.deparam.querystring(true);
                if (!$.isEmptyObject(urldata))
                {
                    if (urldata.dimensions)
                    {
                        urldata.dimensions = urldata.dimensions.split(',')
                    }
                    if (urldata.bkgd_color)
                    {
                        urldata.bkgd_color = '#' + urldata.bkgd_color
                    }
                    if (urldata.extensions)
                    {
                        urldata.extensions = urldata.extensions.match(/[:\/\\]/) ? '' : urldata.extensions.split(',')
                    }
                    $.each(['extPath', 'imgPath', 'langPath', 'jGraduatePath'], function(pathConfig)
                    {
                        if (urldata[pathConfig])
                        {
                            delete urldata[pathConfig]
                        }
                    });
                    editor.setConfig(urldata, {overwrite: false});
                    setupCurConfig();
                    if (!curConfig.preventURLContentLoading)
                    {
                        src = urldata.source;
                        qstr = $.param.querystring();
                        if (!src)
                        {
                            if (qstr.indexOf('source=data:') >= 0)
                            {
                                src = qstr.match(/source=(data:[^&]*)/)[1]
                            }
                        }
                        if (src)
                        {
                            if (src.indexOf('data:') === 0)
                            {
                                src = src.replace(/ /g, '+');
                                editor.loadFromDataURI(src)
                            }
                            else
                            {
                                editor.loadFromString(src)
                            }
                            return
                        }
                        if (qstr.indexOf('paramurl=') !== -1)
                        {
                            editor.loadFromURL(qstr.substr(9));
                            return
                        }
                        if (urldata.url)
                        {
                            editor.loadFromURL(urldata.url);
                            return
                        }
                    }
                    if (!urldata.noStorageOnLoad || curConfig.forceStorage)
                    {
                        editor.loadContentAndPrefs()
                    }
                    setupCurPrefs()
                }
                else
                {
                    setupCurConfig();
                    editor.loadContentAndPrefs();
                    setupCurPrefs()
                }
            }());
            (function()
            {
                var svgEditorReadyEvent,
                    w = window.opener;
                if (w)
                {
                    try
                    {
                        svgEditorReadyEvent = w.document.createEvent('Event');
                        svgEditorReadyEvent.initEvent('svgEditorReady', true, true);
                        w.document.documentElement.dispatchEvent(svgEditorReadyEvent)
                    }
                    catch(e) {}
                }
            }());
            var setIcon = editor.setIcon = function(elem, icon_id, forcedSize)
                {
                    var icon = (typeof icon_id === 'string') ? $.getSvgIcon(icon_id, true) : icon_id.clone();
                    if (!icon)
                    {
                        return
                    }
                    $(elem).empty().append(icon)
                };
            var extFunc = function()
                {
                    $.each(curConfig.extensions, function()
                    {
                        var extname = this;
                        if (!extname.match(/^ext-.*\.js/))
                        {
                            return
                        }
                        $.getScript(curConfig.extPath + extname, function(d)
                        {
                            if (!d)
                            {
                                var s = document.createElement('script');
                                s.src = curConfig.extPath + extname;
                                document.querySelector('head').appendChild(s)
                            }
                        })
                    });
                    editor.putLocale(null, good_langs)
                };
            if (document.location.protocol === 'file:')
            {
                setTimeout(extFunc, 100)
            }
            else
            {
                extFunc()
            }
            $.svgIcons(curConfig.imgPath + 'svg_edit_icons.svg', {
                w: 24, h: 24, id_match: false, no_img: !svgedit.browser.isWebkit(), fallback_path: curConfig.imgPath, fallback: {
                        new_image: 'clear.png', save: 'save.png', open: 'open.png', source: 'source.png', docprops: 'document-properties.png', wireframe: 'wireframe.png', undo: 'undo.png', redo: 'redo.png', select: 'select.png', select_node: 'select_node.png', pencil: 'fhpath.png', pen: 'line.png', square: 'square.png', rect: 'rect.png', fh_rect: 'freehand-square.png', circle: 'circle.png', ellipse: 'ellipse.png', fh_ellipse: 'freehand-circle.png', path: 'path.png', text: 'text.png', image: 'image.png', zoom: 'zoom.png', clone: 'clone.png', node_clone: 'node_clone.png', 'delete': 'delete.png', node_delete: 'node_delete.png', group: 'shape_group_elements.png', ungroup: 'shape_ungroup.png', move_top: 'move_top.png', move_bottom: 'move_bottom.png', to_path: 'to_path.png', link_controls: 'link_controls.png', reorient: 'reorient.png', align_left: 'align-left.png', align_center: 'align-center.png', align_right: 'align-right.png', align_top: 'align-top.png', align_middle: 'align-middle.png', align_bottom: 'align-bottom.png', go_up: 'go-up.png', go_down: 'go-down.png', ok: 'save.png', cancel: 'cancel.png', arrow_right: 'flyouth.png', arrow_down: 'dropdown.gif'
                    }, placement: {
                        '#logo': 'logo', '#tool_clear div,#layer_new': 'new_image', '#tool_save div': 'save', '#tool_export div': 'export', '#tool_open div div': 'open', '#tool_import div div': 'import', '#tool_source': 'source', '#tool_docprops > div': 'docprops', '#tool_wireframe': 'wireframe', '#tool_undo': 'undo', '#tool_redo': 'redo', '#tool_select': 'select', '#tool_fhpath': 'pencil', '#tool_line': 'pen', '#tool_rect,#tools_rect_show': 'rect', '#tool_square': 'square', '#tool_fhrect': 'fh_rect', '#tool_ellipse,#tools_ellipse_show': 'ellipse', '#tool_circle': 'circle', '#tool_fhellipse': 'fh_ellipse', '#tool_path': 'path', '#tool_text,#layer_rename': 'text', '#tool_image': 'image', '#tool_zoom': 'zoom', '#tool_clone,#tool_clone_multi': 'clone', '#tool_node_clone': 'node_clone', '#layer_delete,#tool_delete,#tool_delete_multi': 'delete', '#tool_node_delete': 'node_delete', '#tool_add_subpath': 'add_subpath', '#tool_openclose_path': 'open_path', '#tool_move_top': 'move_top', '#tool_move_bottom': 'move_bottom', '#tool_topath': 'to_path', '#tool_node_link': 'link_controls', '#tool_reorient': 'reorient', '#tool_group_elements': 'group_elements', '#tool_ungroup': 'ungroup', '#tool_unlink_use': 'unlink_use', '#tool_alignleft, #tool_posleft': 'align_left', '#tool_aligncenter, #tool_poscenter': 'align_center', '#tool_alignright, #tool_posright': 'align_right', '#tool_aligntop, #tool_postop': 'align_top', '#tool_alignmiddle, #tool_posmiddle': 'align_middle', '#tool_alignbottom, #tool_posbottom': 'align_bottom', '#cur_position': 'align', '#linecap_butt,#cur_linecap': 'linecap_butt', '#linecap_round': 'linecap_round', '#linecap_square': 'linecap_square', '#linejoin_miter,#cur_linejoin': 'linejoin_miter', '#linejoin_round': 'linejoin_round', '#linejoin_bevel': 'linejoin_bevel', '#url_notice': 'warning', '#layer_up': 'go_up', '#layer_down': 'go_down', '#layer_moreopts': 'context_menu', '#layerlist td.layervis': 'eye', '#tool_source_save,#tool_docprops_save,#tool_prefs_save': 'ok', '#tool_source_cancel,#tool_docprops_cancel,#tool_prefs_cancel': 'cancel', '#rwidthLabel, #iwidthLabel': 'width', '#rheightLabel, #iheightLabel': 'height', '#cornerRadiusLabel span': 'c_radius', '#angleLabel': 'angle', '#linkLabel,#tool_make_link,#tool_make_link_multi': 'globe_link', '#zoomLabel': 'zoom', '#tool_fill label': 'fill', '#tool_stroke .icon_label': 'stroke', '#group_opacityLabel': 'opacity', '#blurLabel': 'blur', '#font_sizeLabel': 'fontsize', '.flyout_arrow_horiz': 'arrow_right', '.dropdown button, #main_button .dropdown': 'arrow_down', '#palette .palette_item:first, #fill_bg, #stroke_bg': 'no_color'
                    }, resize: {
                        '#logo .svg_icon': 28, '.flyout_arrow_horiz .svg_icon': 5, '.layer_button .svg_icon, #layerlist td.layervis .svg_icon': 14, '.dropdown button .svg_icon': 7, '#main_button .dropdown .svg_icon': 9, '.palette_item:first .svg_icon': 15, '#fill_bg .svg_icon, #stroke_bg .svg_icon': 16, '.toolbar_button button .svg_icon': 16, '.stroke_tool div div .svg_icon': 20, '#tools_bottom label .svg_icon': 18
                    }, callback: function(icons)
                    {
                        $('.toolbar_button button > svg, .toolbar_button button > img').each(function()
                        {
                            $(this).parent().prepend(this)
                        });
                        var min_height,
                            tleft = $('#tools_left');
                        if (tleft.length !== 0)
                        {
                            min_height = tleft.offset().top + tleft.outerHeight()
                        }
                        var size = $.pref('iconsize');
                        editor.setIconSize(size || ($(window).height() < min_height ? 's' : 'm'));
                        $('.tools_flyout').each(function()
                        {
                            var shower = $('#' + this.id + '_show');
                            var sel = shower.attr('data-curopt');
                            if (!shower.children('svg, img').length)
                            {
                                var clone = $(sel).children().clone();
                                if (clone.length)
                                {
                                    clone[0].removeAttribute('style');
                                    shower.append(clone)
                                }
                            }
                        });
                        editor.runCallbacks();
                        setTimeout(function()
                        {
                            $('.flyout_arrow_horiz:empty').each(function()
                            {
                                $(this).append($.getSvgIcon('arrow_right').width(5).height(5))
                            })
                        }, 1)
                    }
            });
            editor.canvas = svgCanvas = new $.SvgCanvas(document.getElementById('svgcanvas'), curConfig);
            var supportsNonSS,
                resize_timer,
                changeZoom,
                Actions,
                curScrollPos,
                palette = ['#000000', '#3f3f3f', '#7f7f7f', '#bfbfbf', '#ffffff', '#ff0000', '#ff7f00', '#ffff00', '#7fff00', '#00ff00', '#00ff7f', '#00ffff', '#007fff', '#0000ff', '#7f00ff', '#ff00ff', '#ff007f', '#7f0000', '#7f3f00', '#7f7f00', '#3f7f00', '#007f00', '#007f3f', '#007f7f', '#003f7f', '#00007f', '#3f007f', '#7f007f', '#7f003f', '#ffaaaa', '#ffd4aa', '#ffffaa', '#d4ffaa', '#aaffaa', '#aaffd4', '#aaffff', '#aad4ff', '#aaaaff', '#d4aaff', '#ffaaff', '#ffaad4'],
                modKey = (svgedit.browser.isMac() ? 'meta+' : 'ctrl+'),
                path = svgCanvas.pathActions,
                undoMgr = svgCanvas.undoMgr,
                defaultImageURL = curConfig.imgPath + 'logo.png',
                workarea = $('#workarea'),
                canv_menu = $('#cmenu_canvas'),
                exportWindow = null,
                zoomInIcon = 'crosshair',
                zoomOutIcon = 'crosshair',
                ui_context = 'toolbars',
                origSource = '',
                paintBox = {
                    fill: null, stroke: null
                };
            (function()
            {
                $('#dialog_container').draggable({
                    cancel: '#dialog_content, #dialog_buttons *', containment: 'window'
                });
                var box = $('#dialog_box'),
                    btn_holder = $('#dialog_buttons'),
                    dialog_content = $('#dialog_content'),
                    dbox = function(type, msg, callback, defaultVal, opts, changeCb, checkbox)
                    {
                        var ok,
                            ctrl,
                            chkbx;
                        dialog_content.html('<p>' + msg.replace(/\n/g, '</p><p>') + '</p>').toggleClass('prompt', (type == 'prompt'));
                        btn_holder.empty();
                        ok = $('<input type="button" value="' + uiStrings.common.ok + '">').appendTo(btn_holder);
                        if (type !== 'alert')
                        {
                            $('<input type="button" value="' + uiStrings.common.cancel + '">').appendTo(btn_holder).click(function()
                            {
                                box.hide();
                                callback(false)
                            })
                        }
                        if (type === 'prompt')
                        {
                            ctrl = $('<input type="text">').prependTo(btn_holder);
                            ctrl.val(defaultVal || '');
                            ctrl.bind('keydown', 'return', function()
                            {
                                ok.click()
                            })
                        }
                        else if (type === 'select')
                        {
                            var div = $('<div style="text-align:center;">');
                            ctrl = $('<select>').appendTo(div);
                            if (checkbox)
                            {
                                var label = $('<label>').text(checkbox.label);
                                chkbx = $('<input type="checkbox">').appendTo(label);
                                chkbx.val(checkbox.value);
                                if (checkbox.tooltip)
                                {
                                    label.attr('title', checkbox.tooltip)
                                }
                                chkbx.prop('checked', !!checkbox.checked);
                                div.append($('<div>').append(label))
                            }
                            $.each(opts || [], function(opt, val)
                            {
                                if (typeof val === 'object')
                                {
                                    ctrl.append($('<option>').val(val.value).html(val.text))
                                }
                                else
                                {
                                    ctrl.append($('<option>').html(val))
                                }
                            });
                            dialog_content.append(div);
                            if (defaultVal)
                            {
                                ctrl.val(defaultVal)
                            }
                            if (changeCb)
                            {
                                ctrl.bind('change', 'return', changeCb)
                            }
                            ctrl.bind('keydown', 'return', function()
                            {
                                ok.click()
                            })
                        }
                        if (type === 'process')
                        {
                            ok.hide()
                        }
                        box.show();
                        ok.click(function()
                        {
                            box.hide();
                            var resp = (type === 'prompt' || type === 'select') ? ctrl.val() : true;
                            if (callback)
                            {
                                if (chkbx)
                                {
                                    callback(resp, chkbx.prop('checked'))
                                }
                                else
                                {
                                    callback(resp)
                                }
                            }
                        }).focus();
                        if (type === 'prompt' || type === 'select')
                        {
                            ctrl.focus()
                        }
                    };
                $.alert = function(msg, cb)
                {
                    dbox('alert', msg, cb)
                };
                $.confirm = function(msg, cb)
                {
                    dbox('confirm', msg, cb)
                };
                $.process_cancel = function(msg, cb)
                {
                    dbox('process', msg, cb)
                };
                $.prompt = function(msg, txt, cb)
                {
                    dbox('prompt', msg, cb, txt)
                };
                $.select = function(msg, opts, cb, changeCb, txt, checkbox)
                {
                    dbox('select', msg, cb, txt, opts, changeCb, checkbox)
                }
            }());
            var setSelectMode = function()
                {
                    var curr = $('.tool_button_current');
                    if (curr.length && curr[0].id !== 'tool_select')
                    {
                        curr.removeClass('tool_button_current').addClass('tool_button');
                        $('#tool_select').addClass('tool_button_current').removeClass('tool_button');
                        $('#styleoverrides').text('#svgcanvas svg *{cursor:move;pointer-events:all} #svgcanvas svg{cursor:default}')
                    }
                    svgCanvas.setMode('select');
                    workarea.css('cursor', 'auto')
                };
            var textBeingEntered = false;
            var selectedElement = null;
            var multiselected = false;
            var editingsource = false;
            var docprops = false;
            var preferences = false;
            var cur_context = '';
            var origTitle = $('title:first').text();
            var r_intervals = [];
            var i;
            for (i = 0.1; i < 1E5; i *= 10)
            {
                r_intervals.push(i);
                r_intervals.push(2 * i);
                r_intervals.push(5 * i)
            }
            var toggleHighlightLayer = function(layerNameToHighlight)
                {
                    var i,
                        curNames = [],
                        numLayers = svgCanvas.getCurrentDrawing().getNumLayers();
                    for (i = 0; i < numLayers; i++)
                    {
                        curNames[i] = svgCanvas.getCurrentDrawing().getLayerName(i)
                    }
                    if (layerNameToHighlight)
                    {
                        for (i = 0; i < numLayers; ++i)
                        {
                            if (curNames[i] != layerNameToHighlight)
                            {
                                svgCanvas.getCurrentDrawing().setLayerOpacity(curNames[i], 0.5)
                            }
                        }
                    }
                    else
                    {
                        for (i = 0; i < numLayers; ++i)
                        {
                            svgCanvas.getCurrentDrawing().setLayerOpacity(curNames[i], 1.0)
                        }
                    }
                };
            var populateLayers = function()
                {
                    svgCanvas.clearSelection();
                    var layerlist = $('#layerlist tbody').empty();
                    var selLayerNames = $('#selLayerNames').empty();
                    var drawing = svgCanvas.getCurrentDrawing();
                    var currentLayerName = drawing.getCurrentLayerName();
                    var layer = svgCanvas.getCurrentDrawing().getNumLayers();
                    var icon = $.getSvgIcon('eye');
                    while (layer--)
                    {
                        var name = drawing.getLayerName(layer);
                        var layerTr = $('<tr class="layer">').toggleClass('layersel', name === currentLayerName);
                        var layerVis = $('<td class="layervis">').toggleClass('layerinvis', !drawing.getLayerVisibility(name));
                        var layerName = $('<td class="layername">' + name + '</td>');
                        layerlist.append(layerTr.append(layerVis, layerName));
                        selLayerNames.append('<option value="' + name + '">' + name + '</option>')
                    }
                    if (icon !== undefined)
                    {
                        var copy = icon.clone();
                        $('td.layervis', layerlist).append(copy);
                        $.resizeSvgIcons({'td.layervis .svg_icon': 14})
                    }
                    $('#layerlist td.layername').mouseup(function(evt)
                    {
                        $('#layerlist tr.layer').removeClass('layersel');
                        $(this.parentNode).addClass('layersel');
                        svgCanvas.setCurrentLayer(this.textContent);
                        evt.preventDefault()
                    }).mouseover(function()
                    {
                        toggleHighlightLayer(this.textContent)
                    }).mouseout(function()
                    {
                        toggleHighlightLayer()
                    });
                    $('#layerlist td.layervis').click(function()
                    {
                        var row = $(this.parentNode).prevAll().length;
                        var name = $('#layerlist tr.layer:eq(' + row + ') td.layername').text();
                        var vis = $(this).hasClass('layerinvis');
                        svgCanvas.setLayerVisibility(name, vis);
                        $(this).toggleClass('layerinvis')
                    });
                    var num = 5 - $('#layerlist tr.layer').size();
                    while (num-- > 0)
                    {
                        layerlist.append('<tr><td style="color:white">_</td><td/></tr>')
                    }
                };
            var showSourceEditor = function(e, forSaving)
                {
                    if (editingsource)
                    {
                        return
                    }
                    editingsource = true;
                    origSource = svgCanvas.getSvgString();
                    $('#save_output_btns').toggle(!!forSaving);
                    $('#tool_source_back').toggle(!forSaving);
                    $('#svg_source_textarea').val(origSource);
                    $('#svg_source_editor').fadeIn();
                    $('#svg_source_textarea').focus()
                };
            var togglePathEditMode = function(editmode, elems)
                {
                    $('#path_node_panel').toggle(editmode);
                    $('#tools_bottom_2,#tools_bottom_3').toggle(!editmode);
                    if (editmode)
                    {
                        $('.tool_button_current').removeClass('tool_button_current').addClass('tool_button');
                        $('#tool_select').addClass('tool_button_current').removeClass('tool_button');
                        setIcon('#tool_select', 'select_node');
                        multiselected = false;
                        if (elems.length)
                        {
                            selectedElement = elems[0]
                        }
                    }
                    else
                    {
                        setTimeout(function()
                        {
                            setIcon('#tool_select', 'select')
                        }, 1000)
                    }
                };
            var saveHandler = function(wind, svg)
                {
                    editor.showSaveWarning = false;
                    svg = '<?xml version="1.0"?>\n' + svg;
                    if (svgedit.browser.isIE())
                    {
                        showSourceEditor(0, true);
                        return
                    }
                    var win = wind.open('data:image/svg+xml;base64,' + Utils.encode64(svg));
                    var done = $.pref('save_notice_done');
                    if (done !== 'all')
                    {
                        var note = uiStrings.notification.saveFromBrowser.replace('%s', 'SVG');
                        if (svgedit.browser.isGecko())
                        {
                            if (svg.indexOf('<defs') !== -1)
                            {
                                note += '\n\n' + uiStrings.notification.defsFailOnSave;
                                $.pref('save_notice_done', 'all');
                                done = 'all'
                            }
                            else
                            {
                                $.pref('save_notice_done', 'part')
                            }
                        }
                        else
                        {
                            $.pref('save_notice_done', 'all')
                        }
                        if (done !== 'part')
                        {
                            win.alert(note)
                        }
                    }
                };
            var exportHandler = function(win, data)
                {
                    var issues = data.issues,
                        type = data.type || 'PNG',
                        dataURLType = (type === 'ICO' ? 'BMP' : type).toLowerCase();
                    if (!$('#export_canvas').length)
                    {
                        $('<canvas>', {id: 'export_canvas'}).hide().appendTo('body')
                    }
                    var c = $('#export_canvas')[0];
                    c.width = svgCanvas.contentW;
                    c.height = svgCanvas.contentH;
                    canvg(c, data.svg, {renderCallback: function()
                        {
                            var datauri = data.quality ? c.toDataURL('image/' + dataURLType, data.quality) : c.toDataURL('image/' + dataURLType);
                            exportWindow.location.href = datauri;
                            var done = $.pref('export_notice_done');
                            if (done !== 'all')
                            {
                                var note = uiStrings.notification.saveFromBrowser.replace('%s', type);
                                if (issues.length)
                                {
                                    var pre = '\n \u2022 ';
                                    note += ('\n\n' + uiStrings.notification.noteTheseIssues + pre + issues.join(pre))
                                }
                                $.pref('export_notice_done', 'all');
                                exportWindow.alert(note)
                            }
                        }})
                };
            var operaRepaint = function()
                {
                    if (!window.opera)
                    {
                        return
                    }
                    $('<p/>').hide().appendTo('body').remove()
                };
            function setStrokeOpt(opt, changeElem)
            {
                var id = opt.id;
                var bits = id.split('_');
                var pre = bits[0];
                var val = bits[1];
                if (changeElem)
                {
                    svgCanvas.setStrokeAttr('stroke-' + pre, val)
                }
                operaRepaint();
                setIcon('#cur_' + pre, id, 20);
                $(opt).addClass('current').siblings().removeClass('current')
            }
            var toolButtonClick = editor.toolButtonClick = function(button, noHiding)
                {
                    if ($(button).hasClass('disabled'))
                    {
                        return false
                    }
                    if ($(button).parent().hasClass('tools_flyout'))
                    {
                        return true
                    }
                    var fadeFlyouts = 'normal';
                    if (!noHiding)
                    {
                        $('.tools_flyout').fadeOut(fadeFlyouts)
                    }
                    $('#styleoverrides').text('');
                    workarea.css('cursor', 'auto');
                    $('.tool_button_current').removeClass('tool_button_current').addClass('tool_button');
                    $(button).addClass('tool_button_current').removeClass('tool_button');
                    return true
                };
            var clickSelect = editor.clickSelect = function()
                {
                    if (toolButtonClick('#tool_select'))
                    {
                        svgCanvas.setMode('select');
                        $('#styleoverrides').text('#svgcanvas svg *{cursor:move;pointer-events:all}, #svgcanvas svg{cursor:default}')
                    }
                };
            var setImageURL = editor.setImageURL = function(url)
                {
                    if (!url)
                    {
                        url = defaultImageURL
                    }
                    svgCanvas.setImageURL(url);
                    $('#image_url').val(url);
                    if (url.indexOf('data:') === 0)
                    {
                        $('#image_url').hide();
                        $('#change_image_url').show()
                    }
                    else
                    {
                        svgCanvas.embedImage(url, function(dataURI)
                        {
                            $('#url_notice').toggle(!dataURI);
                            defaultImageURL = url
                        });
                        $('#image_url').show();
                        $('#change_image_url').hide()
                    }
                };
            function setBackground(color, url)
            {
                $.pref('bkgd_color', color);
                $.pref('bkgd_url', url);
                svgCanvas.setBackground(color, url)
            }
            function promptImgURL()
            {
                var curhref = svgCanvas.getHref(selectedElement);
                curhref = curhref.indexOf('data:') === 0 ? '' : curhref;
                $.prompt(uiStrings.notification.enterNewImgURL, curhref, function(url)
                {
                    if (url)
                    {
                        setImageURL(url)
                    }
                })
            }
            var setInputWidth = function(elem)
                {
                    var w = Math.min(Math.max(12 + elem.value.length * 6, 50), 300);
                    $(elem).width(w)
                };
            function updateRulers(scanvas, zoom)
            {
                if (!zoom)
                {
                    zoom = svgCanvas.getZoom()
                }
                if (!scanvas)
                {
                    scanvas = $('#svgcanvas')
                }
                var d,
                    i;
                var limit = 30000;
                var contentElem = svgCanvas.getContentElem();
                var units = svgedit.units.getTypeMap();
                var unit = units[curConfig.baseUnit];
                for (d = 0; d < 2; d++)
                {
                    var isX = (d === 0);
                    var dim = isX ? 'x' : 'y';
                    var lentype = isX ? 'width' : 'height';
                    var contentDim = Number(contentElem.getAttribute(dim));
                    var $hcanv_orig = $('#ruler_' + dim + ' canvas:first');
                    var $hcanv = $hcanv_orig.clone();
                    $hcanv_orig.replaceWith($hcanv);
                    var hcanv = $hcanv[0];
                    var ruler_len = scanvas[lentype]();
                    var total_len = ruler_len;
                    hcanv.parentNode.style[lentype] = total_len + 'px';
                    var ctx_num = 0;
                    var ctx = hcanv.getContext('2d');
                    var ctx_arr,
                        num,
                        ctx_arr_num;
                    ctx.fillStyle = 'rgb(200,0,0)';
                    ctx.fillRect(0, 0, hcanv.width, hcanv.height);
                    $hcanv.siblings().remove();
                    if (ruler_len >= limit)
                    {
                        ctx_arr_num = parseInt(ruler_len / limit, 10) + 1;
                        ctx_arr = [];
                        ctx_arr[0] = ctx;
                        var copy;
                        for (i = 1; i < ctx_arr_num; i++)
                        {
                            hcanv[lentype] = limit;
                            copy = hcanv.cloneNode(true);
                            hcanv.parentNode.appendChild(copy);
                            ctx_arr[i] = copy.getContext('2d')
                        }
                        copy[lentype] = ruler_len % limit;
                        ruler_len = limit
                    }
                    hcanv[lentype] = ruler_len;
                    var u_multi = unit * zoom;
                    var raw_m = 50 / u_multi;
                    var multi = 1;
                    for (i = 0; i < r_intervals.length; i++)
                    {
                        num = r_intervals[i];
                        multi = num;
                        if (raw_m <= num)
                        {
                            break
                        }
                    }
                    var big_int = multi * u_multi;
                    ctx.font = '9px sans-serif';
                    var ruler_d = ((contentDim / u_multi) % multi) * u_multi;
                    var label_pos = ruler_d - big_int;
                    while (ruler_d < total_len)
                    {
                        label_pos += big_int;
                        var cur_d = Math.round(ruler_d) + 0.5;
                        if (isX)
                        {
                            ctx.moveTo(cur_d, 15);
                            ctx.lineTo(cur_d, 0)
                        }
                        else
                        {
                            ctx.moveTo(15, cur_d);
                            ctx.lineTo(0, cur_d)
                        }
                        num = (label_pos - contentDim) / u_multi;
                        var label;
                        if (multi >= 1)
                        {
                            label = Math.round(num)
                        }
                        else
                        {
                            var decs = String(multi).split('.')[1].length;
                            label = num.toFixed(decs)
                        }
                        if (label !== 0 && label !== 1000 && label % 1000 === 0)
                        {
                            label = (label / 1000) + 'K'
                        }
                        if (isX)
                        {
                            ctx.fillText(label, ruler_d + 2, 8)
                        }
                        else
                        {
                            var str = String(label).split('');
                            for (i = 0; i < str.length; i++)
                            {
                                ctx.fillText(str[i], 1, (ruler_d + 9) + i * 9)
                            }
                        }
                        var part = big_int / 10;
                        for (i = 1; i < 10; i++)
                        {
                            var sub_d = Math.round(ruler_d + part * i) + 0.5;
                            if (ctx_arr && sub_d > ruler_len)
                            {
                                ctx_num++;
                                ctx.stroke();
                                if (ctx_num >= ctx_arr_num)
                                {
                                    i = 10;
                                    ruler_d = total_len;
                                    continue
                                }
                                ctx = ctx_arr[ctx_num];
                                ruler_d -= limit;
                                sub_d = Math.round(ruler_d + part * i) + 0.5
                            }
                            var line_num = (i % 2) ? 12 : 10;
                            if (isX)
                            {
                                ctx.moveTo(sub_d, 15);
                                ctx.lineTo(sub_d, line_num)
                            }
                            else
                            {
                                ctx.moveTo(15, sub_d);
                                ctx.lineTo(line_num, sub_d)
                            }
                        }
                        ruler_d += big_int
                    }
                    ctx.strokeStyle = '#000';
                    ctx.stroke()
                }
            }
            var updateCanvas = editor.updateCanvas = function(center, new_ctr)
                {
                    var w = workarea.width(),
                        h = workarea.height();
                    var w_orig = w,
                        h_orig = h;
                    var zoom = svgCanvas.getZoom();
                    var w_area = workarea;
                    var cnvs = $('#svgcanvas');
                    var old_ctr = {
                            x: w_area[0].scrollLeft + w_orig / 2, y: w_area[0].scrollTop + h_orig / 2
                        };
                    var multi = curConfig.canvas_expansion;
                    w = Math.max(w_orig, svgCanvas.contentW * zoom * multi);
                    h = Math.max(h_orig, svgCanvas.contentH * zoom * multi);
                    if (w == w_orig && h == h_orig)
                    {
                        workarea.css('overflow', 'hidden')
                    }
                    else
                    {
                        workarea.css('overflow', 'scroll')
                    }
                    var old_can_y = cnvs.height() / 2;
                    var old_can_x = cnvs.width() / 2;
                    cnvs.width(w).height(h);
                    var new_can_y = h / 2;
                    var new_can_x = w / 2;
                    var offset = svgCanvas.updateCanvas(w, h);
                    var ratio = new_can_x / old_can_x;
                    var scroll_x = w / 2 - w_orig / 2;
                    var scroll_y = h / 2 - h_orig / 2;
                    if (!new_ctr)
                    {
                        var old_dist_x = old_ctr.x - old_can_x;
                        var new_x = new_can_x + old_dist_x * ratio;
                        var old_dist_y = old_ctr.y - old_can_y;
                        var new_y = new_can_y + old_dist_y * ratio;
                        new_ctr = {
                            x: new_x, y: new_y
                        }
                    }
                    else
                    {
                        new_ctr.x += offset.x;
                        new_ctr.y += offset.y
                    }
                    if (center)
                    {
                        if (svgCanvas.contentW > w_area.width())
                        {
                            workarea[0].scrollLeft = offset.x - 10;
                            workarea[0].scrollTop = offset.y - 10
                        }
                        else
                        {
                            w_area[0].scrollLeft = scroll_x;
                            w_area[0].scrollTop = scroll_y
                        }
                    }
                    else
                    {
                        w_area[0].scrollLeft = new_ctr.x - w_orig / 2;
                        w_area[0].scrollTop = new_ctr.y - h_orig / 2
                    }
                    if (curConfig.showRulers)
                    {
                        updateRulers(cnvs, zoom);
                        workarea.scroll()
                    }
                    if (urldata.storagePrompt !== true && !editor.storagePromptClosed)
                    {
                        $('#dialog_box').hide()
                    }
                };
            var updateToolButtonState = function()
                {
                    var index,
                        button;
                    var bNoFill = (svgCanvas.getColor('fill') == 'none');
                    var bNoStroke = (svgCanvas.getColor('stroke') == 'none');
                    var buttonsNeedingStroke = ['#tool_fhpath', '#tool_line'];
                    var buttonsNeedingFillAndStroke = ['#tools_rect .tool_button', '#tools_ellipse .tool_button', '#tool_text', '#tool_path'];
                    if (bNoStroke)
                    {
                        for (index in buttonsNeedingStroke)
                        {
                            button = buttonsNeedingStroke[index];
                            if ($(button).hasClass('tool_button_current'))
                            {
                                clickSelect()
                            }
                            $(button).addClass('disabled')
                        }
                    }
                    else
                    {
                        for (index in buttonsNeedingStroke)
                        {
                            button = buttonsNeedingStroke[index];
                            $(button).removeClass('disabled')
                        }
                    }
                    if (bNoStroke && bNoFill)
                    {
                        for (index in buttonsNeedingFillAndStroke)
                        {
                            button = buttonsNeedingFillAndStroke[index];
                            if ($(button).hasClass('tool_button_current'))
                            {
                                clickSelect()
                            }
                            $(button).addClass('disabled')
                        }
                    }
                    else
                    {
                        for (index in buttonsNeedingFillAndStroke)
                        {
                            button = buttonsNeedingFillAndStroke[index];
                            $(button).removeClass('disabled')
                        }
                    }
                    svgCanvas.runExtensions('toolButtonStateUpdate', {
                        nofill: bNoFill, nostroke: bNoStroke
                    });
                    $('.tools_flyout').each(function()
                    {
                        var shower = $('#' + this.id + '_show');
                        var has_enabled = false;
                        $(this).children().each(function()
                        {
                            if (!$(this).hasClass('disabled'))
                            {
                                has_enabled = true
                            }
                        });
                        shower.toggleClass('disabled', !has_enabled)
                    });
                    operaRepaint()
                };
            var updateToolbar = function()
                {
                    var i,
                        len;
                    if (selectedElement != null)
                    {
                        switch (selectedElement.tagName)
                        {
                            case'use':
                            case'image':
                            case'foreignObject':
                                break;
                            case'g':
                            case'a':
                                var gWidth = null;
                                var childs = selectedElement.getElementsByTagName('*');
                                for (i = 0, len = childs.length; i < len; i++)
                                {
                                    var swidth = childs[i].getAttribute('stroke-width');
                                    if (i === 0)
                                    {
                                        gWidth = swidth
                                    }
                                    else if (gWidth !== swidth)
                                    {
                                        gWidth = null
                                    }
                                }
                                $('#stroke_width').val(gWidth === null ? '' : gWidth);
                                paintBox.fill.update(true);
                                paintBox.stroke.update(true);
                                break;
                            default:
                                paintBox.fill.update(true);
                                paintBox.stroke.update(true);
                                $('#stroke_width').val(selectedElement.getAttribute('stroke-width') || 1);
                                $('#stroke_style').val(selectedElement.getAttribute('stroke-dasharray') || 'none');
                                var attr = selectedElement.getAttribute('stroke-linejoin') || 'miter';
                                if ($('#linejoin_' + attr).length != 0)
                                {
                                    setStrokeOpt($('#linejoin_' + attr)[0])
                                }
                                attr = selectedElement.getAttribute('stroke-linecap') || 'butt';
                                if ($('#linecap_' + attr).length != 0)
                                {
                                    setStrokeOpt($('#linecap_' + attr)[0])
                                }
                        }
                    }
                    if (selectedElement != null)
                    {
                        var opac_perc = ((selectedElement.getAttribute('opacity') || 1.0) * 100);
                        $('#group_opacity').val(opac_perc);
                        $('#opac_slider').slider('option', 'value', opac_perc);
                        $('#elem_id').val(selectedElement.id)
                    }
                    updateToolButtonState()
                };
            var updateContextPanel = function()
                {
                    var elem = selectedElement;
                    if (elem != null && !elem.parentNode)
                    {
                        elem = null
                    }
                    var currentLayerName = svgCanvas.getCurrentDrawing().getCurrentLayerName();
                    var currentMode = svgCanvas.getMode();
                    var unit = curConfig.baseUnit !== 'px' ? curConfig.baseUnit : null;
                    var is_node = currentMode == 'pathedit';
                    var menu_items = $('#cmenu_canvas li');
                    $('#selected_panel, #multiselected_panel, #g_panel, #rect_panel, #circle_panel,' + '#ellipse_panel, #line_panel, #text_panel, #image_panel, #container_panel,' + ' #use_panel, #a_panel').hide();
                    if (elem != null)
                    {
                        var elname = elem.nodeName;
                        var angle = svgCanvas.getRotationAngle(elem);
                        $('#angle').val(angle);
                        var blurval = svgCanvas.getBlur(elem);
                        $('#blur').val(blurval);
                        $('#blur_slider').slider('option', 'value', blurval);
                        if (svgCanvas.addedNew)
                        {
                            if (elname === 'image')
                            {
                                if (svgCanvas.getHref(elem).indexOf('data:') !== 0)
                                {
                                    promptImgURL()
                                }
                            }
                        }
                        if (!is_node && currentMode != 'pathedit')
                        {
                            $('#selected_panel').show();
                            if (['line', 'circle', 'ellipse'].indexOf(elname) >= 0)
                            {
                                $('#xy_panel').hide()
                            }
                            else
                            {
                                var x,
                                    y;
                                if (['g', 'polyline', 'path'].indexOf(elname) >= 0)
                                {
                                    var bb = svgCanvas.getStrokedBBox([elem]);
                                    if (bb)
                                    {
                                        x = bb.x;
                                        y = bb.y
                                    }
                                }
                                else
                                {
                                    x = elem.getAttribute('x');
                                    y = elem.getAttribute('y')
                                }
                                if (unit)
                                {
                                    x = svgedit.units.convertUnit(x);
                                    y = svgedit.units.convertUnit(y)
                                }
                                $('#selected_x').val(x || 0);
                                $('#selected_y').val(y || 0);
                                $('#xy_panel').show()
                            }
                            var no_path = ['image', 'text', 'path', 'g', 'use'].indexOf(elname) == -1;
                            $('#tool_topath').toggle(no_path);
                            $('#tool_reorient').toggle(elname === 'path');
                            $('#tool_reorient').toggleClass('disabled', angle === 0)
                        }
                        else
                        {
                            var point = path.getNodePoint();
                            $('#tool_add_subpath').removeClass('push_button_pressed').addClass('tool_button');
                            $('#tool_node_delete').toggleClass('disabled', !path.canDeleteNodes);
                            setIcon('#tool_openclose_path', path.closed_subpath ? 'open_path' : 'close_path');
                            if (point)
                            {
                                var seg_type = $('#seg_type');
                                if (unit)
                                {
                                    point.x = svgedit.units.convertUnit(point.x);
                                    point.y = svgedit.units.convertUnit(point.y)
                                }
                                $('#path_node_x').val(point.x);
                                $('#path_node_y').val(point.y);
                                if (point.type)
                                {
                                    seg_type.val(point.type).removeAttr('disabled')
                                }
                                else
                                {
                                    seg_type.val(4).attr('disabled', 'disabled')
                                }
                            }
                            return
                        }
                        var panels = {
                                g: [], a: [], rect: ['rx', 'width', 'height'], image: ['width', 'height'], circle: ['cx', 'cy', 'r'], ellipse: ['cx', 'cy', 'rx', 'ry'], line: ['x1', 'y1', 'x2', 'y2'], text: [], use: []
                            };
                        var el_name = elem.tagName;
                        var link_href = null;
                        if (el_name === 'a')
                        {
                            link_href = svgCanvas.getHref(elem);
                            $('#g_panel').show()
                        }
                        if (elem.parentNode.tagName === 'a')
                        {
                            if (!$(elem).siblings().length)
                            {
                                $('#a_panel').show();
                                link_href = svgCanvas.getHref(elem.parentNode)
                            }
                        }
                        $('#tool_make_link, #tool_make_link').toggle(!link_href);
                        if (link_href)
                        {
                            $('#link_url').val(link_href)
                        }
                        if (panels[el_name])
                        {
                            var cur_panel = panels[el_name];
                            $('#' + el_name + '_panel').show();
                            $.each(cur_panel, function(i, item)
                            {
                                var attrVal = elem.getAttribute(item);
                                if (curConfig.baseUnit !== 'px' && elem[item])
                                {
                                    var bv = elem[item].baseVal.value;
                                    attrVal = svgedit.units.convertUnit(bv)
                                }
                                $('#' + el_name + '_' + item).val(attrVal || 0)
                            });
                            if (el_name == 'text')
                            {
                                $('#text_panel').css('display', 'inline');
                                if (svgCanvas.getItalic())
                                {
                                    $('#tool_italic').addClass('push_button_pressed').removeClass('tool_button')
                                }
                                else
                                {
                                    $('#tool_italic').removeClass('push_button_pressed').addClass('tool_button')
                                }
                                if (svgCanvas.getBold())
                                {
                                    $('#tool_bold').addClass('push_button_pressed').removeClass('tool_button')
                                }
                                else
                                {
                                    $('#tool_bold').removeClass('push_button_pressed').addClass('tool_button')
                                }
                                $('#font_family').val(elem.getAttribute('font-family'));
                                $('#font_size').val(elem.getAttribute('font-size'));
                                $('#text').val(elem.textContent);
                                if (svgCanvas.addedNew)
                                {
                                    setTimeout(function()
                                    {
                                        $('#text').focus().select()
                                    }, 100)
                                }
                            }
                            else if (el_name == 'image')
                            {
                                setImageURL(svgCanvas.getHref(elem))
                            }
                            else if (el_name === 'g' || el_name === 'use')
                            {
                                $('#container_panel').show();
                                var title = svgCanvas.getTitle();
                                var label = $('#g_title')[0];
                                label.value = title;
                                setInputWidth(label);
                                $('#g_title').prop('disabled', el_name == 'use')
                            }
                        }
                        menu_items[(el_name === 'g' ? 'en' : 'dis') + 'ableContextMenuItems']('#ungroup');
                        menu_items[((el_name === 'g' || !multiselected) ? 'dis' : 'en') + 'ableContextMenuItems']('#group')
                    }
                    else if (multiselected)
                    {
                        $('#multiselected_panel').show();
                        menu_items.enableContextMenuItems('#group').disableContextMenuItems('#ungroup')
                    }
                    else
                    {
                        menu_items.disableContextMenuItems('#delete,#cut,#copy,#group,#ungroup,#move_front,#move_up,#move_down,#move_back')
                    }
                    $('#tool_undo').toggleClass('disabled', undoMgr.getUndoStackSize() === 0);
                    $('#tool_redo').toggleClass('disabled', undoMgr.getRedoStackSize() === 0);
                    svgCanvas.addedNew = false;
                    if ((elem && !is_node) || multiselected)
                    {
                        $('#selLayerNames').removeAttr('disabled').val(currentLayerName);
                        canv_menu.enableContextMenuItems('#delete,#cut,#copy,#move_front,#move_up,#move_down,#move_back')
                    }
                    else
                    {
                        $('#selLayerNames').attr('disabled', 'disabled')
                    }
                };
            var updateWireFrame = function()
                {
                    if (supportsNonSS)
                    {
                        return
                    }
                    var rule = '#workarea.wireframe #svgcontent * { stroke-width: ' + 1 / svgCanvas.getZoom() + 'px; }';
                    $('#wireframe_rules').text(workarea.hasClass('wireframe') ? rule : '')
                };
            var updateTitle = function(title)
                {
                    title = title || svgCanvas.getDocumentTitle();
                    var newTitle = origTitle + (title ? ': ' + title : '');
                    $('title:first').text(newTitle)
                };
            var selectedChanged = function(win, elems)
                {
                    var mode = svgCanvas.getMode();
                    if (mode === 'select')
                    {
                        setSelectMode()
                    }
                    var is_node = (mode == "pathedit");
                    selectedElement = (elems.length === 1 || elems[1] == null ? elems[0] : null);
                    multiselected = (elems.length >= 2 && elems[1] != null);
                    if (selectedElement != null)
                    {
                        if (!is_node)
                        {
                            updateToolbar()
                        }
                    }
                    togglePathEditMode(is_node, elems);
                    updateContextPanel();
                    svgCanvas.runExtensions('selectedChanged', {
                        elems: elems, selectedElement: selectedElement, multiselected: multiselected
                    })
                };
            var elementTransition = function(win, elems)
                {
                    var mode = svgCanvas.getMode();
                    var elem = elems[0];
                    if (!elem)
                    {
                        return
                    }
                    multiselected = (elems.length >= 2 && elems[1] != null);
                    if (!multiselected)
                    {
                        switch (mode)
                        {
                            case'rotate':
                                var ang = svgCanvas.getRotationAngle(elem);
                                $('#angle').val(ang);
                                $('#tool_reorient').toggleClass('disabled', ang === 0);
                                break
                        }
                    }
                    svgCanvas.runExtensions('elementTransition', {elems: elems})
                };
            var elementChanged = function(win, elems)
                {
                    var i,
                        mode = svgCanvas.getMode();
                    if (mode === 'select')
                    {
                        setSelectMode()
                    }
                    for (i = 0; i < elems.length; ++i)
                    {
                        var elem = elems[i];
                        if (elem && elem.tagName === 'svg')
                        {
                            populateLayers();
                            updateCanvas()
                        }
                        else if (elem && selectedElement && selectedElement.parentNode == null)
                        {
                            selectedElement = elem
                        }
                    }
                    editor.showSaveWarning = true;
                    updateContextPanel();
                    if (selectedElement && mode === 'select')
                    {
                        paintBox.fill.update();
                        paintBox.stroke.update()
                    }
                    svgCanvas.runExtensions('elementChanged', {elems: elems})
                };
            var zoomDone = function()
                {
                    updateWireFrame()
                };
            var zoomChanged = svgCanvas.zoomChanged = function(win, bbox, autoCenter)
                {
                    var scrbar = 15,
                        w_area = workarea;
                    var z_info = svgCanvas.setBBoxZoom(bbox, w_area.width() - scrbar, w_area.height() - scrbar);
                    if (!z_info)
                    {
                        return
                    }
                    var zoomlevel = z_info.zoom,
                        bb = z_info.bbox;
                    if (zoomlevel < 0.001)
                    {
                        changeZoom({value: 0.1});
                        return
                    }
                    $('#zoom').val((zoomlevel * 100).toFixed(1));
                    if (autoCenter)
                    {
                        updateCanvas()
                    }
                    else
                    {
                        updateCanvas(false, {
                            x: bb.x * zoomlevel + (bb.width * zoomlevel) / 2, y: bb.y * zoomlevel + (bb.height * zoomlevel) / 2
                        })
                    }
                    if (svgCanvas.getMode() == 'zoom' && bb.width)
                    {
                        setSelectMode()
                    }
                    zoomDone()
                };
            changeZoom = function(ctl)
            {
                var zoomlevel = ctl.value / 100;
                if (zoomlevel < 0.001)
                {
                    ctl.value = 0.1;
                    return
                }
                var zoom = svgCanvas.getZoom();
                var w_area = workarea;
                zoomChanged(window, {
                    width: 0, height: 0, x: (w_area[0].scrollLeft + w_area.width() / 2) / zoom, y: (w_area[0].scrollTop + w_area.height() / 2) / zoom, zoom: zoomlevel
                }, true)
            };
            $('#cur_context_panel').delegate('a', 'click', function()
            {
                var link = $(this);
                if (link.attr('data-root'))
                {
                    svgCanvas.leaveContext()
                }
                else
                {
                    svgCanvas.setContext(link.text())
                }
                svgCanvas.clearSelection();
                return false
            });
            var contextChanged = function(win, context)
                {
                    var link_str = '';
                    if (context)
                    {
                        var str = '';
                        link_str = '<a href="#" data-root="y">' + svgCanvas.getCurrentDrawing().getCurrentLayerName() + '</a>';
                        $(context).parentsUntil('#svgcontent > g').andSelf().each(function()
                        {
                            if (this.id)
                            {
                                str += ' > ' + this.id;
                                if (this !== context)
                                {
                                    link_str += ' > <a href="#">' + this.id + '</a>'
                                }
                                else
                                {
                                    link_str += ' > ' + this.id
                                }
                            }
                        });
                        cur_context = str
                    }
                    else
                    {
                        cur_context = null
                    }
                    $('#cur_context_panel').toggle(!!context).html(link_str);
                    updateTitle()
                };
            var prepPaints = function()
                {
                    paintBox.fill.prep();
                    paintBox.stroke.prep()
                };
            var flyout_funcs = {};
            var setFlyoutTitles = function()
                {
                    $('.tools_flyout').each(function()
                    {
                        var shower = $('#' + this.id + '_show');
                        if (shower.data('isLibrary'))
                        {
                            return
                        }
                        var tooltips = [];
                        $(this).children().each(function()
                        {
                            tooltips.push(this.title)
                        });
                        shower[0].title = tooltips.join(' / ')
                    })
                };
            var setFlyoutPositions = function()
                {
                    $('.tools_flyout').each(function()
                    {
                        var shower = $('#' + this.id + '_show');
                        var pos = shower.offset();
                        var w = shower.outerWidth();
                        $(this).css({
                            left: (pos.left + w) * editor.tool_scale, top: pos.top
                        })
                    })
                };
            var setupFlyouts = function(holders)
                {
                    $.each(holders, function(hold_sel, btn_opts)
                    {
                        var buttons = $(hold_sel).children();
                        var show_sel = hold_sel + '_show';
                        var shower = $(show_sel);
                        var def = false;
                        buttons.addClass('tool_button').unbind('click mousedown mouseup').each(function(i)
                        {
                            var opts = btn_opts[i];
                            flyout_funcs[opts.sel] = opts.fn;
                            if (opts.isDefault)
                            {
                                def = i
                            }
                            var func = function(event)
                                {
                                    var options = opts;
                                    if (event.type === 'keydown')
                                    {
                                        var flyoutIsSelected = $(options.parent + '_show').hasClass('tool_button_current');
                                        var currentOperation = $(options.parent + '_show').attr('data-curopt');
                                        $.each(holders[opts.parent], function(i, tool)
                                        {
                                            if (tool.sel == currentOperation)
                                            {
                                                if (!event.shiftKey || !flyoutIsSelected)
                                                {
                                                    options = tool
                                                }
                                                else
                                                {
                                                    options = holders[opts.parent][i + 1] || holders[opts.parent][0]
                                                }
                                            }
                                        })
                                    }
                                    if ($(this).hasClass('disabled'))
                                    {
                                        return false
                                    }
                                    if (toolButtonClick(show_sel))
                                    {
                                        options.fn()
                                    }
                                    var icon;
                                    if (options.icon)
                                    {
                                        icon = $.getSvgIcon(options.icon, true)
                                    }
                                    else
                                    {
                                        icon = $(options.sel).children().eq(0).clone()
                                    }
                                    icon[0].setAttribute('width', shower.width());
                                    icon[0].setAttribute('height', shower.height());
                                    shower.children(':not(.flyout_arrow_horiz)').remove();
                                    shower.append(icon).attr('data-curopt', options.sel)
                                };
                            $(this).mouseup(func);
                            if (opts.key)
                            {
                                $(document).bind('keydown', opts.key[0] + ' shift+' + opts.key[0], func)
                            }
                        });
                        if (def)
                        {
                            shower.attr('data-curopt', btn_opts[def].sel)
                        }
                        else if (!shower.attr('data-curopt'))
                        {
                            shower.attr('data-curopt', btn_opts[0].sel)
                        }
                        var timer;
                        var pos = $(show_sel).position();
                        shower.mousedown(function(evt)
                        {
                            if (shower.hasClass('disabled'))
                            {
                                return false
                            }
                            var holder = $(hold_sel);
                            var l = pos.left + 34;
                            var w = holder.width() * -1;
                            var time = holder.data('shown_popop') ? 200 : 0;
                            timer = setTimeout(function()
                            {
                                if (!shower.data('isLibrary'))
                                {
                                    holder.css('left', w).show().animate({left: l}, 150)
                                }
                                else
                                {
                                    holder.css('left', l).show()
                                }
                                holder.data('shown_popop', true)
                            }, time);
                            evt.preventDefault()
                        }).mouseup(function(evt)
                        {
                            clearTimeout(timer);
                            var opt = $(this).attr('data-curopt');
                            if (shower.data('isLibrary') && $(show_sel.replace('_show', '')).is(':visible'))
                            {
                                toolButtonClick(show_sel, true);
                                return
                            }
                            if (toolButtonClick(show_sel) && flyout_funcs[opt])
                            {
                                flyout_funcs[opt]()
                            }
                        })
                    });
                    setFlyoutTitles();
                    setFlyoutPositions()
                };
            var makeFlyoutHolder = function(id, child)
                {
                    var div = $('<div>', {
                            'class': 'tools_flyout', id: id
                        }).appendTo('#svg_editor').append(child);
                    return div
                };
            var uaPrefix = (function()
                {
                    var prop;
                    var regex = /^(Moz|Webkit|Khtml|O|ms|Icab)(?=[A-Z])/;
                    var someScript = document.getElementsByTagName('script')[0];
                    for (prop in someScript.style)
                    {
                        if (regex.test(prop))
                        {
                            return prop.match(regex)[0]
                        }
                    }
                    if ('WebkitOpacity' in someScript.style)
                    {
                        return 'Webkit'
                    }
                    if ('KhtmlOpacity' in someScript.style)
                    {
                        return 'Khtml'
                    }
                    return ''
                }());
            var scaleElements = function(elems, scale)
                {
                    var sides = ['top', 'left', 'bottom', 'right'];
                    elems.each(function()
                    {
                        var i;
                        var el = $(this);
                        var w = el.outerWidth() * (scale - 1);
                        var h = el.outerHeight() * (scale - 1);
                        for (i = 0; i < 4; i++)
                        {
                            var s = sides[i];
                            var cur = el.data('orig_margin-' + s);
                            if (cur == null)
                            {
                                cur = parseInt(el.css('margin-' + s), 10);
                                el.data('orig_margin-' + s, cur)
                            }
                            var val = cur * scale;
                            if (s === 'right')
                            {
                                val += w
                            }
                            else if (s === 'bottom')
                            {
                                val += h
                            }
                            el.css('margin-' + s, val)
                        }
                    })
                };
            var setIconSize = editor.setIconSize = function(size)
                {
                    return;
                    var sel_toscale = '#tools_top .toolset, #editor_panel > *, #history_panel > *,' + '				#main_button, #tools_left > *, #path_node_panel > *, #multiselected_panel > *,' + '				#g_panel > *, #tool_font_size > *, .tools_flyout';
                    var elems = $(sel_toscale);
                    var scale = 1;
                    if (typeof size === 'number')
                    {
                        scale = size
                    }
                    else
                    {
                        var icon_sizes = {
                                s: 0.75, m: 1, l: 1.25, xl: 1.5
                            };
                        scale = icon_sizes[size]
                    }
                    editor.tool_scale = scale;
                    setFlyoutPositions();
                    var hidden_ps = elems.parents(':hidden');
                    hidden_ps.css('visibility', 'hidden').show();
                    scaleElements(elems, scale);
                    hidden_ps.css('visibility', 'visible').hide();
                    $.pref('iconsize', size);
                    $('#iconsize').val(size);
                    var cssResizeRules = {
                            '#tools_top': {
                                left: 50, height: 72
                            }, '#tools_left': {
                                    width: 31, top: 74
                                }, 'div#workarea': {
                                    left: 38, top: 74
                                }
                        };
                    var rule_elem = $('#tool_size_rules');
                    if (!rule_elem.length)
                    {
                        rule_elem = $('<style id="tool_size_rules"><\/style>').appendTo('head')
                    }
                    else
                    {
                        rule_elem.empty()
                    }
                    if (size !== 'm')
                    {
                        var styleStr = '';
                        $.each(cssResizeRules, function(selector, rules)
                        {
                            selector = '#svg_editor ' + selector.replace(/,/g, ', #svg_editor');
                            styleStr += selector + '{';
                            $.each(rules, function(prop, values)
                            {
                                var val;
                                if (typeof values === 'number')
                                {
                                    val = (values * scale) + 'px'
                                }
                                else if (values[size] || values.all)
                                {
                                    val = (values[size] || values.all)
                                }
                                styleStr += (prop + ':' + val + ';')
                            });
                            styleStr += '}'
                        });
                        var prefix = '-' + uaPrefix.toLowerCase() + '-';
                        styleStr += (sel_toscale + '{' + prefix + 'transform: scale(' + scale + ');}' + ' #svg_editor div.toolset .toolset {' + prefix + 'transform: scale(1); margin: 1px !important;}' + ' #svg_editor .ui-slider {' + prefix + 'transform: scale(' + (1 / scale) + ');}');
                        rule_elem.text(styleStr)
                    }
                    setFlyoutPositions()
                };
            var addAltDropDown = function(elem, list, callback, opts)
                {
                    var button = $(elem);
                    list = $(list);
                    var on_button = false;
                    var dropUp = opts.dropUp;
                    if (dropUp)
                    {
                        $(elem).addClass('dropup')
                    }
                    list.find('li').bind('mouseup', function()
                    {
                        if (opts.seticon)
                        {
                            setIcon('#cur_' + button[0].id, $(this).children());
                            $(this).addClass('current').siblings().removeClass('current')
                        }
                        callback.apply(this, arguments)
                    });
                    $(window).mouseup(function(evt)
                    {
                        if (!on_button)
                        {
                            button.removeClass('down');
                            list.hide();
                            list.css({
                                top: 0, left: 0
                            })
                        }
                        on_button = false
                    });
                    button.bind('mousedown', function()
                    {
                        var off = button.offset();
                        if (dropUp)
                        {
                            off.top -= list.height();
                            off.left += 8
                        }
                        else
                        {
                            off.top += button.height()
                        }
                        list.offset(off);
                        if (!button.hasClass('down'))
                        {
                            list.show();
                            on_button = true
                        }
                        else
                        {
                            list.hide();
                            list.css({
                                top: 0, left: 0
                            })
                        }
                        button.toggleClass('down')
                    }).hover(function()
                    {
                        on_button = true
                    }).mouseout(function()
                    {
                        on_button = false
                    });
                    if (opts.multiclick)
                    {
                        list.mousedown(function()
                        {
                            on_button = true
                        })
                    }
                };
            var extsPreLang = [];
            var extAdded = function(win, ext)
                {
                    if (!ext)
                    {
                        return
                    }
                    var cb_called = false;
                    var resize_done = false;
                    var cb_ready = true;
                    if (ext.langReady)
                    {
                        if (editor.langChanged)
                        {
                            var lang = $.pref('lang');
                            ext.langReady({
                                lang: lang, uiStrings: uiStrings
                            })
                        }
                        else
                        {
                            extsPreLang.push(ext)
                        }
                    }
                    function prepResize()
                    {
                        if (resize_timer)
                        {
                            clearTimeout(resize_timer);
                            resize_timer = null
                        }
                        if (!resize_done)
                        {
                            resize_timer = setTimeout(function()
                            {
                                resize_done = true;
                                setIconSize($.pref('iconsize'))
                            }, 50)
                        }
                    }
                    var runCallback = function()
                        {
                            if (ext.callback && !cb_called && cb_ready)
                            {
                                cb_called = true;
                                ext.callback()
                            }
                        };
                    var btn_selects = [];
                    if (ext.context_tools)
                    {
                        $.each(ext.context_tools, function(i, tool)
                        {
                            var html;
                            var cont_id = tool.container_id ? (' id="' + tool.container_id + '"') : '';
                            var panel = $('#' + tool.panel);
                            if (!panel.length)
                            {
                                panel = $('<div>', {id: tool.panel}).appendTo('#tools_top')
                            }
                            switch (tool.type)
                            {
                                case'tool_button':
                                    html = '<div class="tool_button">' + tool.id + '</div>';
                                    var div = $(html).appendTo(panel);
                                    if (tool.events)
                                    {
                                        $.each(tool.events, function(evt, func)
                                        {
                                            $(div).bind(evt, func)
                                        })
                                    }
                                    break;
                                case'select':
                                    html = '<label' + cont_id + '>' + '<select id="' + tool.id + '">';
                                    $.each(tool.options, function(val, text)
                                    {
                                        var sel = (val == tool.defval) ? " selected" : "";
                                        html += '<option value="' + val + '"' + sel + '>' + text + '</option>'
                                    });
                                    html += "</select></label>";
                                    var sel = $(html).appendTo(panel).find('select');
                                    $.each(tool.events, function(evt, func)
                                    {
                                        $(sel).bind(evt, func)
                                    });
                                    break;
                                case'button-select':
                                    html = '<div id="' + tool.id + '" class="dropdown toolset" title="' + tool.title + '">' + '<div id="cur_' + tool.id + '" class="icon_label"></div><button></button></div>';
                                    var list = $('<ul id="' + tool.id + '_opts"></ul>').appendTo('#option_lists');
                                    if (tool.colnum)
                                    {
                                        list.addClass('optcols' + tool.colnum)
                                    }
                                    var dropdown = $(html).appendTo(panel).children();
                                    btn_selects.push({
                                        elem: ('#' + tool.id), list: ('#' + tool.id + '_opts'), title: tool.title, callback: tool.events.change, cur: ('#cur_' + tool.id)
                                    });
                                    break;
                                case'input':
                                    html = '<label' + cont_id + '>' + '<span id="' + tool.id + '_label">' + tool.label + ':</span>' + '<input id="' + tool.id + '" title="' + tool.title + '" size="' + (tool.size || "4") + '" value="' + (tool.defval || "") + '" type="text"/></label>';
                                    var inp = $(html).appendTo(panel).find('input');
                                    if (tool.spindata)
                                    {
                                        inp.SpinButton(tool.spindata)
                                    }
                                    if (tool.events)
                                    {
                                        $.each(tool.events, function(evt, func)
                                        {
                                            inp.bind(evt, func)
                                        })
                                    }
                                    break;
                                default:
                                    break
                            }
                        })
                    }
                    if (ext.buttons)
                    {
                        var fallback_obj = {},
                            placement_obj = {},
                            svgicons = ext.svgicons,
                            holders = {};
                        $.each(ext.buttons, function(i, btn)
                        {
                            var icon,
                                svgicon,
                                tls_id;
                            var id = btn.id;
                            var num = i;
                            while ($('#' + id).length)
                            {
                                id = btn.id + '_' + (++num)
                            }
                            if (!svgicons)
                            {
                                icon = $('<img src="' + btn.icon + '">')
                            }
                            else
                            {
                                fallback_obj[id] = btn.icon;
                                svgicon = btn.svgicon || btn.id;
                                if (btn.type == 'app_menu')
                                {
                                    placement_obj['#' + id + ' > div'] = svgicon
                                }
                                else
                                {
                                    placement_obj['#' + id] = svgicon
                                }
                            }
                            var cls,
                                parent;
                            switch (btn.type)
                            {
                                case'mode_flyout':
                                case'mode':
                                    cls = 'tool_button';
                                    parent = '#tools_left';
                                    break;
                                case'context':
                                    cls = 'tool_button';
                                    parent = '#' + btn.panel;
                                    if (!$(parent).length)
                                    {
                                        $('<div>', {id: btn.panel}).appendTo('#tools_top')
                                    }
                                    break;
                                case'app_menu':
                                    cls = '';
                                    parent = '#main_menu ul';
                                    break
                            }
                            var flyout_holder,
                                cur_h,
                                show_btn,
                                ref_data,
                                ref_btn;
                            var button = $((btn.list || btn.type == 'app_menu') ? '<li/>' : '<div/>').attr('id', id).attr('title', btn.title).addClass(cls);
                            if (!btn.includeWith && !btn.list)
                            {
                                if ('position' in btn)
                                {
                                    if ($(parent).children().eq(btn.position).length)
                                    {
                                        $(parent).children().eq(btn.position).before(button)
                                    }
                                    else
                                    {
                                        $(parent).children().last().before(button)
                                    }
                                }
                                else
                                {
                                    button.appendTo(parent)
                                }
                                if (btn.type == 'mode_flyout')
                                {
                                    ref_btn = $(button);
                                    flyout_holder = ref_btn.parent();
                                    if (!ref_btn.parent().hasClass('tools_flyout'))
                                    {
                                        tls_id = ref_btn[0].id.replace('tool_', 'tools_');
                                        show_btn = ref_btn.clone().attr('id', tls_id + '_show').append($('<div>', {'class': 'flyout_arrow_horiz'}));
                                        ref_btn.before(show_btn);
                                        flyout_holder = makeFlyoutHolder(tls_id, ref_btn);
                                        flyout_holder.data('isLibrary', true);
                                        show_btn.data('isLibrary', true)
                                    }
                                    placement_obj['#' + tls_id + '_show'] = btn.id;
                                    cur_h = holders['#' + flyout_holder[0].id] = [{
                                            sel: '#' + id, fn: btn.events.click, icon: btn.id, isDefault: true
                                        }, ref_data]
                                }
                                else if (btn.type == 'app_menu')
                                {
                                    button.append('<div>').append(btn.title)
                                }
                            }
                            else if (btn.list)
                            {
                                button.addClass('push_button');
                                $('#' + btn.list + '_opts').append(button);
                                if (btn.isDefault)
                                {
                                    $('#cur_' + btn.list).append(button.children().clone());
                                    svgicon = btn.svgicon || btn.id;
                                    placement_obj['#cur_' + btn.list] = svgicon
                                }
                            }
                            else if (btn.includeWith)
                            {
                                var opts = btn.includeWith;
                                ref_btn = $(opts.button);
                                flyout_holder = ref_btn.parent();
                                if (!ref_btn.parent().hasClass('tools_flyout'))
                                {
                                    tls_id = ref_btn[0].id.replace('tool_', 'tools_');
                                    show_btn = ref_btn.clone().attr('id', tls_id + '_show').append($('<div>', {'class': 'flyout_arrow_horiz'}));
                                    ref_btn.before(show_btn);
                                    flyout_holder = makeFlyoutHolder(tls_id, ref_btn)
                                }
                                ref_data = Actions.getButtonData(opts.button);
                                if (opts.isDefault)
                                {
                                    placement_obj['#' + tls_id + '_show'] = btn.id
                                }
                                cur_h = holders['#' + flyout_holder[0].id] = [{
                                        sel: '#' + id, fn: btn.events.click, icon: btn.id, key: btn.key, isDefault: btn.includeWith ? btn.includeWith.isDefault : 0
                                    }, ref_data];
                                var pos = ('position' in opts) ? opts.position : 'last';
                                var len = flyout_holder.children().length;
                                if (!isNaN(pos) && pos >= 0 && pos < len)
                                {
                                    flyout_holder.children().eq(pos).before(button)
                                }
                                else
                                {
                                    flyout_holder.append(button);
                                    cur_h.reverse()
                                }
                            }
                            if (!svgicons)
                            {
                                button.append(icon)
                            }
                            if (!btn.list)
                            {
                                $.each(btn.events, function(name, func)
                                {
                                    if (name == 'click' && btn.type == 'mode')
                                    {
                                        if (btn.includeWith)
                                        {
                                            button.bind(name, func)
                                        }
                                        else
                                        {
                                            button.bind(name, function()
                                            {
                                                if (toolButtonClick(button))
                                                {
                                                    func()
                                                }
                                            })
                                        }
                                        if (btn.key)
                                        {
                                            $(document).bind('keydown', btn.key, func);
                                            if (btn.title)
                                            {
                                                button.attr('title', btn.title + ' [' + btn.key + ']')
                                            }
                                        }
                                    }
                                    else
                                    {
                                        button.bind(name, func)
                                    }
                                })
                            }
                            setupFlyouts(holders)
                        });
                        $.each(btn_selects, function()
                        {
                            addAltDropDown(this.elem, this.list, this.callback, {seticon: true})
                        });
                        if (svgicons)
                        {
                            cb_ready = false
                        }
                        $.svgIcons(svgicons, {
                            w: 24, h: 24, id_match: false, no_img: (!svgedit.browser.isWebkit()), fallback: fallback_obj, placement: placement_obj, callback: function(icons)
                                {
                                    if ($.pref('iconsize') !== 'm')
                                    {
                                        prepResize()
                                    }
                                    cb_ready = true;
                                    runCallback()
                                }
                        })
                    }
                    runCallback()
                };
            var getPaint = function(color, opac, type)
                {
                    var opts = {alpha: opac};
                    if (color.indexOf('url(#') === 0)
                    {
                        var refElem = svgCanvas.getRefElem(color);
                        if (refElem)
                        {
                            refElem = refElem.cloneNode(true)
                        }
                        else
                        {
                            refElem = $('#' + type + '_color defs *')[0]
                        }
                        opts[refElem.tagName] = refElem
                    }
                    else if (color.indexOf('#') === 0)
                    {
                        opts.solidColor = color.substr(1)
                    }
                    else
                    {
                        opts.solidColor = 'none'
                    }
                    return new $.jGraduate.Paint(opts)
                };
            $('#text').focus(function()
            {
                textBeingEntered = true
            });
            $('#text').blur(function()
            {
                textBeingEntered = false
            });
            svgCanvas.bind('selected', selectedChanged);
            svgCanvas.bind('transition', elementTransition);
            svgCanvas.bind('changed', elementChanged);
            svgCanvas.bind('saved', saveHandler);
            svgCanvas.bind('exported', exportHandler);
            svgCanvas.bind('zoomed', zoomChanged);
            svgCanvas.bind('contextset', contextChanged);
            svgCanvas.bind('extension_added', extAdded);
            svgCanvas.textActions.setInputElem($('#text')[0]);
            var str = '<div class="palette_item" data-rgb="none"></div>';
            $.each(palette, function(i, item)
            {
                str += '<div class="palette_item" style="background-color: ' + item + ';" data-rgb="' + item + '"></div>'
            });
            $('#palette').append(str);
            var color_blocks = ['#FFF', '#888', '#000'];
            str = '';
            $.each(color_blocks, function()
            {
                str += '<div class="color_block" style="background-color:' + this + ';"></div>'
            });
            $('#bg_blocks').append(str);
            var blocks = $('#bg_blocks div');
            var cur_bg = 'cur_background';
            blocks.each(function()
            {
                var blk = $(this);
                blk.click(function()
                {
                    blocks.removeClass(cur_bg);
                    $(this).addClass(cur_bg)
                })
            });
            setBackground($.pref('bkgd_color'), $.pref('bkgd_url'));
            $('#image_save_opts input').val([$.pref('img_save')]);
            var changeRectRadius = function(ctl)
                {
                    svgCanvas.setRectRadius(ctl.value)
                };
            var changeFontSize = function(ctl)
                {
                    svgCanvas.setFontSize(ctl.value)
                };
            var changeStrokeWidth = function(ctl)
                {
                    var val = ctl.value;
                    if (val == 0 && selectedElement && ['line', 'polyline'].indexOf(selectedElement.nodeName) >= 0)
                    {
                        val = ctl.value = 1
                    }
                    svgCanvas.setStrokeWidth(val)
                };
            var changeRotationAngle = function(ctl)
                {
                    svgCanvas.setRotationAngle(ctl.value);
                    $('#tool_reorient').toggleClass('disabled', parseInt(ctl.value, 10) === 0)
                };
            var changeOpacity = function(ctl, val)
                {
                    if (val == null)
                    {
                        val = ctl.value
                    }
                    $('#group_opacity').val(val);
                    if (!ctl || !ctl.handle)
                    {
                        $('#opac_slider').slider('option', 'value', val)
                    }
                    svgCanvas.setOpacity(val / 100)
                };
            var changeBlur = function(ctl, val, noUndo)
                {
                    if (val == null)
                    {
                        val = ctl.value
                    }
                    $('#blur').val(val);
                    var complete = false;
                    if (!ctl || !ctl.handle)
                    {
                        $('#blur_slider').slider('option', 'value', val);
                        complete = true
                    }
                    if (noUndo)
                    {
                        svgCanvas.setBlurNoUndo(val)
                    }
                    else
                    {
                        svgCanvas.setBlur(val, complete)
                    }
                };
            $('#stroke_style').change(function()
            {
                svgCanvas.setStrokeAttr('stroke-dasharray', $(this).val());
                operaRepaint()
            });
            $('#stroke_linejoin').change(function()
            {
                svgCanvas.setStrokeAttr('stroke-linejoin', $(this).val());
                operaRepaint()
            });
            $('select').change(function()
            {
                $(this).blur()
            });
            var promptMoveLayerOnce = false;
            $('#selLayerNames').change(function()
            {
                var destLayer = this.options[this.selectedIndex].value;
                var confirmStr = uiStrings.notification.QmoveElemsToLayer.replace('%s', destLayer);
                var moveToLayer = function(ok)
                    {
                        if (!ok)
                        {
                            return
                        }
                        promptMoveLayerOnce = true;
                        svgCanvas.moveSelectedToLayer(destLayer);
                        svgCanvas.clearSelection();
                        populateLayers()
                    };
                if (destLayer)
                {
                    if (promptMoveLayerOnce)
                    {
                        moveToLayer(true)
                    }
                    else
                    {
                        $.confirm(confirmStr, moveToLayer)
                    }
                }
            });
            $('#font_family').change(function()
            {
                svgCanvas.setFontFamily(this.value)
            });
            $('#seg_type').change(function()
            {
                svgCanvas.setSegType($(this).val())
            });
            $('#text').keyup(function()
            {
                svgCanvas.setTextContent(this.value)
            });
            $('#image_url').change(function()
            {
                setImageURL(this.value)
            });
            $('#link_url').change(function()
            {
                if (this.value.length)
                {
                    svgCanvas.setLinkURL(this.value)
                }
                else
                {
                    svgCanvas.removeHyperlink()
                }
            });
            $('#g_title').change(function()
            {
                svgCanvas.setGroupTitle(this.value)
            });
            $('.attr_changer').change(function()
            {
                var attr = this.getAttribute('data-attr');
                var val = this.value;
                var valid = svgedit.units.isValidUnit(attr, val, selectedElement);
                if (!valid)
                {
                    $.alert(uiStrings.notification.invalidAttrValGiven);
                    this.value = selectedElement.getAttribute(attr);
                    return false
                }
                if (attr !== 'id')
                {
                    if (isNaN(val))
                    {
                        val = svgCanvas.convertToNum(attr, val)
                    }
                    else if (curConfig.baseUnit !== 'px')
                    {
                        var unitData = svgedit.units.getTypeMap();
                        if (selectedElement[attr] || svgCanvas.getMode() === 'pathedit' || attr === 'x' || attr === 'y')
                        {
                            val *= unitData[curConfig.baseUnit]
                        }
                    }
                }
                if (attr === 'id')
                {
                    var elem = selectedElement;
                    svgCanvas.clearSelection();
                    elem.id = val;
                    svgCanvas.addToSelection([elem], true)
                }
                else
                {
                    svgCanvas.changeSelectedAttribute(attr, val)
                }
                this.blur()
            });
            $('#palette').mouseover(function()
            {
                var inp = $('<input type="hidden">');
                $(this).append(inp);
                inp.focus().remove()
            });
            $('.palette_item').mousedown(function(evt)
            {
                var picker = evt.shiftKey || evt.button === 2 ? 'stroke' : 'fill';
                var color = $(this).data('rgb');
                var paint;
                if (color === 'none' || color === 'transparent' || color === 'initial')
                {
                    color = 'none';
                    paint = new $.jGraduate.Paint
                }
                else
                {
                    paint = new $.jGraduate.Paint({
                        alpha: 100, solidColor: color.substr(1)
                    })
                }
                paintBox[picker].setPaint(paint);
                svgCanvas.setColor(picker, color);
                if (color !== 'none' && svgCanvas.getPaintOpacity(picker) !== 1)
                {
                    svgCanvas.setPaintOpacity(picker, 1.0)
                }
                updateToolButtonState()
            }).bind('contextmenu', function(e)
            {
                e.preventDefault()
            });
            $('#toggle_stroke_tools').on('click', function()
            {
                $('#tools_bottom').toggleClass('expanded')
            });
            (function()
            {
                var last_x = null,
                    last_y = null,
                    w_area = workarea[0],
                    panning = false,
                    keypan = false;
                $('#svgcanvas').bind('mousemove mouseup', function(evt)
                {
                    if (panning === false)
                    {
                        return
                    }
                    w_area.scrollLeft -= (evt.clientX - last_x);
                    w_area.scrollTop -= (evt.clientY - last_y);
                    last_x = evt.clientX;
                    last_y = evt.clientY;
                    if (evt.type === 'mouseup')
                    {
                        panning = false
                    }
                    return false
                }).mousedown(function(evt)
                {
                    if (evt.button === 1 || keypan === true)
                    {
                        panning = true;
                        last_x = evt.clientX;
                        last_y = evt.clientY;
                        return false
                    }
                });
                $(window).mouseup(function()
                {
                    panning = false
                });
                $(document).bind('keydown', 'space', function(evt)
                {
                    svgCanvas.spaceKey = keypan = true;
                    evt.preventDefault()
                }).bind('keyup', 'space', function(evt)
                {
                    evt.preventDefault();
                    svgCanvas.spaceKey = keypan = false
                }).bind('keydown', 'shift', function(evt)
                {
                    if (svgCanvas.getMode() === 'zoom')
                    {
                        workarea.css('cursor', zoomOutIcon)
                    }
                }).bind('keyup', 'shift', function(evt)
                {
                    if (svgCanvas.getMode() === 'zoom')
                    {
                        workarea.css('cursor', zoomInIcon)
                    }
                });
                editor.setPanning = function(active)
                {
                    svgCanvas.spaceKey = keypan = active
                }
            }());
            (function()
            {
                var button = $('#main_icon');
                var overlay = $('#main_icon span');
                var list = $('#main_menu');
                var on_button = false;
                var height = 0;
                var js_hover = true;
                var set_click = false;
                $(window).mouseup(function(evt)
                {
                    if (!on_button)
                    {
                        button.removeClass('buttondown');
                        if (evt.target.tagName != 'INPUT')
                        {
                            list.fadeOut(200)
                        }
                        else if (!set_click)
                        {
                            set_click = true;
                            $(evt.target).click(function()
                            {
                                list.css('margin-left', '-9999px').show()
                            })
                        }
                    }
                    on_button = false
                }).mousedown(function(evt)
                {
                    var islib = $(evt.target).closest('div.tools_flyout, .contextMenu').length;
                    if (!islib)
                    {
                        $('.tools_flyout:visible,.contextMenu').fadeOut(250)
                    }
                });
                overlay.bind('mousedown', function()
                {
                    if (!button.hasClass('buttondown'))
                    {
                        list.css('margin-left', 0).show();
                        if (!height)
                        {
                            height = list.height()
                        }
                        list.css('height', 0).animate({height: height}, 200);
                        on_button = true
                    }
                    else
                    {
                        list.fadeOut(200)
                    }
                    button.toggleClass('buttondown buttonup')
                }).hover(function()
                {
                    on_button = true
                }).mouseout(function()
                {
                    on_button = false
                });
                var list_items = $('#main_menu li');
                list_items.mouseover(function()
                {
                    js_hover = ($(this).css('background-color') == 'rgba(0, 0, 0, 0)');
                    list_items.unbind('mouseover');
                    if (js_hover)
                    {
                        list_items.mouseover(function()
                        {
                            this.style.backgroundColor = '#FFC'
                        }).mouseout(function()
                        {
                            this.style.backgroundColor = 'transparent';
                            return true
                        })
                    }
                })
            }());
            editor.addDropDown = function(elem, callback, dropUp)
            {
                if ($(elem).length == 0)
                {
                    return
                }
                var button = $(elem).find('button');
                var list = $(elem).find('ul').attr('id', $(elem)[0].id + '-list');
                var on_button = false;
                if (dropUp)
                {
                    $(elem).addClass('dropup')
                }
                else
                {
                    $('#option_lists').append(list)
                }
                list.find('li').bind('mouseup', callback);
                $(window).mouseup(function(evt)
                {
                    if (!on_button)
                    {
                        button.removeClass('down');
                        list.hide()
                    }
                    on_button = false
                });
                button.bind('mousedown', function()
                {
                    if (!button.hasClass('down'))
                    {
                        if (!dropUp)
                        {
                            var pos = $(elem).position();
                            list.css({
                                top: pos.top + 24, left: pos.left - 10
                            })
                        }
                        list.show();
                        on_button = true
                    }
                    else
                    {
                        list.hide()
                    }
                    button.toggleClass('down')
                }).hover(function()
                {
                    on_button = true
                }).mouseout(function()
                {
                    on_button = false
                })
            };
            editor.addDropDown('#font_family_dropdown', function()
            {
                $('#font_family').val($(this).text()).change()
            });
            editor.addDropDown('#opacity_dropdown', function()
            {
                if ($(this).find('div').length)
                {
                    return
                }
                var perc = parseInt($(this).text().split('%')[0], 10);
                changeOpacity(false, perc)
            }, true);
            $('#opac_slider').slider({
                start: function()
                {
                    $('#opacity_dropdown li:not(.special)').hide()
                }, stop: function()
                    {
                        $('#opacity_dropdown li').show();
                        $(window).mouseup()
                    }, slide: function(evt, ui)
                    {
                        changeOpacity(ui)
                    }
            });
            editor.addDropDown('#blur_dropdown', $.noop);
            var slideStart = false;
            $('#blur_slider').slider({
                max: 10, step: 0.1, stop: function(evt, ui)
                    {
                        slideStart = false;
                        changeBlur(ui);
                        $('#blur_dropdown li').show();
                        $(window).mouseup()
                    }, start: function()
                    {
                        slideStart = true
                    }, slide: function(evt, ui)
                    {
                        changeBlur(ui, null, slideStart)
                    }
            });
            editor.addDropDown('#zoom_dropdown', function()
            {
                var item = $(this);
                var val = item.data('val');
                if (val)
                {
                    zoomChanged(window, val)
                }
                else
                {
                    changeZoom({value: parseFloat(item.text())})
                }
            }, true);
            addAltDropDown('#stroke_linecap', '#linecap_opts', function()
            {
                setStrokeOpt(this, true)
            }, {dropUp: true});
            addAltDropDown('#stroke_linejoin', '#linejoin_opts', function()
            {
                setStrokeOpt(this, true)
            }, {dropUp: true});
            addAltDropDown('#tool_position', '#position_opts', function()
            {
                var letter = this.id.replace('tool_pos', '').charAt(0);
                svgCanvas.alignSelectedElements(letter, 'page')
            }, {multiclick: true});
            (function()
            {
                var inp;
                var unfocus = function()
                    {
                        $(inp).blur()
                    };
                $('#svg_editor').find('button, select, input:not(#text)').focus(function()
                {
                    inp = this;
                    ui_context = 'toolbars';
                    workarea.mousedown(unfocus)
                }).blur(function()
                {
                    ui_context = 'canvas';
                    workarea.unbind('mousedown', unfocus);
                    if (svgCanvas.getMode() == 'textedit')
                    {
                        $('#text').focus()
                    }
                })
            }());
            var clickFHPath = function()
                {
                    if (toolButtonClick('#tool_fhpath'))
                    {
                        svgCanvas.setMode('fhpath')
                    }
                };
            var clickLine = function()
                {
                    if (toolButtonClick('#tool_line'))
                    {
                        svgCanvas.setMode('line')
                    }
                };
            var clickSquare = function()
                {
                    if (toolButtonClick('#tool_square'))
                    {
                        svgCanvas.setMode('square')
                    }
                };
            var clickRect = function()
                {
                    if (toolButtonClick('#tool_rect'))
                    {
                        svgCanvas.setMode('rect')
                    }
                };
            var clickFHRect = function()
                {
                    if (toolButtonClick('#tool_fhrect'))
                    {
                        svgCanvas.setMode('fhrect')
                    }
                };
            var clickCircle = function()
                {
                    if (toolButtonClick('#tool_circle'))
                    {
                        svgCanvas.setMode('circle')
                    }
                };
            var clickEllipse = function()
                {
                    if (toolButtonClick('#tool_ellipse'))
                    {
                        svgCanvas.setMode('ellipse')
                    }
                };
            var clickFHEllipse = function()
                {
                    if (toolButtonClick('#tool_fhellipse'))
                    {
                        svgCanvas.setMode('fhellipse')
                    }
                };
            var clickImage = function()
                {
                    if (toolButtonClick('#tool_image'))
                    {
                        svgCanvas.setMode('image')
                    }
                };
            var clickZoom = function()
                {
                    if (toolButtonClick('#tool_zoom'))
                    {
                        svgCanvas.setMode('zoom');
                        workarea.css('cursor', zoomInIcon)
                    }
                };
            var zoomImage = function(multiplier)
                {
                    var res = svgCanvas.getResolution();
                    multiplier = multiplier ? res.zoom * multiplier : 1;
                    $('#zoom').val(multiplier * 100);
                    svgCanvas.setZoom(multiplier);
                    zoomDone();
                    updateCanvas(true)
                };
            var dblclickZoom = function()
                {
                    if (toolButtonClick('#tool_zoom'))
                    {
                        zoomImage();
                        setSelectMode()
                    }
                };
            var clickText = function()
                {
                    if (toolButtonClick('#tool_text'))
                    {
                        svgCanvas.setMode('text')
                    }
                };
            var clickPath = function()
                {
                    if (toolButtonClick('#tool_path'))
                    {
                        svgCanvas.setMode('path')
                    }
                };
            var deleteSelected = function()
                {
                    if (selectedElement != null || multiselected)
                    {
                        svgCanvas.deleteSelectedElements()
                    }
                };
            var cutSelected = function()
                {
                    if (selectedElement != null || multiselected)
                    {
                        svgCanvas.cutSelectedElements()
                    }
                };
            var copySelected = function()
                {
                    if (selectedElement != null || multiselected)
                    {
                        svgCanvas.copySelectedElements()
                    }
                };
            var pasteInCenter = function()
                {
                    var zoom = svgCanvas.getZoom();
                    var x = (workarea[0].scrollLeft + workarea.width() / 2) / zoom - svgCanvas.contentW;
                    var y = (workarea[0].scrollTop + workarea.height() / 2) / zoom - svgCanvas.contentH;
                    svgCanvas.pasteElements('point', x, y)
                };
            var moveToTopSelected = function()
                {
                    if (selectedElement != null)
                    {
                        svgCanvas.moveToTopSelectedElement()
                    }
                };
            var moveToBottomSelected = function()
                {
                    if (selectedElement != null)
                    {
                        svgCanvas.moveToBottomSelectedElement()
                    }
                };
            var moveUpDownSelected = function(dir)
                {
                    if (selectedElement != null)
                    {
                        svgCanvas.moveUpDownSelected(dir)
                    }
                };
            var convertToPath = function()
                {
                    if (selectedElement != null)
                    {
                        svgCanvas.convertToPath()
                    }
                };
            var reorientPath = function()
                {
                    if (selectedElement != null)
                    {
                        path.reorient()
                    }
                };
            var makeHyperlink = function()
                {
                    if (selectedElement != null || multiselected)
                    {
                        $.prompt(uiStrings.notification.enterNewLinkURL, 'http://', function(url)
                        {
                            if (url)
                            {
                                svgCanvas.makeHyperlink(url)
                            }
                        })
                    }
                };
            var moveSelected = function(dx, dy)
                {
                    if (selectedElement != null || multiselected)
                    {
                        if (curConfig.gridSnapping)
                        {
                            var multi = svgCanvas.getZoom() * curConfig.snappingStep;
                            dx *= multi;
                            dy *= multi
                        }
                        svgCanvas.moveSelectedElements(dx, dy)
                    }
                };
            var linkControlPoints = function()
                {
                    $('#tool_node_link').toggleClass('push_button_pressed tool_button');
                    var linked = $('#tool_node_link').hasClass('push_button_pressed');
                    path.linkControlPoints(linked)
                };
            var clonePathNode = function()
                {
                    if (path.getNodePoint())
                    {
                        path.clonePathNode()
                    }
                };
            var deletePathNode = function()
                {
                    if (path.getNodePoint())
                    {
                        path.deletePathNode()
                    }
                };
            var addSubPath = function()
                {
                    var button = $('#tool_add_subpath');
                    var sp = !button.hasClass('push_button_pressed');
                    button.toggleClass('push_button_pressed tool_button');
                    path.addSubPath(sp)
                };
            var opencloseSubPath = function()
                {
                    path.opencloseSubPath()
                };
            var selectNext = function()
                {
                    svgCanvas.cycleElement(1)
                };
            var selectPrev = function()
                {
                    svgCanvas.cycleElement(0)
                };
            var rotateSelected = function(cw, step)
                {
                    if (selectedElement == null || multiselected)
                    {
                        return
                    }
                    if (!cw)
                    {
                        step *= -1
                    }
                    var angle = parseFloat($('#angle').val()) + step;
                    svgCanvas.setRotationAngle(angle);
                    updateContextPanel()
                };
            var clickClear = function()
                {
                    var dims = curConfig.dimensions;
                    $.confirm(uiStrings.notification.QwantToClear, function(ok)
                    {
                        if (!ok)
                        {
                            return
                        }
                        setSelectMode();
                        svgCanvas.clear();
                        svgCanvas.setResolution(dims[0], dims[1]);
                        updateCanvas(true);
                        zoomImage();
                        populateLayers();
                        updateContextPanel();
                        prepPaints();
                        svgCanvas.runExtensions('onNewDocument')
                    })
                };
            var clickBold = function()
                {
                    svgCanvas.setBold(!svgCanvas.getBold());
                    updateContextPanel();
                    return false
                };
            var clickItalic = function()
                {
                    svgCanvas.setItalic(!svgCanvas.getItalic());
                    updateContextPanel();
                    return false
                };
            var clickSave = function()
                {
                    var saveOpts = {
                            images: $.pref('img_save'), round_digits: 6
                        };
                    svgCanvas.save(saveOpts)
                };
            var clickExport = function()
                {
                    $.select('Select an image type for export: ', ['PNG', 'JPEG', 'BMP', 'WEBP'], function(imgType)
                    {
                        if (!imgType)
                        {
                            return
                        }
                        if (!customHandlers.exportImage && !customHandlers.pngsave)
                        {
                            var str = uiStrings.notification.loadingImage;
                            exportWindow = window.open('data:text/html;charset=utf-8,<title>' + str + '<\/title><h1>' + str + '<\/h1>')
                        }
                        var quality = parseInt($('#image-slider').val(), 10) / 100;
                        if (window.canvg)
                        {
                            svgCanvas.rasterExport(imgType, quality)
                        }
                        else
                        {
                            $.getScript('canvg/rgbcolor.js', function()
                            {
                                $.getScript('canvg/canvg.js', function()
                                {
                                    svgCanvas.rasterExport(imgType, quality)
                                })
                            })
                        }
                    }, function()
                    {
                        var sel = $(this);
                        if (sel.val() === 'JPEG' || sel.val() === 'WEBP')
                        {
                            if (!$('#image-slider').length)
                            {
                                $('<div><label>Quality: <input id="image-slider" type="range" min="1" max="100" value="92" /></label></div>').appendTo(sel.parent())
                            }
                        }
                        else
                        {
                            $('#image-slider').parent().remove()
                        }
                    })
                };
            var clickOpen = function()
                {
                    svgCanvas.open()
                };
            var clickImport = function(){};
            var clickUndo = function()
                {
                    if (undoMgr.getUndoStackSize() > 0)
                    {
                        undoMgr.undo();
                        populateLayers()
                    }
                };
            var clickRedo = function()
                {
                    if (undoMgr.getRedoStackSize() > 0)
                    {
                        undoMgr.redo();
                        populateLayers()
                    }
                };
            var clickGroup = function()
                {
                    if (multiselected)
                    {
                        svgCanvas.groupSelectedElements()
                    }
                    else if (selectedElement)
                    {
                        svgCanvas.ungroupSelectedElement()
                    }
                };
            var clickClone = function()
                {
                    svgCanvas.cloneSelectedElements(20, 20)
                };
            var clickAlign = function()
                {
                    var letter = this.id.replace('tool_align', '').charAt(0);
                    svgCanvas.alignSelectedElements(letter, $('#align_relative_to').val())
                };
            var clickWireframe = function()
                {
                    $('#tool_wireframe').toggleClass('push_button_pressed tool_button');
                    workarea.toggleClass('wireframe');
                    if (supportsNonSS)
                    {
                        return
                    }
                    var wf_rules = $('#wireframe_rules');
                    if (!wf_rules.length)
                    {
                        wf_rules = $('<style id="wireframe_rules"><\/style>').appendTo('head')
                    }
                    else
                    {
                        wf_rules.empty()
                    }
                    updateWireFrame()
                };
            $('#svg_docprops_container, #svg_prefs_container').draggable({
                cancel: 'button,fieldset', containment: 'window'
            });
            var showDocProperties = function()
                {
                    if (docprops)
                    {
                        return
                    }
                    docprops = true;
                    $('#image_save_opts input').val([$.pref('img_save')]);
                    var res = svgCanvas.getResolution();
                    if (curConfig.baseUnit !== 'px')
                    {
                        res.w = svgedit.units.convertUnit(res.w) + curConfig.baseUnit;
                        res.h = svgedit.units.convertUnit(res.h) + curConfig.baseUnit
                    }
                    $('#canvas_width').val(res.w);
                    $('#canvas_height').val(res.h);
                    $('#canvas_title').val(svgCanvas.getDocumentTitle());
                    $('#svg_docprops').show()
                };
            var showPreferences = function()
                {
                    if (preferences)
                    {
                        return
                    }
                    preferences = true;
                    $('#main_menu').hide();
                    var blocks = $('#bg_blocks div');
                    var cur_bg = 'cur_background';
                    var canvas_bg = curPrefs.bkgd_color;
                    var url = $.pref('bkgd_url');
                    blocks.each(function()
                    {
                        var blk = $(this);
                        var is_bg = blk.css('background-color') == canvas_bg;
                        blk.toggleClass(cur_bg, is_bg);
                        if (is_bg)
                        {
                            $('#canvas_bg_url').removeClass(cur_bg)
                        }
                    });
                    if (!canvas_bg)
                    {
                        blocks.eq(0).addClass(cur_bg)
                    }
                    if (url)
                    {
                        $('#canvas_bg_url').val(url)
                    }
                    $('#grid_snapping_on').prop('checked', curConfig.gridSnapping);
                    $('#grid_snapping_step').attr('value', curConfig.snappingStep);
                    $('#grid_color').attr('value', curConfig.gridColor);
                    $('#svg_prefs').show()
                };
            var hideSourceEditor = function()
                {
                    $('#svg_source_editor').hide();
                    editingsource = false;
                    $('#svg_source_textarea').blur()
                };
            var saveSourceEditor = function()
                {
                    if (!editingsource)
                    {
                        return
                    }
                    var saveChanges = function()
                        {
                            svgCanvas.clearSelection();
                            hideSourceEditor();
                            zoomImage();
                            populateLayers();
                            updateTitle();
                            prepPaints()
                        };
                    if (!svgCanvas.setSvgString($('#svg_source_textarea').val()))
                    {
                        $.confirm(uiStrings.notification.QerrorsRevertToSource, function(ok)
                        {
                            if (!ok)
                            {
                                return false
                            }
                            saveChanges()
                        })
                    }
                    else
                    {
                        saveChanges()
                    }
                    setSelectMode()
                };
            var hideDocProperties = function()
                {
                    $('#svg_docprops').hide();
                    $('#canvas_width,#canvas_height').removeAttr('disabled');
                    $('#resolution')[0].selectedIndex = 0;
                    $('#image_save_opts input').val([$.pref('img_save')]);
                    docprops = false
                };
            var hidePreferences = function()
                {
                    $('#svg_prefs').hide();
                    preferences = false
                };
            var saveDocProperties = function()
                {
                    var newTitle = $('#canvas_title').val();
                    updateTitle(newTitle);
                    svgCanvas.setDocumentTitle(newTitle);
                    var width = $('#canvas_width'),
                        w = width.val();
                    var height = $('#canvas_height'),
                        h = height.val();
                    if (w != 'fit' && !svgedit.units.isValidUnit('width', w))
                    {
                        $.alert(uiStrings.notification.invalidAttrValGiven);
                        width.parent().addClass('error');
                        return false
                    }
                    width.parent().removeClass('error');
                    if (h != 'fit' && !svgedit.units.isValidUnit('height', h))
                    {
                        $.alert(uiStrings.notification.invalidAttrValGiven);
                        height.parent().addClass('error');
                        return false
                    }
                    height.parent().removeClass('error');
                    if (!svgCanvas.setResolution(w, h))
                    {
                        $.alert(uiStrings.notification.noContentToFitTo);
                        return false
                    }
                    $.pref('img_save', $('#image_save_opts :checked').val());
                    updateCanvas();
                    hideDocProperties()
                };
            var savePreferences = editor.savePreferences = function()
                {
                    var color = $('#bg_blocks div.cur_background').css('background-color') || '#FFF';
                    setBackground(color, $('#canvas_bg_url').val());
                    var lang = $('#lang_select').val();
                    if (lang !== $.pref('lang'))
                    {
                        editor.putLocale(lang, good_langs)
                    }
                    setIconSize($('#iconsize').val());
                    curConfig.gridSnapping = $('#grid_snapping_on')[0].checked;
                    curConfig.snappingStep = $('#grid_snapping_step').val();
                    curConfig.gridColor = $('#grid_color').val();
                    curConfig.showRulers = $('#show_rulers')[0].checked;
                    $('#rulers').toggle(curConfig.showRulers);
                    if (curConfig.showRulers)
                    {
                        updateRulers()
                    }
                    curConfig.baseUnit = $('#base_unit').val();
                    svgCanvas.setConfig(curConfig);
                    updateCanvas();
                    hidePreferences()
                };
            var resetScrollPos = $.noop;
            var cancelOverlays = function()
                {
                    $('#dialog_box').hide();
                    if (!editingsource && !docprops && !preferences)
                    {
                        if (cur_context)
                        {
                            svgCanvas.leaveContext()
                        }
                        return
                    }
                    if (editingsource)
                    {
                        if (origSource !== $('#svg_source_textarea').val())
                        {
                            $.confirm(uiStrings.notification.QignoreSourceChanges, function(ok)
                            {
                                if (ok)
                                {
                                    hideSourceEditor()
                                }
                            })
                        }
                        else
                        {
                            hideSourceEditor()
                        }
                    }
                    else if (docprops)
                    {
                        hideDocProperties()
                    }
                    else if (preferences)
                    {
                        hidePreferences()
                    }
                    resetScrollPos()
                };
            var win_wh = {
                    width: $(window).width(), height: $(window).height()
                };
            if (svgedit.browser.isIE())
            {
                (function()
                {
                    resetScrollPos = function()
                    {
                        if (workarea[0].scrollLeft === 0 && workarea[0].scrollTop === 0)
                        {
                            workarea[0].scrollLeft = curScrollPos.left;
                            workarea[0].scrollTop = curScrollPos.top
                        }
                    };
                    curScrollPos = {
                        left: workarea[0].scrollLeft, top: workarea[0].scrollTop
                    };
                    $(window).resize(resetScrollPos);
                    editor.ready(function()
                    {
                        setTimeout(function()
                        {
                            resetScrollPos()
                        }, 500)
                    });
                    workarea.scroll(function()
                    {
                        curScrollPos = {
                            left: workarea[0].scrollLeft, top: workarea[0].scrollTop
                        }
                    })
                }())
            }
            $(window).resize(function(evt)
            {
                $.each(win_wh, function(type, val)
                {
                    var curval = $(window)[type]();
                    workarea[0]['scroll' + (type === 'width' ? 'Left' : 'Top')] -= (curval - val) / 2;
                    win_wh[type] = curval
                });
                setFlyoutPositions()
            });
            (function()
            {
                workarea.scroll(function()
                {
                    if ($('#ruler_x').length != 0)
                    {
                        $('#ruler_x')[0].scrollLeft = workarea[0].scrollLeft
                    }
                    if ($('#ruler_y').length != 0)
                    {
                        $('#ruler_y')[0].scrollTop = workarea[0].scrollTop
                    }
                })
            }());
            $('#url_notice').click(function()
            {
                $.alert(this.title)
            });
            $('#change_image_url').click(promptImgURL);
            (function()
            {
                var toolnames = ['clear', 'open', 'save', 'source', 'delete', 'delete_multi', 'paste', 'clone', 'clone_multi', 'move_top', 'move_bottom'];
                var all_tools = '';
                var cur_class = 'tool_button_current';
                $.each(toolnames, function(i, item)
                {
                    all_tools += '#tool_' + item + (i < toolnames.length - 1 ? ',' : '')
                });
                $(all_tools).mousedown(function()
                {
                    $(this).addClass(cur_class)
                }).bind('mousedown mouseout', function()
                {
                    $(this).removeClass(cur_class)
                });
                $('#tool_undo, #tool_redo').mousedown(function()
                {
                    if (!$(this).hasClass('disabled'))
                    {
                        $(this).addClass(cur_class)
                    }
                }).bind('mousedown mouseout', function()
                {
                    $(this).removeClass(cur_class)
                })
            }());
            if (svgedit.browser.isMac() && !window.opera)
            {
                var shortcutButtons = ['tool_clear', 'tool_save', 'tool_source', 'tool_undo', 'tool_redo', 'tool_clone'];
                i = shortcutButtons.length;
                while (i--)
                {
                    var button = document.getElementById(shortcutButtons[i]);
                    if (button)
                    {
                        var title = button.title;
                        var index = title.indexOf('Ctrl+');
                        button.title = [title.substr(0, index), 'Cmd+', title.substr(index + 5)].join('')
                    }
                }
            }
            var colorPicker = function(elem)
                {
                    var picker = elem.attr('id') == 'stroke_color' ? 'stroke' : 'fill';
                    var paint = paintBox[picker].paint;
                    var title = (picker == 'stroke' ? 'Pick a Stroke Paint and Opacity' : 'Pick a Fill Paint and Opacity');
                    var pos = elem.offset();
                    $('#color_picker').draggable({
                        cancel: '.jGraduate_tabs, .jGraduate_colPick, .jGraduate_gradPick, .jPicker', containment: 'window'
                    }).css(curConfig.colorPickerCSS || {
                        left: pos.left - 140, bottom: 40
                    }).jGraduate({
                        paint: paint, window: {pickerTitle: title}, images: {clientPath: curConfig.jGraduatePath}, newstop: 'inverse'
                    }, function(p)
                    {
                        paint = new $.jGraduate.Paint(p);
                        paintBox[picker].setPaint(paint);
                        svgCanvas.setPaint(picker, paint);
                        $('#color_picker').hide()
                    }, function()
                    {
                        $('#color_picker').hide()
                    })
                };
            var PaintBox = function(container, type)
                {
                    var paintColor,
                        paintOpacity,
                        cur = curConfig[type === 'fill' ? 'initFill' : 'initStroke'];
                    var svgdocbox = (new DOMParser).parseFromString('<svg xmlns="http://www.w3.org/2000/svg"><rect width="16.5" height="16.5"' + '					fill="#' + cur.color + '" opacity="' + cur.opacity + '"/>' + '					<defs><linearGradient id="gradbox_"/></defs></svg>', 'text/xml');
                    var docElem = svgdocbox.documentElement;
                    docElem = $(container)[0].appendChild(document.importNode(docElem, true));
                    docElem.setAttribute('width', 16.5);
                    this.rect = docElem.firstChild;
                    this.defs = docElem.getElementsByTagName('defs')[0];
                    this.grad = this.defs.firstChild;
                    this.paint = new $.jGraduate.Paint({solidColor: cur.color});
                    this.type = type;
                    this.setPaint = function(paint, apply)
                    {
                        this.paint = paint;
                        var fillAttr = 'none';
                        var ptype = paint.type;
                        var opac = paint.alpha / 100;
                        switch (ptype)
                        {
                            case'solidColor':
                                fillAttr = (paint[ptype] != 'none') ? '#' + paint[ptype] : paint[ptype];
                                break;
                            case'linearGradient':
                            case'radialGradient':
                                this.defs.removeChild(this.grad);
                                this.grad = this.defs.appendChild(paint[ptype]);
                                var id = this.grad.id = 'gradbox_' + this.type;
                                fillAttr = 'url(#' + id + ')';
                                break
                        }
                        this.rect.setAttribute('fill', fillAttr);
                        this.rect.setAttribute('opacity', opac);
                        if (apply)
                        {
                            svgCanvas.setColor(this.type, paintColor, true);
                            svgCanvas.setPaintOpacity(this.type, paintOpacity, true)
                        }
                    };
                    this.update = function(apply)
                    {
                        if (!selectedElement)
                        {
                            return
                        }
                        var i,
                            len;
                        var type = this.type;
                        switch (selectedElement.tagName)
                        {
                            case'use':
                            case'image':
                            case'foreignObject':
                                return;
                            case'g':
                            case'a':
                                var gPaint = null;
                                var childs = selectedElement.getElementsByTagName('*');
                                for (i = 0, len = childs.length; i < len; i++)
                                {
                                    var elem = childs[i];
                                    var p = elem.getAttribute(type);
                                    if (i === 0)
                                    {
                                        gPaint = p
                                    }
                                    else if (gPaint !== p)
                                    {
                                        gPaint = null;
                                        break
                                    }
                                }
                                if (gPaint === null)
                                {
                                    paintColor = null;
                                    return
                                }
                                paintColor = gPaint;
                                paintOpacity = 1;
                                break;
                            default:
                                paintOpacity = parseFloat(selectedElement.getAttribute(type + '-opacity'));
                                if (isNaN(paintOpacity))
                                {
                                    paintOpacity = 1.0
                                }
                                var defColor = type === 'fill' ? 'black' : 'none';
                                paintColor = selectedElement.getAttribute(type) || defColor
                        }
                        if (apply)
                        {
                            svgCanvas.setColor(type, paintColor, true);
                            svgCanvas.setPaintOpacity(type, paintOpacity, true)
                        }
                        paintOpacity *= 100;
                        var paint = getPaint(paintColor, paintOpacity, type);
                        this.setPaint(paint)
                    };
                    this.prep = function()
                    {
                        var ptype = this.paint.type;
                        switch (ptype)
                        {
                            case'linearGradient':
                            case'radialGradient':
                                var paint = new $.jGraduate.Paint({copy: this.paint});
                                svgCanvas.setPaint(type, paint);
                                break
                        }
                    }
                };
            paintBox.fill = new PaintBox('#fill_color', 'fill');
            paintBox.stroke = new PaintBox('#stroke_color', 'stroke');
            $('#stroke_width').val(curConfig.initStroke.width);
            $('#group_opacity').val(curConfig.initOpacity * 100);
            var testEl = paintBox.fill.rect.cloneNode(false);
            testEl.setAttribute('style', 'vector-effect:non-scaling-stroke');
            supportsNonSS = (testEl.style.vectorEffect === 'non-scaling-stroke');
            testEl.removeAttribute('style');
            var svgdocbox = paintBox.fill.rect.ownerDocument;
            var blurTest = svgdocbox.createElementNS(svgedit.NS.SVG, 'feGaussianBlur');
            if (blurTest.stdDeviationX === undefined)
            {
                $('#tool_blur').hide()
            }
            $(blurTest).remove();
            (function()
            {
                var pre = '-' + uaPrefix.toLowerCase() + '-zoom-';
                var zoom = pre + 'in';
                workarea.css('cursor', zoom);
                if (workarea.css('cursor') === zoom)
                {
                    zoomInIcon = zoom;
                    zoomOutIcon = pre + 'out'
                }
                workarea.css('cursor', 'auto')
            }());
            setTimeout(function()
            {
                svgCanvas.embedImage('images/logo.png', function(datauri)
                {
                    if (!datauri)
                    {
                        $('#image_save_opts [value=embed]').attr('disabled', 'disabled');
                        $('#image_save_opts input').val(['ref']);
                        $.pref('img_save', 'ref');
                        $('#image_opt_embed').css('color', '#666').attr('title', uiStrings.notification.featNotSupported)
                    }
                })
            }, 1000);
            $('#fill_color, #tool_fill .icon_label').click(function()
            {
                colorPicker($('#fill_color'));
                updateToolButtonState()
            });
            $('#stroke_color, #tool_stroke .icon_label').click(function()
            {
                colorPicker($('#stroke_color'));
                updateToolButtonState()
            });
            $('#group_opacityLabel').click(function()
            {
                $('#opacity_dropdown button').mousedown();
                $(window).mouseup()
            });
            $('#zoomLabel').click(function()
            {
                $('#zoom_dropdown button').mousedown();
                $(window).mouseup()
            });
            $('#tool_move_top').mousedown(function(evt)
            {
                $('#tools_stacking').show();
                evt.preventDefault()
            });
            $('.layer_button').mousedown(function()
            {
                $(this).addClass('layer_buttonpressed')
            }).mouseout(function()
            {
                $(this).removeClass('layer_buttonpressed')
            }).mouseup(function()
            {
                $(this).removeClass('layer_buttonpressed')
            });
            $('.push_button').mousedown(function()
            {
                if (!$(this).hasClass('disabled'))
                {
                    $(this).addClass('push_button_pressed').removeClass('push_button')
                }
            }).mouseout(function()
            {
                $(this).removeClass('push_button_pressed').addClass('push_button')
            }).mouseup(function()
            {
                $(this).removeClass('push_button_pressed').addClass('push_button')
            });
            $('#layer_new').click(function()
            {
                var uniqName,
                    i = svgCanvas.getCurrentDrawing().getNumLayers();
                do
                    uniqName = uiStrings.layers.layer + ' ' + (++i);
                while (svgCanvas.getCurrentDrawing().hasLayer(uniqName));
                $.prompt(uiStrings.notification.enterUniqueLayerName, uniqName, function(newName)
                {
                    if (!newName)
                    {
                        return
                    }
                    if (svgCanvas.getCurrentDrawing().hasLayer(newName))
                    {
                        $.alert(uiStrings.notification.dupeLayerName);
                        return
                    }
                    svgCanvas.createLayer(newName);
                    updateContextPanel();
                    populateLayers()
                })
            });
            function deleteLayer()
            {
                if (svgCanvas.deleteCurrentLayer())
                {
                    updateContextPanel();
                    populateLayers();
                    $('#layerlist tr.layer').removeClass('layersel');
                    $('#layerlist tr.layer:first').addClass('layersel')
                }
            }
            function cloneLayer()
            {
                var name = svgCanvas.getCurrentDrawing().getCurrentLayerName() + ' copy';
                $.prompt(uiStrings.notification.enterUniqueLayerName, name, function(newName)
                {
                    if (!newName)
                    {
                        return
                    }
                    if (svgCanvas.getCurrentDrawing().hasLayer(newName))
                    {
                        $.alert(uiStrings.notification.dupeLayerName);
                        return
                    }
                    svgCanvas.cloneLayer(newName);
                    updateContextPanel();
                    populateLayers()
                })
            }
            function mergeLayer()
            {
                if ($('#layerlist tr.layersel').index() == svgCanvas.getCurrentDrawing().getNumLayers() - 1)
                {
                    return
                }
                svgCanvas.mergeLayer();
                updateContextPanel();
                populateLayers()
            }
            function moveLayer(pos)
            {
                var curIndex = $('#layerlist tr.layersel').index();
                var total = svgCanvas.getCurrentDrawing().getNumLayers();
                if (curIndex > 0 || curIndex < total - 1)
                {
                    curIndex += pos;
                    svgCanvas.setCurrentLayerPosition(total - curIndex - 1);
                    populateLayers()
                }
            }
            $('#layer_delete').click(deleteLayer);
            $('#layer_up').click(function()
            {
                moveLayer(-1)
            });
            $('#layer_down').click(function()
            {
                moveLayer(1)
            });
            $('#layer_rename').click(function()
            {
                var oldName = $('#layerlist tr.layersel td.layername').text();
                $.prompt(uiStrings.notification.enterNewLayerName, '', function(newName)
                {
                    if (!newName)
                    {
                        return
                    }
                    if (oldName == newName || svgCanvas.getCurrentDrawing().hasLayer(newName))
                    {
                        $.alert(uiStrings.notification.layerHasThatName);
                        return
                    }
                    svgCanvas.renameCurrentLayer(newName);
                    populateLayers()
                })
            });
            var SIDEPANEL_MAXWIDTH = 300;
            var SIDEPANEL_OPENWIDTH = 150;
            var sidedrag = -1,
                sidedragging = false,
                allowmove = false;
            var changeSidePanelWidth = function(delta)
                {
                    var rulerX = $('#ruler_x');
                    $('#sidepanels').width('+=' + delta);
                    $('#layerpanel').width('+=' + delta);
                    rulerX.css('right', parseInt(rulerX.css('right'), 10) + delta);
                    workarea.css('right', parseInt(workarea.css('right'), 10) + delta);
                    svgCanvas.runExtensions("workareaResized")
                };
            var resizeSidePanel = function(evt)
                {
                    if (!allowmove)
                    {
                        return
                    }
                    if (sidedrag == -1)
                    {
                        return
                    }
                    sidedragging = true;
                    var deltaX = sidedrag - evt.pageX;
                    var sideWidth = $('#sidepanels').width();
                    if (sideWidth + deltaX > SIDEPANEL_MAXWIDTH)
                    {
                        deltaX = SIDEPANEL_MAXWIDTH - sideWidth;
                        sideWidth = SIDEPANEL_MAXWIDTH
                    }
                    else if (sideWidth + deltaX < 2)
                    {
                        deltaX = 2 - sideWidth;
                        sideWidth = 2
                    }
                    if (deltaX == 0)
                    {
                        return
                    }
                    sidedrag -= deltaX;
                    changeSidePanelWidth(deltaX)
                };
            var toggleSidePanel = function(close)
                {
                    var w = $('#sidepanels').width();
                    var deltaX = (w > 2 || close ? 2 : SIDEPANEL_OPENWIDTH) - w;
                    changeSidePanelWidth(deltaX)
                };
            $('#sidepanel_handle').mousedown(function(evt)
            {
                sidedrag = evt.pageX;
                $(window).mousemove(resizeSidePanel);
                allowmove = false;
                setTimeout(function()
                {
                    allowmove = true
                }, 20)
            }).mouseup(function(evt)
            {
                if (!sidedragging)
                {
                    toggleSidePanel()
                }
                sidedrag = -1;
                sidedragging = false
            });
            $(window).mouseup(function()
            {
                sidedrag = -1;
                sidedragging = false;
                $('#svg_editor').unbind('mousemove', resizeSidePanel)
            });
            populateLayers();
            var centerCanvas = function()
                {
                    workarea.css('line-height', workarea.height() + 'px')
                };
            $(window).bind('load resize', centerCanvas);
            function stepFontSize(elem, step)
            {
                var orig_val = Number(elem.value);
                var sug_val = orig_val + step;
                var increasing = sug_val >= orig_val;
                if (step === 0)
                {
                    return orig_val
                }
                if (orig_val >= 24)
                {
                    if (increasing)
                    {
                        return Math.round(orig_val * 1.1)
                    }
                    return Math.round(orig_val / 1.1)
                }
                if (orig_val <= 1)
                {
                    if (increasing)
                    {
                        return orig_val * 2
                    }
                    return orig_val / 2
                }
                return sug_val
            }
            function stepZoom(elem, step)
            {
                var orig_val = Number(elem.value);
                if (orig_val === 0)
                {
                    return 100
                }
                var sug_val = orig_val + step;
                if (step === 0)
                {
                    return orig_val
                }
                if (orig_val >= 100)
                {
                    return sug_val
                }
                if (sug_val >= orig_val)
                {
                    return orig_val * 2
                }
                return orig_val / 2
            }
            $('#resolution').change(function()
            {
                var wh = $('#canvas_width,#canvas_height');
                if (!this.selectedIndex)
                {
                    if ($('#canvas_width').val() == 'fit')
                    {
                        wh.removeAttr('disabled').val(100)
                    }
                }
                else if (this.value == 'content')
                {
                    wh.val('fit').attr('disabled', 'disabled')
                }
                else
                {
                    var dims = this.value.split('x');
                    $('#canvas_width').val(dims[0]);
                    $('#canvas_height').val(dims[1]);
                    wh.removeAttr('disabled')
                }
            });
            $('input,select').attr('autocomplete', 'off');
            Actions = (function()
            {
                var tool_buttons = [{
                            sel: '#tool_select', fn: clickSelect, evt: 'click', key: ['V', true]
                        }, {
                            sel: '#tool_fhpath', fn: clickFHPath, evt: 'click', key: ['Q', true]
                        }, {
                            sel: '#tool_line', fn: clickLine, evt: 'click', key: ['L', true]
                        }, {
                            sel: '#tool_rect', fn: clickRect, evt: 'mouseup', key: ['R', true], parent: '#tools_rect', icon: 'rect'
                        }, {
                            sel: '#tool_square', fn: clickSquare, evt: 'mouseup', parent: '#tools_rect', icon: 'square'
                        }, {
                            sel: '#tool_fhrect', fn: clickFHRect, evt: 'mouseup', parent: '#tools_rect', icon: 'fh_rect'
                        }, {
                            sel: '#tool_ellipse', fn: clickEllipse, evt: 'mouseup', key: ['E', true], parent: '#tools_ellipse', icon: 'ellipse'
                        }, {
                            sel: '#tool_circle', fn: clickCircle, evt: 'mouseup', parent: '#tools_ellipse', icon: 'circle'
                        }, {
                            sel: '#tool_fhellipse', fn: clickFHEllipse, evt: 'mouseup', parent: '#tools_ellipse', icon: 'fh_ellipse'
                        }, {
                            sel: '#tool_path', fn: clickPath, evt: 'click', key: ['P', true]
                        }, {
                            sel: '#tool_text', fn: clickText, evt: 'click', key: ['T', true]
                        }, {
                            sel: '#tool_image', fn: clickImage, evt: 'mouseup'
                        }, {
                            sel: '#tool_zoom', fn: clickZoom, evt: 'mouseup', key: ['Z', true]
                        }, {
                            sel: '#tool_clear', fn: clickClear, evt: 'mouseup', key: ['N', true]
                        }, {
                            sel: '#tool_save', fn: function()
                                {
                                    if (editingsource)
                                    {
                                        saveSourceEditor()
                                    }
                                    else
                                    {
                                        clickSave()
                                    }
                                }, evt: 'mouseup', key: ['S', true]
                        }, {
                            sel: '#tool_export', fn: clickExport, evt: 'mouseup'
                        }, {
                            sel: '#tool_open', fn: clickOpen, evt: 'mouseup', key: ['O', true]
                        }, {
                            sel: '#tool_import', fn: clickImport, evt: 'mouseup'
                        }, {
                            sel: '#tool_source', fn: showSourceEditor, evt: 'click', key: ['U', true]
                        }, {
                            sel: '#tool_wireframe', fn: clickWireframe, evt: 'click', key: ['F', true]
                        }, {
                            sel: '#tool_source_cancel,.overlay,#tool_docprops_cancel,#tool_prefs_cancel', fn: cancelOverlays, evt: 'click', key: ['esc', false, false], hidekey: true
                        }, {
                            sel: '#tool_source_save', fn: saveSourceEditor, evt: 'click'
                        }, {
                            sel: '#tool_docprops_save', fn: saveDocProperties, evt: 'click'
                        }, {
                            sel: '#tool_docprops', fn: showDocProperties, evt: 'mouseup'
                        }, {
                            sel: '#tool_prefs_save', fn: savePreferences, evt: 'click'
                        }, {
                            sel: '#tool_prefs_option', fn: function()
                                {
                                    showPreferences();
                                    return false
                                }, evt: 'mouseup'
                        }, {
                            sel: '#tool_delete,#tool_delete_multi', fn: deleteSelected, evt: 'click', key: ['del/backspace', true]
                        }, {
                            sel: '#tool_reorient', fn: reorientPath, evt: 'click'
                        }, {
                            sel: '#tool_node_link', fn: linkControlPoints, evt: 'click'
                        }, {
                            sel: '#tool_node_clone', fn: clonePathNode, evt: 'click'
                        }, {
                            sel: '#tool_node_delete', fn: deletePathNode, evt: 'click'
                        }, {
                            sel: '#tool_openclose_path', fn: opencloseSubPath, evt: 'click'
                        }, {
                            sel: '#tool_add_subpath', fn: addSubPath, evt: 'click'
                        }, {
                            sel: '#tool_move_top', fn: moveToTopSelected, evt: 'click', key: 'ctrl+shift+]'
                        }, {
                            sel: '#tool_move_bottom', fn: moveToBottomSelected, evt: 'click', key: 'ctrl+shift+['
                        }, {
                            sel: '#tool_topath', fn: convertToPath, evt: 'click'
                        }, {
                            sel: '#tool_make_link,#tool_make_link_multi', fn: makeHyperlink, evt: 'click'
                        }, {
                            sel: '#tool_undo', fn: clickUndo, evt: 'click', key: ['Z', true]
                        }, {
                            sel: '#tool_redo', fn: clickRedo, evt: 'click', key: ['Y', true]
                        }, {
                            sel: '#tool_clone,#tool_clone_multi', fn: clickClone, evt: 'click', key: ['D', true]
                        }, {
                            sel: '#tool_group_elements', fn: clickGroup, evt: 'click', key: ['G', true]
                        }, {
                            sel: '#tool_ungroup', fn: clickGroup, evt: 'click'
                        }, {
                            sel: '#tool_unlink_use', fn: clickGroup, evt: 'click'
                        }, {
                            sel: '[id^=tool_align]', fn: clickAlign, evt: 'click'
                        }, {
                            sel: '#tool_bold', fn: clickBold, evt: 'mousedown'
                        }, {
                            sel: '#tool_italic', fn: clickItalic, evt: 'mousedown'
                        }, {
                            sel: '#sidepanel_handle', fn: toggleSidePanel, key: ['X']
                        }, {
                            sel: '#copy_save_done', fn: cancelOverlays, evt: 'click'
                        }, {
                            key: 'ctrl+left', fn: function()
                                {
                                    rotateSelected(0, 1)
                                }
                        }, {
                            key: 'ctrl+right', fn: function()
                                {
                                    rotateSelected(1, 1)
                                }
                        }, {
                            key: 'ctrl+shift+left', fn: function()
                                {
                                    rotateSelected(0, 5)
                                }
                        }, {
                            key: 'ctrl+shift+right', fn: function()
                                {
                                    rotateSelected(1, 5)
                                }
                        }, {
                            key: 'shift+O', fn: selectPrev
                        }, {
                            key: 'shift+P', fn: selectNext
                        }, {
                            key: [modKey + 'up', true], fn: function()
                                {
                                    zoomImage(2)
                                }
                        }, {
                            key: [modKey + 'down', true], fn: function()
                                {
                                    zoomImage(0.5)
                                }
                        }, {
                            key: [modKey + ']', true], fn: function()
                                {
                                    moveUpDownSelected('Up')
                                }
                        }, {
                            key: [modKey + '[', true], fn: function()
                                {
                                    moveUpDownSelected('Down')
                                }
                        }, {
                            key: ['up', true], fn: function()
                                {
                                    moveSelected(0, -1)
                                }
                        }, {
                            key: ['down', true], fn: function()
                                {
                                    moveSelected(0, 1)
                                }
                        }, {
                            key: ['left', true], fn: function()
                                {
                                    moveSelected(-1, 0)
                                }
                        }, {
                            key: ['right', true], fn: function()
                                {
                                    moveSelected(1, 0)
                                }
                        }, {
                            key: 'shift+up', fn: function()
                                {
                                    moveSelected(0, -10)
                                }
                        }, {
                            key: 'shift+down', fn: function()
                                {
                                    moveSelected(0, 10)
                                }
                        }, {
                            key: 'shift+left', fn: function()
                                {
                                    moveSelected(-10, 0)
                                }
                        }, {
                            key: 'shift+right', fn: function()
                                {
                                    moveSelected(10, 0)
                                }
                        }, {
                            key: ['alt+up', true], fn: function()
                                {
                                    svgCanvas.cloneSelectedElements(0, -1)
                                }
                        }, {
                            key: ['alt+down', true], fn: function()
                                {
                                    svgCanvas.cloneSelectedElements(0, 1)
                                }
                        }, {
                            key: ['alt+left', true], fn: function()
                                {
                                    svgCanvas.cloneSelectedElements(-1, 0)
                                }
                        }, {
                            key: ['alt+right', true], fn: function()
                                {
                                    svgCanvas.cloneSelectedElements(1, 0)
                                }
                        }, {
                            key: ['alt+shift+up', true], fn: function()
                                {
                                    svgCanvas.cloneSelectedElements(0, -10)
                                }
                        }, {
                            key: ['alt+shift+down', true], fn: function()
                                {
                                    svgCanvas.cloneSelectedElements(0, 10)
                                }
                        }, {
                            key: ['alt+shift+left', true], fn: function()
                                {
                                    svgCanvas.cloneSelectedElements(-10, 0)
                                }
                        }, {
                            key: ['alt+shift+right', true], fn: function()
                                {
                                    svgCanvas.cloneSelectedElements(10, 0)
                                }
                        }, {
                            key: 'A', fn: function()
                                {
                                    svgCanvas.selectAllInCurrentLayer()
                                }
                        }, {
                            key: modKey + 'z', fn: clickUndo
                        }, {
                            key: modKey + 'shift+z', fn: clickRedo
                        }, {
                            key: modKey + 'y', fn: clickRedo
                        }, {
                            key: modKey + 'x', fn: cutSelected
                        }, {
                            key: modKey + 'c', fn: copySelected
                        }, {
                            key: modKey + 'v', fn: pasteInCenter
                        }];
                var key_assocs = {
                        '4/Shift+4': '#tools_rect_show', '5/Shift+5': '#tools_ellipse_show'
                    };
                return {
                        setAll: function()
                        {
                            var flyouts = {};
                            $.each(tool_buttons, function(i, opts)
                            {
                                var btn;
                                if (opts.sel)
                                {
                                    btn = $(opts.sel);
                                    if (btn.length == 0)
                                    {
                                        return true
                                    }
                                    if (opts.evt)
                                    {
                                        if (svgedit.browser.isTouch() && opts.evt === 'click')
                                        {
                                            opts.evt = 'mousedown'
                                        }
                                        btn[opts.evt](opts.fn)
                                    }
                                    if (opts.parent && $(opts.parent + '_show').length != 0)
                                    {
                                        var f_h = $(opts.parent);
                                        if (!f_h.length)
                                        {
                                            f_h = makeFlyoutHolder(opts.parent.substr(1))
                                        }
                                        f_h.append(btn);
                                        if (!$.isArray(flyouts[opts.parent]))
                                        {
                                            flyouts[opts.parent] = []
                                        }
                                        flyouts[opts.parent].push(opts)
                                    }
                                }
                                if (opts.key)
                                {
                                    var keyval,
                                        disInInp = true,
                                        fn = opts.fn,
                                        pd = false;
                                    if ($.isArray(opts.key))
                                    {
                                        keyval = opts.key[0];
                                        if (opts.key.length > 1)
                                        {
                                            pd = opts.key[1]
                                        }
                                        if (opts.key.length > 2)
                                        {
                                            disInInp = opts.key[2]
                                        }
                                    }
                                    else
                                    {
                                        keyval = opts.key
                                    }
                                    keyval += '';
                                    $.each(keyval.split('/'), function(i, key)
                                    {
                                        $(document).bind('keydown', key, function(e)
                                        {
                                            fn();
                                            if (pd)
                                            {
                                                e.preventDefault()
                                            }
                                            return false
                                        })
                                    });
                                    if (opts.sel && !opts.hidekey && btn.attr('title'))
                                    {
                                        var newTitle = btn.attr('title').split('[')[0] + ' (' + keyval + ')';
                                        key_assocs[keyval] = opts.sel;
                                        if (!btn.parents('#main_menu').length)
                                        {
                                            btn.attr('title', newTitle)
                                        }
                                    }
                                }
                            });
                            setupFlyouts(flyouts);
                            $('.attr_changer, #image_url').bind('keydown', 'return', function(evt)
                            {
                                $(this).change();
                                evt.preventDefault()
                            });
                            $(window).bind('keydown', 'tab', function(e)
                            {
                                if (ui_context === 'canvas')
                                {
                                    e.preventDefault();
                                    selectNext()
                                }
                            }).bind('keydown', 'shift+tab', function(e)
                            {
                                if (ui_context === 'canvas')
                                {
                                    e.preventDefault();
                                    selectPrev()
                                }
                            });
                            $('#tool_zoom').dblclick(dblclickZoom)
                        }, setTitles: function()
                            {
                                $.each(key_assocs, function(keyval, sel)
                                {
                                    var menu = ($(sel).parents('#main_menu').length);
                                    $(sel).each(function()
                                    {
                                        var t;
                                        if (menu)
                                        {
                                            t = $(this).text().split(' [')[0]
                                        }
                                        else
                                        {
                                            t = this.title.split(' [')[0]
                                        }
                                        var key_str = '';
                                        $.each(keyval.split('/'), function(i, key)
                                        {
                                            var mod_bits = key.split('+'),
                                                mod = '';
                                            if (mod_bits.length > 1)
                                            {
                                                mod = mod_bits[0] + '+';
                                                key = mod_bits[1]
                                            }
                                            key_str += (i ? '/' : '') + mod + (uiStrings['key_' + key] || key)
                                        });
                                        if (menu)
                                        {
                                            this.lastChild.textContent = t + ' [' + key_str + ']'
                                        }
                                        else
                                        {
                                            this.title = t + ' [' + key_str + ']'
                                        }
                                    })
                                })
                            }, getButtonData: function(sel)
                            {
                                var b;
                                $.each(tool_buttons, function(i, btn)
                                {
                                    if (btn.sel === sel)
                                    {
                                        b = btn
                                    }
                                });
                                return b
                            }
                    }
            }());
            Actions.setAll();
            editor.ready(function()
            {
                var tool,
                    itool = curConfig.initTool,
                    container = $('#tools_left, #svg_editor .tools_flyout'),
                    pre_tool = container.find('#tool_' + itool),
                    reg_tool = container.find('#' + itool);
                if (pre_tool.length)
                {
                    tool = pre_tool
                }
                else if (reg_tool.length)
                {
                    tool = reg_tool
                }
                else
                {
                    tool = $('#tool_select')
                }
                tool.click().mouseup();
                if (curConfig.wireframe)
                {
                    $('#tool_wireframe').click()
                }
                if (curConfig.showlayers)
                {
                    toggleSidePanel()
                }
                $('#rulers').toggle(!!curConfig.showRulers);
                if (curConfig.showRulers)
                {
                    $('#show_rulers')[0].checked = true
                }
                if (curConfig.baseUnit)
                {
                    $('#base_unit').val(curConfig.baseUnit)
                }
                if (curConfig.gridSnapping)
                {
                    $('#grid_snapping_on')[0].checked = true
                }
                if (curConfig.snappingStep)
                {
                    $('#grid_snapping_step').val(curConfig.snappingStep)
                }
                if (curConfig.gridColor)
                {
                    $('#grid_color').val(curConfig.gridColor)
                }
            });
            $('#rect_rx').SpinButton({
                min: 0, max: 1000, callback: changeRectRadius
            });
            $('#stroke_width').SpinButton({
                min: 0, max: 99, smallStep: 0.1, callback: changeStrokeWidth
            });
            $('#angle').SpinButton({
                min: -180, max: 180, step: 5, callback: changeRotationAngle
            });
            $('#font_size').SpinButton({
                min: 0.001, stepfunc: stepFontSize, callback: changeFontSize
            });
            $('#group_opacity').SpinButton({
                min: 0, max: 100, step: 5, callback: changeOpacity
            });
            $('#blur').SpinButton({
                min: 0, max: 10, step: 0.1, callback: changeBlur
            });
            $('#zoom').SpinButton({
                min: 0.001, max: 10000, step: 50, stepfunc: stepZoom, callback: changeZoom
            }).val(svgCanvas.getZoom() * 100);
            $('#workarea').contextMenu({
                menu: 'cmenu_canvas', inSpeed: 0
            }, function(action, el, pos)
            {
                switch (action)
                {
                    case'delete':
                        deleteSelected();
                        break;
                    case'cut':
                        cutSelected();
                        break;
                    case'copy':
                        copySelected();
                        break;
                    case'paste':
                        svgCanvas.pasteElements();
                        break;
                    case'paste_in_place':
                        svgCanvas.pasteElements('in_place');
                        break;
                    case'group_elements':
                        svgCanvas.groupSelectedElements();
                        break;
                    case'ungroup':
                        svgCanvas.ungroupSelectedElement();
                        break;
                    case'move_front':
                        moveToTopSelected();
                        break;
                    case'move_up':
                        moveUpDownSelected('Up');
                        break;
                    case'move_down':
                        moveUpDownSelected('Down');
                        break;
                    case'move_back':
                        moveToBottomSelected();
                        break;
                    default:
                        if (svgedit.contextmenu && svgedit.contextmenu.hasCustomHandler(action))
                        {
                            svgedit.contextmenu.getCustomHandler(action).call()
                        }
                        break
                }
                if (svgCanvas.clipBoard.length)
                {
                    canv_menu.enableContextMenuItems('#paste,#paste_in_place')
                }
            });
            var lmenu_func = function(action, el, pos)
                {
                    switch (action)
                    {
                        case'dupe':
                            cloneLayer();
                            break;
                        case'delete':
                            deleteLayer();
                            break;
                        case'merge_down':
                            mergeLayer();
                            break;
                        case'merge_all':
                            svgCanvas.mergeAllLayers();
                            updateContextPanel();
                            populateLayers();
                            break
                    }
                };
            $('#layerlist').contextMenu({
                menu: 'cmenu_layers', inSpeed: 0
            }, lmenu_func);
            $('#layer_moreopts').contextMenu({
                menu: 'cmenu_layers', inSpeed: 0, allowLeft: true
            }, lmenu_func);
            $('.contextMenu li').mousedown(function(ev)
            {
                ev.preventDefault()
            });
            $('#cmenu_canvas li').disableContextMenu();
            canv_menu.enableContextMenuItems('#delete,#cut,#copy');
            window.addEventListener('beforeunload', function(e)
            {
                if (undoMgr.getUndoStackSize() === 0)
                {
                    editor.showSaveWarning = false
                }
                if (!curConfig.no_save_warning && editor.showSaveWarning)
                {
                    e.returnValue = uiStrings.notification.unsavedChanges;
                    return uiStrings.notification.unsavedChanges
                }
            }, false);
            editor.openPrep = function(func)
            {
                $('#main_menu').hide();
                if (undoMgr.getUndoStackSize() === 0)
                {
                    func(true)
                }
                else
                {
                    $.confirm(uiStrings.notification.QwantToOpen, func)
                }
            };
            function onDragEnter(e)
            {
                e.stopPropagation();
                e.preventDefault()
            }
            function onDragOver(e)
            {
                e.stopPropagation();
                e.preventDefault()
            }
            function onDragLeave(e)
            {
                e.stopPropagation();
                e.preventDefault()
            }
            if (window.FileReader)
            {
                var importImage = function(e)
                    {
                        $.process_cancel(uiStrings.notification.loadingImage);
                        e.stopPropagation();
                        e.preventDefault();
                        $('#workarea').removeAttr('style');
                        $('#main_menu').hide();
                        var file = (e.type == 'drop') ? e.dataTransfer.files[0] : this.files[0];
                        if (!file)
                        {
                            return
                        }
                        if (file.type.indexOf('image') != -1)
                        {
                            var reader;
                            if (file.type.indexOf('svg') != -1)
                            {
                                reader = new FileReader;
                                reader.onloadend = function(e)
                                {
                                    svgCanvas.importSvgString(e.target.result, true);
                                    svgCanvas.ungroupSelectedElement();
                                    svgCanvas.ungroupSelectedElement();
                                    svgCanvas.groupSelectedElements();
                                    svgCanvas.alignSelectedElements('m', 'page');
                                    svgCanvas.alignSelectedElements('c', 'page')
                                };
                                reader.readAsText(file)
                            }
                            else
                            {
                                reader = new FileReader;
                                reader.onloadend = function(e)
                                {
                                    var insertNewImage = function(width, height)
                                        {
                                            var newImage = svgCanvas.addSvgElementFromJson({
                                                    element: 'image', attr: {
                                                            x: 0, y: 0, width: width, height: height, id: svgCanvas.getNextId(), style: 'pointer-events:inherit'
                                                        }
                                                });
                                            svgCanvas.setHref(newImage, e.target.result);
                                            svgCanvas.selectOnly([newImage]);
                                            svgCanvas.alignSelectedElements('m', 'page');
                                            svgCanvas.alignSelectedElements('c', 'page');
                                            updateContextPanel()
                                        };
                                    var imgWidth = 100;
                                    var imgHeight = 100;
                                    var img = new Image;
                                    img.src = e.target.result;
                                    img.style.opacity = 0;
                                    img.onload = function()
                                    {
                                        imgWidth = img.offsetWidth;
                                        imgHeight = img.offsetHeight;
                                        insertNewImage(imgWidth, imgHeight)
                                    }
                                };
                                reader.readAsDataURL(file)
                            }
                        }
                    };
                workarea[0].addEventListener('dragenter', onDragEnter, false);
                workarea[0].addEventListener('dragover', onDragOver, false);
                workarea[0].addEventListener('dragleave', onDragLeave, false);
                workarea[0].addEventListener('drop', importImage, false);
                var open = $('<input type="file">').change(function()
                    {
                        var f = this;
                        editor.openPrep(function(ok)
                        {
                            if (!ok)
                            {
                                return
                            }
                            svgCanvas.clear();
                            if (f.files.length === 1)
                            {
                                $.process_cancel(uiStrings.notification.loadingImage);
                                var reader = new FileReader;
                                reader.onloadend = function(e)
                                {
                                    loadSvgString(e.target.result);
                                    updateCanvas()
                                };
                                reader.readAsText(f.files[0])
                            }
                        })
                    });
                $('#tool_open').show().prepend(open);
                var imgImport = $('<input type="file">').change(importImage);
                $('#tool_import').show().prepend(imgImport)
            }
            updateCanvas(true);
            $(function()
            {
                window.svgCanvas = svgCanvas;
                svgCanvas.ready = editor.ready
            });
            editor.setLang = function(lang, allStrings)
            {
                editor.langChanged = true;
                $.pref('lang', lang);
                $('#lang_select').val(lang);
                if (!allStrings)
                {
                    return
                }
                var oldLayerName = $('#layerlist tr.layersel td.layername').text();
                var rename_layer = (oldLayerName == uiStrings.common.layer + ' 1');
                $.extend(uiStrings, allStrings);
                svgCanvas.setUiStrings(allStrings);
                Actions.setTitles();
                if (rename_layer)
                {
                    svgCanvas.renameCurrentLayer(uiStrings.common.layer + ' 1');
                    populateLayers()
                }
                if (extsPreLang.length)
                {
                    while (extsPreLang.length)
                    {
                        var ext = extsPreLang.shift();
                        ext.langReady({
                            lang: lang, uiStrings: uiStrings
                        })
                    }
                }
                else
                {
                    svgCanvas.runExtensions('langReady', {
                        lang: lang, uiStrings: uiStrings
                    })
                }
                svgCanvas.runExtensions('langChanged', lang);
                setFlyoutTitles();
                var elems = {
                        '#stroke_color': '#tool_stroke .icon_label, #tool_stroke .color_block', '#fill_color': '#tool_fill label, #tool_fill .color_block', '#linejoin_miter': '#cur_linejoin', '#linecap_butt': '#cur_linecap'
                    };
                $.each(elems, function(source, dest)
                {
                    $(dest).attr('title', $(source)[0].title)
                });
                $('#multiselected_panel div[id^=tool_align]').each(function()
                {
                    $('#tool_pos' + this.id.substr(10))[0].title = this.title
                })
            }
        };
        editor.ready = function(cb)
        {
            if (!isReady)
            {
                callbacks.push(cb)
            }
            else
            {
                cb()
            }
        };
        editor.runCallbacks = function()
        {
            $.each(callbacks, function()
            {
                this()
            });
            isReady = true;
            callbacks = []
        };
        editor.loadFromString = function(str)
        {
            editor.ready(function()
            {
                loadSvgString(str)
            })
        };
        editor.disableUI = function(featList){};
        editor.loadFromURL = function(url, opts)
        {
            if (!opts)
            {
                opts = {}
            }
            var cache = opts.cache;
            var cb = opts.callback;
            editor.ready(function()
            {
                $.ajax({
                    url: url, dataType: 'text', cache: !!cache, beforeSend: function()
                        {
                            $.process_cancel(uiStrings.notification.loadingImage)
                        }, success: function(str)
                        {
                            loadSvgString(str, cb)
                        }, error: function(xhr, stat, err)
                        {
                            if (xhr.status != 404 && xhr.responseText)
                            {
                                loadSvgString(xhr.responseText, cb)
                            }
                            else
                            {
                                $.alert(uiStrings.notification.URLloadFail + ': \n' + err, cb)
                            }
                        }, complete: function()
                        {
                            $('#dialog_box').hide()
                        }
                })
            })
        };
        editor.loadFromDataURI = function(str)
        {
            editor.ready(function()
            {
                var pre = 'data:image/svg+xml;base64,';
                var src = str.substring(pre.length);
                loadSvgString(Utils.decode64(src))
            })
        };
        editor.addExtension = function()
        {
            var args = arguments;
            $(function()
            {
                if (svgCanvas)
                {
                    svgCanvas.addExtension.apply(this, args)
                }
            })
        };
        return editor
    }(jQuery))
}());
var svgEditor = (function($, editor)
    {
        'use strict';
        var lang_param;
        function setStrings(type, obj, ids)
        {
            var i,
                sel,
                val,
                $elem,
                elem,
                node,
                parent = $('#svg_editor').parent();
            for (sel in obj)
            {
                val = obj[sel];
                if (!val)
                {
                    console.log(sel)
                }
                if (ids)
                {
                    sel = '#' + sel
                }
                $elem = parent.find(sel);
                if ($elem.length)
                {
                    elem = parent.find(sel)[0];
                    switch (type)
                    {
                        case'content':
                            for (i = 0; i < elem.childNodes.length; i++)
                            {
                                node = elem.childNodes[i];
                                if (node.nodeType === 3 && node.textContent.replace(/\s/g, ''))
                                {
                                    node.textContent = val;
                                    break
                                }
                            }
                            break;
                        case'title':
                            elem.title = val;
                            break
                    }
                }
                else
                {}
            }
        }
        editor.readLang = function(langData)
        {
            var more = editor.canvas.runExtensions("addlangData", lang_param, true);
            $.each(more, function(i, m)
            {
                if (m.data)
                {
                    langData = $.merge(langData, m.data)
                }
            });
            if (!langData.tools)
            {
                return
            }
            var tools = langData.tools,
                misc = langData.misc,
                properties = langData.properties,
                config = langData.config,
                layers = langData.layers,
                common = langData.common,
                ui = langData.ui;
            setStrings('content', {
                curve_segments: properties.curve_segments, fitToContent: tools.fitToContent, fit_to_all: tools.fit_to_all, fit_to_canvas: tools.fit_to_canvas, fit_to_layer_content: tools.fit_to_layer_content, fit_to_sel: tools.fit_to_sel, icon_large: config.icon_large, icon_medium: config.icon_medium, icon_small: config.icon_small, icon_xlarge: config.icon_xlarge, image_opt_embed: config.image_opt_embed, image_opt_ref: config.image_opt_ref, includedImages: config.included_images, largest_object: tools.largest_object, layersLabel: layers.layers, page: tools.page, relativeToLabel: tools.relativeTo, selLayerLabel: layers.move_elems_to, selectedPredefined: config.select_predefined, selected_objects: tools.selected_objects, smallest_object: tools.smallest_object, straight_segments: properties.straight_segments, svginfo_bg_url: config.editor_img_url + ":", svginfo_bg_note: config.editor_bg_note, svginfo_change_background: config.background, svginfo_dim: config.doc_dims, svginfo_editor_prefs: config.editor_prefs, svginfo_height: common.height, svginfo_icons: config.icon_size, svginfo_image_props: config.image_props, svginfo_lang: config.language, svginfo_title: config.doc_title, svginfo_width: common.width, tool_docprops_cancel: common.cancel, tool_docprops_save: common.ok, tool_source_cancel: common.cancel, tool_source_save: common.ok, tool_prefs_cancel: common.cancel, tool_prefs_save: common.ok, sidepanel_handle: layers.layers.split('').join(' '), tool_clear: tools.new_doc, tool_docprops: tools.docprops, tool_export: tools.export_img, tool_import: tools.import_doc, tool_imagelib: tools.imagelib, tool_open: tools.open_doc, tool_save: tools.save_doc, svginfo_units_rulers: config.units_and_rulers, svginfo_rulers_onoff: config.show_rulers, svginfo_unit: config.base_unit, svginfo_grid_settings: config.grid, svginfo_snap_onoff: config.snapping_onoff, svginfo_snap_step: config.snapping_stepsize, svginfo_grid_color: config.grid_color
            }, true);
            var o,
                cats = {};
            for (o in langData.shape_cats)
            {
                cats['#shape_cats [data-cat="' + o + '"]'] = langData.shape_cats[o]
            }
            setTimeout(function()
            {
                setStrings('content', cats)
            }, 2000);
            var opts = {};
            $.each(['cut', 'copy', 'paste', 'paste_in_place', 'delete', 'group', 'ungroup', 'move_front', 'move_up', 'move_down', 'move_back'], function()
            {
                opts['#cmenu_canvas a[href="#' + this + '"]'] = tools[this]
            });
            $.each(['dupe', 'merge_down', 'merge_all'], function()
            {
                opts['#cmenu_layers a[href="#' + this + '"]'] = layers[this]
            });
            opts['#cmenu_layers a[href="#delete"]'] = layers.del;
            setStrings('content', opts);
            setStrings('title', {
                align_relative_to: tools.align_relative_to, circle_cx: properties.circle_cx, circle_cy: properties.circle_cy, circle_r: properties.circle_r, cornerRadiusLabel: properties.corner_radius, ellipse_cx: properties.ellipse_cx, ellipse_cy: properties.ellipse_cy, ellipse_rx: properties.ellipse_rx, ellipse_ry: properties.ellipse_ry, fill_color: properties.fill_color, font_family: properties.font_family, idLabel: properties.id, image_height: properties.image_height, image_url: properties.image_url, image_width: properties.image_width, layer_delete: layers.del, layer_down: layers.move_down, layer_new: layers['new'], layer_rename: layers.rename, layer_moreopts: common.more_opts, layer_up: layers.move_up, line_x1: properties.line_x1, line_x2: properties.line_x2, line_y1: properties.line_y1, line_y2: properties.line_y2, linecap_butt: properties.linecap_butt, linecap_round: properties.linecap_round, linecap_square: properties.linecap_square, linejoin_bevel: properties.linejoin_bevel, linejoin_miter: properties.linejoin_miter, linejoin_round: properties.linejoin_round, main_icon: tools.main_menu, mode_connect: tools.mode_connect, tools_shapelib_show: tools.mode_shapelib, palette: ui.palette_info, zoom_panel: ui.zoom_level, path_node_x: properties.node_x, path_node_y: properties.node_y, rect_height_tool: properties.rect_height, rect_width_tool: properties.rect_width, seg_type: properties.seg_type, selLayerNames: layers.move_selected, selected_x: properties.pos_x, selected_y: properties.pos_y, stroke_color: properties.stroke_color, stroke_style: properties.stroke_style, stroke_width: properties.stroke_width, svginfo_title: config.doc_title, text: properties.text_contents, toggle_stroke_tools: ui.toggle_stroke_tools, tool_add_subpath: tools.add_subpath, tool_alignbottom: tools.align_bottom, tool_aligncenter: tools.align_center, tool_alignleft: tools.align_left, tool_alignmiddle: tools.align_middle, tool_alignright: tools.align_right, tool_aligntop: tools.align_top, tool_angle: properties.angle, tool_blur: properties.blur, tool_bold: properties.bold, tool_circle: tools.mode_circle, tool_clone: tools.clone, tool_clone_multi: tools.clone, tool_delete: tools.del, tool_delete_multi: tools.del, tool_ellipse: tools.mode_ellipse, tool_eyedropper: tools.mode_eyedropper, tool_fhellipse: tools.mode_fhellipse, tool_fhpath: tools.mode_fhpath, tool_fhrect: tools.mode_fhrect, tool_font_size: properties.font_size, tool_group_elements: tools.group_elements, tool_make_link: tools.make_link, tool_link_url: tools.set_link_url, tool_image: tools.mode_image, tool_italic: properties.italic, tool_line: tools.mode_line, tool_move_bottom: tools.move_bottom, tool_move_top: tools.move_top, tool_node_clone: tools.node_clone, tool_node_delete: tools.node_delete, tool_node_link: tools.node_link, tool_opacity: properties.opacity, tool_openclose_path: tools.openclose_path, tool_path: tools.mode_path, tool_position: tools.align_to_page, tool_rect: tools.mode_rect, tool_redo: tools.redo, tool_reorient: tools.reorient_path, tool_select: tools.mode_select, tool_source: tools.source_save, tool_square: tools.mode_square, tool_text: tools.mode_text, tool_topath: tools.to_path, tool_undo: tools.undo, tool_ungroup: tools.ungroup, tool_wireframe: tools.wireframe_mode, view_grid: tools.toggle_grid, tool_zoom: tools.mode_zoom, url_notice: tools.no_embed
            }, true);
            editor.setLang(lang_param, langData)
        };
        editor.putLocale = function(given_param, good_langs)
        {
            if (given_param)
            {
                lang_param = given_param
            }
            else
            {
                lang_param = $.pref('lang');
                if (!lang_param)
                {
                    if (navigator.userLanguage)
                    {
                        lang_param = navigator.userLanguage
                    }
                    else if (navigator.language)
                    {
                        lang_param = navigator.language
                    }
                    if (lang_param == null)
                    {
                        return
                    }
                }
                console.log('Lang: ' + lang_param);
                if ($.inArray(lang_param, good_langs) === -1 && lang_param !== 'test')
                {
                    lang_param = "en"
                }
            }
            var conf = editor.curConfig;
            var url = conf.langPath + "lang." + lang_param + ".js";
            $.getScript(url, function(d)
            {
                if (!d)
                {
                    var s = document.createElement('script');
                    s.src = url;
                    document.querySelector('head').appendChild(s)
                }
            })
        };
        return editor
    }(jQuery, svgEditor));
/**
 * A class to parse color values
 * @author Stoyan Stefanov <sstoo@gmail.com>
 * @link   http://www.phpied.com/rgb-color-parser-in-javascript/
 * @license Use it if you like it
 */
function RGBColor(color_string)
{
    'use strict';
    this.ok = false;
    if (color_string.charAt(0) === '#')
    {
        color_string = color_string.substr(1, 6)
    }
    color_string = color_string.replace(/ /g, '');
    color_string = color_string.toLowerCase();
    var simple_colors = {
            aliceblue: 'f0f8ff', antiquewhite: 'faebd7', aqua: '00ffff', aquamarine: '7fffd4', azure: 'f0ffff', beige: 'f5f5dc', bisque: 'ffe4c4', black: '000000', blanchedalmond: 'ffebcd', blue: '0000ff', blueviolet: '8a2be2', brown: 'a52a2a', burlywood: 'deb887', cadetblue: '5f9ea0', chartreuse: '7fff00', chocolate: 'd2691e', coral: 'ff7f50', cornflowerblue: '6495ed', cornsilk: 'fff8dc', crimson: 'dc143c', cyan: '00ffff', darkblue: '00008b', darkcyan: '008b8b', darkgoldenrod: 'b8860b', darkgray: 'a9a9a9', darkgreen: '006400', darkkhaki: 'bdb76b', darkmagenta: '8b008b', darkolivegreen: '556b2f', darkorange: 'ff8c00', darkorchid: '9932cc', darkred: '8b0000', darksalmon: 'e9967a', darkseagreen: '8fbc8f', darkslateblue: '483d8b', darkslategray: '2f4f4f', darkturquoise: '00ced1', darkviolet: '9400d3', deeppink: 'ff1493', deepskyblue: '00bfff', dimgray: '696969', dodgerblue: '1e90ff', feldspar: 'd19275', firebrick: 'b22222', floralwhite: 'fffaf0', forestgreen: '228b22', fuchsia: 'ff00ff', gainsboro: 'dcdcdc', ghostwhite: 'f8f8ff', gold: 'ffd700', goldenrod: 'daa520', gray: '808080', green: '008000', greenyellow: 'adff2f', honeydew: 'f0fff0', hotpink: 'ff69b4', indianred: 'cd5c5c', indigo: '4b0082', ivory: 'fffff0', khaki: 'f0e68c', lavender: 'e6e6fa', lavenderblush: 'fff0f5', lawngreen: '7cfc00', lemonchiffon: 'fffacd', lightblue: 'add8e6', lightcoral: 'f08080', lightcyan: 'e0ffff', lightgoldenrodyellow: 'fafad2', lightgrey: 'd3d3d3', lightgreen: '90ee90', lightpink: 'ffb6c1', lightsalmon: 'ffa07a', lightseagreen: '20b2aa', lightskyblue: '87cefa', lightslateblue: '8470ff', lightslategray: '778899', lightsteelblue: 'b0c4de', lightyellow: 'ffffe0', lime: '00ff00', limegreen: '32cd32', linen: 'faf0e6', magenta: 'ff00ff', maroon: '800000', mediumaquamarine: '66cdaa', mediumblue: '0000cd', mediumorchid: 'ba55d3', mediumpurple: '9370d8', mediumseagreen: '3cb371', mediumslateblue: '7b68ee', mediumspringgreen: '00fa9a', mediumturquoise: '48d1cc', mediumvioletred: 'c71585', midnightblue: '191970', mintcream: 'f5fffa', mistyrose: 'ffe4e1', moccasin: 'ffe4b5', navajowhite: 'ffdead', navy: '000080', oldlace: 'fdf5e6', olive: '808000', olivedrab: '6b8e23', orange: 'ffa500', orangered: 'ff4500', orchid: 'da70d6', palegoldenrod: 'eee8aa', palegreen: '98fb98', paleturquoise: 'afeeee', palevioletred: 'd87093', papayawhip: 'ffefd5', peachpuff: 'ffdab9', peru: 'cd853f', pink: 'ffc0cb', plum: 'dda0dd', powderblue: 'b0e0e6', purple: '800080', red: 'ff0000', rosybrown: 'bc8f8f', royalblue: '4169e1', saddlebrown: '8b4513', salmon: 'fa8072', sandybrown: 'f4a460', seagreen: '2e8b57', seashell: 'fff5ee', sienna: 'a0522d', silver: 'c0c0c0', skyblue: '87ceeb', slateblue: '6a5acd', slategray: '708090', snow: 'fffafa', springgreen: '00ff7f', steelblue: '4682b4', tan: 'd2b48c', teal: '008080', thistle: 'd8bfd8', tomato: 'ff6347', turquoise: '40e0d0', violet: 'ee82ee', violetred: 'd02090', wheat: 'f5deb3', white: 'ffffff', whitesmoke: 'f5f5f5', yellow: 'ffff00', yellowgreen: '9acd32'
        };
    var key;
    for (key in simple_colors)
    {
        if (simple_colors.hasOwnProperty(key))
        {
            if (color_string == key)
            {
                color_string = simple_colors[key]
            }
        }
    }
    var color_defs = [{
                re: /^rgb\((\d{1,3}),\s*(\d{1,3}),\s*(\d{1,3})\)$/, example: ['rgb(123, 234, 45)', 'rgb(255,234,245)'], process: function(bits)
                    {
                        return [parseInt(bits[1], 10), parseInt(bits[2], 10), parseInt(bits[3], 10)]
                    }
            }, {
                re: /^(\w{2})(\w{2})(\w{2})$/, example: ['#00ff00', '336699'], process: function(bits)
                    {
                        return [parseInt(bits[1], 16), parseInt(bits[2], 16), parseInt(bits[3], 16)]
                    }
            }, {
                re: /^(\w{1})(\w{1})(\w{1})$/, example: ['#fb0', 'f0f'], process: function(bits)
                    {
                        return [parseInt(bits[1] + bits[1], 16), parseInt(bits[2] + bits[2], 16), parseInt(bits[3] + bits[3], 16)]
                    }
            }];
    var i;
    for (i = 0; i < color_defs.length; i++)
    {
        var re = color_defs[i].re;
        var processor = color_defs[i].process;
        var bits = re.exec(color_string);
        if (bits)
        {
            var channels = processor(bits);
            this.r = channels[0];
            this.g = channels[1];
            this.b = channels[2];
            this.ok = true
        }
    }
    this.r = (this.r < 0 || isNaN(this.r)) ? 0 : ((this.r > 255) ? 255 : this.r);
    this.g = (this.g < 0 || isNaN(this.g)) ? 0 : ((this.g > 255) ? 255 : this.g);
    this.b = (this.b < 0 || isNaN(this.b)) ? 0 : ((this.b > 255) ? 255 : this.b);
    this.toRGB = function()
    {
        return 'rgb(' + this.r + ', ' + this.g + ', ' + this.b + ')'
    };
    this.toHex = function()
    {
        var r = this.r.toString(16);
        var g = this.g.toString(16);
        var b = this.b.toString(16);
        if (r.length === 1)
        {
            r = '0' + r
        }
        if (g.length === 1)
        {
            g = '0' + g
        }
        if (b.length === 1)
        {
            b = '0' + b
        }
        return '#' + r + g + b
    };
    this.getHelpXML = function()
    {
        var i,
            j;
        var examples = [];
        for (i = 0; i < color_defs.length; i++)
        {
            var example = color_defs[i].example;
            for (j = 0; j < example.length; j++)
            {
                examples[examples.length] = example[j]
            }
        }
        var sc;
        for (sc in simple_colors)
        {
            if (simple_colors.hasOwnProperty(sc))
            {
                examples[examples.length] = sc
            }
        }
        var xml = document.createElement('ul');
        xml.setAttribute('id', 'rgbcolor-examples');
        for (i = 0; i < examples.length; i++)
        {
            try
            {
                var list_item = document.createElement('li');
                var list_color = new RGBColor(examples[i]);
                var example_div = document.createElement('div');
                example_div.style.cssText = 'margin: 3px; ' + 'border: 1px solid black; ' + 'background:' + list_color.toHex() + '; ' + 'color:' + list_color.toHex();
                example_div.appendChild(document.createTextNode('test'));
                var list_item_value = document.createTextNode(' ' + examples[i] + ' -> ' + list_color.toRGB() + ' -> ' + list_color.toHex());
                list_item.appendChild(example_div);
                list_item.appendChild(list_item_value);
                xml.appendChild(list_item)
            }
            catch(e) {}
        }
        return xml
    }
}
;
if (!window.console)
{
    window.console = {};
    window.console.log = function(str){};
    window.console.dir = function(str){}
}
if (!Array.prototype.indexOf)
{
    Array.prototype.indexOf = function(obj)
    {
        for (var i = 0; i < this.length; i++)
        {
            if (this[i] == obj)
            {
                return i
            }
        }
        return -1
    }
}
(function()
{
    this.canvg = function(target, s, opts)
    {
        if (target == null && s == null && opts == null)
        {
            var svgTags = document.getElementsByTagName('svg');
            for (var i = 0; i < svgTags.length; i++)
            {
                var svgTag = svgTags[i];
                var c = document.createElement('canvas');
                c.width = svgTag.clientWidth;
                c.height = svgTag.clientHeight;
                svgTag.parentNode.insertBefore(c, svgTag);
                svgTag.parentNode.removeChild(svgTag);
                var div = document.createElement('div');
                div.appendChild(svgTag);
                canvg(c, div.innerHTML)
            }
            return
        }
        opts = opts || {};
        if (typeof target == 'string')
        {
            target = document.getElementById(target)
        }
        var svg;
        if (target.svg == null)
        {
            svg = build();
            target.svg = svg
        }
        else
        {
            svg = target.svg;
            svg.stop()
        }
        svg.opts = opts;
        var ctx = target.getContext('2d');
        if (typeof(s.documentElement) != 'undefined')
        {
            svg.loadXmlDoc(ctx, s)
        }
        else if (s.substr(0, 1) == '<')
        {
            svg.loadXml(ctx, s)
        }
        else
        {
            svg.load(ctx, s)
        }
    };
    function build()
    {
        var svg = {};
        svg.FRAMERATE = 30;
        svg.MAX_VIRTUAL_PIXELS = 30000;
        svg.init = function(ctx)
        {
            svg.Definitions = {};
            svg.Styles = {};
            svg.Animations = [];
            svg.Images = [];
            svg.ctx = ctx;
            svg.ViewPort = new(function()
            {
                this.viewPorts = [];
                this.Clear = function()
                {
                    this.viewPorts = []
                };
                this.SetCurrent = function(width, height)
                {
                    this.viewPorts.push({
                        width: width, height: height
                    })
                };
                this.RemoveCurrent = function()
                {
                    this.viewPorts.pop()
                };
                this.Current = function()
                {
                    return this.viewPorts[this.viewPorts.length - 1]
                };
                this.width = function()
                {
                    return this.Current().width
                };
                this.height = function()
                {
                    return this.Current().height
                };
                this.ComputeSize = function(d)
                {
                    if (d != null && typeof(d) == 'number')
                        return d;
                    if (d == 'x')
                        return this.width();
                    if (d == 'y')
                        return this.height();
                    return Math.sqrt(Math.pow(this.width(), 2) + Math.pow(this.height(), 2)) / Math.sqrt(2)
                }
            })
        };
        svg.init();
        svg.ImagesLoaded = function()
        {
            for (var i = 0; i < svg.Images.length; i++)
            {
                if (!svg.Images[i].loaded)
                    return false
            }
            return true
        };
        svg.trim = function(s)
        {
            return s.replace(/^\s+|\s+$/g, '')
        };
        svg.compressSpaces = function(s)
        {
            return s.replace(/[\s\r\t\n]+/gm, ' ')
        };
        svg.ajax = function(url)
        {
            var AJAX;
            if (window.XMLHttpRequest)
            {
                AJAX = new XMLHttpRequest
            }
            else
            {
                AJAX = new ActiveXObject('Microsoft.XMLHTTP')
            }
            if (AJAX)
            {
                AJAX.open('GET', url, false);
                AJAX.send(null);
                return AJAX.responseText
            }
            return null
        };
        svg.parseXml = function(xml)
        {
            if (window.DOMParser)
            {
                var parser = new DOMParser;
                return parser.parseFromString(xml, 'text/xml')
            }
            else
            {
                xml = xml.replace(/<!DOCTYPE svg[^>]*>/, '');
                var xmlDoc = new ActiveXObject('Microsoft.XMLDOM');
                xmlDoc.async = 'false';
                xmlDoc.loadXML(xml);
                return xmlDoc
            }
        };
        svg.Property = function(name, value)
        {
            this.name = name;
            this.value = value;
            this.hasValue = function()
            {
                return (this.value != null && this.value !== '')
            };
            this.numValue = function()
            {
                if (!this.hasValue())
                    return 0;
                var n = parseFloat(this.value);
                if ((this.value + '').match(/%$/))
                {
                    n = n / 100.0
                }
                return n
            };
            this.valueOrDefault = function(def)
            {
                if (this.hasValue())
                    return this.value;
                return def
            };
            this.numValueOrDefault = function(def)
            {
                if (this.hasValue())
                    return this.numValue();
                return def
            };
            var that = this;
            this.Color = {addOpacity: function(opacity)
                {
                    var newValue = that.value;
                    if (opacity != null && opacity != '')
                    {
                        var color = new RGBColor(that.value);
                        if (color.ok)
                        {
                            newValue = 'rgba(' + color.r + ', ' + color.g + ', ' + color.b + ', ' + opacity + ')'
                        }
                    }
                    return new svg.Property(that.name, newValue)
                }};
            this.Definition = {
                getDefinition: function()
                {
                    var name = that.value.replace(/^(url\()?#([^\)]+)\)?$/, '$2');
                    return svg.Definitions[name]
                }, isUrl: function()
                    {
                        return that.value.indexOf('url(') == 0
                    }, getFillStyle: function(e)
                    {
                        var def = this.getDefinition();
                        if (def != null && def.createGradient)
                        {
                            return def.createGradient(svg.ctx, e)
                        }
                        if (def != null && def.createPattern)
                        {
                            return def.createPattern(svg.ctx, e)
                        }
                        return null
                    }
            };
            this.Length = {
                DPI: function(viewPort)
                {
                    return 96.0
                }, EM: function(viewPort)
                    {
                        var em = 12;
                        var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                        if (fontSize.hasValue())
                            em = fontSize.Length.toPixels(viewPort);
                        return em
                    }, toPixels: function(viewPort)
                    {
                        if (!that.hasValue())
                            return 0;
                        var s = that.value + '';
                        if (s.match(/em$/))
                            return that.numValue() * this.EM(viewPort);
                        if (s.match(/ex$/))
                            return that.numValue() * this.EM(viewPort) / 2.0;
                        if (s.match(/px$/))
                            return that.numValue();
                        if (s.match(/pt$/))
                            return that.numValue() * 1.25;
                        if (s.match(/pc$/))
                            return that.numValue() * 15;
                        if (s.match(/cm$/))
                            return that.numValue() * this.DPI(viewPort) / 2.54;
                        if (s.match(/mm$/))
                            return that.numValue() * this.DPI(viewPort) / 25.4;
                        if (s.match(/in$/))
                            return that.numValue() * this.DPI(viewPort);
                        if (s.match(/%$/))
                            return that.numValue() * svg.ViewPort.ComputeSize(viewPort);
                        return that.numValue()
                    }
            };
            this.Time = {toMilliseconds: function()
                {
                    if (!that.hasValue())
                        return 0;
                    var s = that.value + '';
                    if (s.match(/s$/))
                        return that.numValue() * 1000;
                    if (s.match(/ms$/))
                        return that.numValue();
                    return that.numValue()
                }};
            this.Angle = {toRadians: function()
                {
                    if (!that.hasValue())
                        return 0;
                    var s = that.value + '';
                    if (s.match(/deg$/))
                        return that.numValue() * (Math.PI / 180.0);
                    if (s.match(/grad$/))
                        return that.numValue() * (Math.PI / 200.0);
                    if (s.match(/rad$/))
                        return that.numValue();
                    return that.numValue() * (Math.PI / 180.0)
                }}
        };
        svg.Font = new(function()
        {
            this.Styles = ['normal', 'italic', 'oblique', 'inherit'];
            this.Variants = ['normal', 'small-caps', 'inherit'];
            this.Weights = ['normal', 'bold', 'bolder', 'lighter', '100', '200', '300', '400', '500', '600', '700', '800', '900', 'inherit'];
            this.CreateFont = function(fontStyle, fontVariant, fontWeight, fontSize, fontFamily, inherit)
            {
                var f = inherit != null ? this.Parse(inherit) : this.CreateFont('', '', '', '', '', svg.ctx.font);
                return {
                        fontFamily: fontFamily || f.fontFamily, fontSize: fontSize || f.fontSize, fontStyle: fontStyle || f.fontStyle, fontWeight: fontWeight || f.fontWeight, fontVariant: fontVariant || f.fontVariant, toString: function()
                            {
                                return [this.fontStyle, this.fontVariant, this.fontWeight, this.fontSize, this.fontFamily].join(' ')
                            }
                    }
            };
            var that = this;
            this.Parse = function(s)
            {
                var f = {};
                var d = svg.trim(svg.compressSpaces(s || '')).split(' ');
                var set = {
                        fontSize: false, fontStyle: false, fontWeight: false, fontVariant: false
                    };
                var ff = '';
                for (var i = 0; i < d.length; i++)
                {
                    if (!set.fontStyle && that.Styles.indexOf(d[i]) != -1)
                    {
                        if (d[i] != 'inherit')
                            f.fontStyle = d[i];
                        set.fontStyle = true
                    }
                    else if (!set.fontVariant && that.Variants.indexOf(d[i]) != -1)
                    {
                        if (d[i] != 'inherit')
                            f.fontVariant = d[i];
                        set.fontStyle = set.fontVariant = true
                    }
                    else if (!set.fontWeight && that.Weights.indexOf(d[i]) != -1)
                    {
                        if (d[i] != 'inherit')
                            f.fontWeight = d[i];
                        set.fontStyle = set.fontVariant = set.fontWeight = true
                    }
                    else if (!set.fontSize)
                    {
                        if (d[i] != 'inherit')
                            f.fontSize = d[i].split('/')[0];
                        set.fontStyle = set.fontVariant = set.fontWeight = set.fontSize = true
                    }
                    else
                    {
                        if (d[i] != 'inherit')
                            ff += d[i]
                    }
                }
                if (ff != '')
                    f.fontFamily = ff;
                return f
            }
        });
        svg.ToNumberArray = function(s)
        {
            var a = svg.trim(svg.compressSpaces((s || '').replace(/,/g, ' '))).split(' ');
            for (var i = 0; i < a.length; i++)
            {
                a[i] = parseFloat(a[i])
            }
            return a
        };
        svg.Point = function(x, y)
        {
            this.x = x;
            this.y = y;
            this.angleTo = function(p)
            {
                return Math.atan2(p.y - this.y, p.x - this.x)
            };
            this.applyTransform = function(v)
            {
                var xp = this.x * v[0] + this.y * v[2] + v[4];
                var yp = this.x * v[1] + this.y * v[3] + v[5];
                this.x = xp;
                this.y = yp
            }
        };
        svg.CreatePoint = function(s)
        {
            var a = svg.ToNumberArray(s);
            return new svg.Point(a[0], a[1])
        };
        svg.CreatePath = function(s)
        {
            var a = svg.ToNumberArray(s);
            var path = [];
            for (var i = 0; i < a.length; i += 2)
            {
                path.push(new svg.Point(a[i], a[i + 1]))
            }
            return path
        };
        svg.BoundingBox = function(x1, y1, x2, y2)
        {
            this.x1 = Number.NaN;
            this.y1 = Number.NaN;
            this.x2 = Number.NaN;
            this.y2 = Number.NaN;
            this.x = function()
            {
                return this.x1
            };
            this.y = function()
            {
                return this.y1
            };
            this.width = function()
            {
                return this.x2 - this.x1
            };
            this.height = function()
            {
                return this.y2 - this.y1
            };
            this.addPoint = function(x, y)
            {
                if (x != null)
                {
                    if (isNaN(this.x1) || isNaN(this.x2))
                    {
                        this.x1 = x;
                        this.x2 = x
                    }
                    if (x < this.x1)
                        this.x1 = x;
                    if (x > this.x2)
                        this.x2 = x
                }
                if (y != null)
                {
                    if (isNaN(this.y1) || isNaN(this.y2))
                    {
                        this.y1 = y;
                        this.y2 = y
                    }
                    if (y < this.y1)
                        this.y1 = y;
                    if (y > this.y2)
                        this.y2 = y
                }
            };
            this.addX = function(x)
            {
                this.addPoint(x, null)
            };
            this.addY = function(y)
            {
                this.addPoint(null, y)
            };
            this.addBoundingBox = function(bb)
            {
                this.addPoint(bb.x1, bb.y1);
                this.addPoint(bb.x2, bb.y2)
            };
            this.addQuadraticCurve = function(p0x, p0y, p1x, p1y, p2x, p2y)
            {
                var cp1x = p0x + 2 / 3 * (p1x - p0x);
                var cp1y = p0y + 2 / 3 * (p1y - p0y);
                var cp2x = cp1x + 1 / 3 * (p2x - p0x);
                var cp2y = cp1y + 1 / 3 * (p2y - p0y);
                this.addBezierCurve(p0x, p0y, cp1x, cp2x, cp1y, cp2y, p2x, p2y)
            };
            this.addBezierCurve = function(p0x, p0y, p1x, p1y, p2x, p2y, p3x, p3y)
            {
                var p0 = [p0x, p0y],
                    p1 = [p1x, p1y],
                    p2 = [p2x, p2y],
                    p3 = [p3x, p3y];
                this.addPoint(p0[0], p0[1]);
                this.addPoint(p3[0], p3[1]);
                for (i = 0; i <= 1; i++)
                {
                    var f = function(t)
                        {
                            return Math.pow(1 - t, 3) * p0[i] + 3 * Math.pow(1 - t, 2) * t * p1[i] + 3 * (1 - t) * Math.pow(t, 2) * p2[i] + Math.pow(t, 3) * p3[i]
                        };
                    var b = 6 * p0[i] - 12 * p1[i] + 6 * p2[i];
                    var a = -3 * p0[i] + 9 * p1[i] - 9 * p2[i] + 3 * p3[i];
                    var c = 3 * p1[i] - 3 * p0[i];
                    if (a == 0)
                    {
                        if (b == 0)
                            continue;
                        var t = -c / b;
                        if (0 < t && t < 1)
                        {
                            if (i == 0)
                                this.addX(f(t));
                            if (i == 1)
                                this.addY(f(t))
                        }
                        continue
                    }
                    var b2ac = Math.pow(b, 2) - 4 * c * a;
                    if (b2ac < 0)
                        continue;
                    var t1 = (-b + Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t1 && t1 < 1)
                    {
                        if (i == 0)
                            this.addX(f(t1));
                        if (i == 1)
                            this.addY(f(t1))
                    }
                    var t2 = (-b - Math.sqrt(b2ac)) / (2 * a);
                    if (0 < t2 && t2 < 1)
                    {
                        if (i == 0)
                            this.addX(f(t2));
                        if (i == 1)
                            this.addY(f(t2))
                    }
                }
            };
            this.isPointInBox = function(x, y)
            {
                return (this.x1 <= x && x <= this.x2 && this.y1 <= y && y <= this.y2)
            };
            this.addPoint(x1, y1);
            this.addPoint(x2, y2)
        };
        svg.Transform = function(v)
        {
            var that = this;
            this.Type = {};
            this.Type.translate = function(s)
            {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx)
                {
                    ctx.translate(this.p.x || 0.0, this.p.y || 0.0)
                };
                this.applyToPoint = function(p)
                {
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0])
                }
            };
            this.Type.rotate = function(s)
            {
                var a = svg.ToNumberArray(s);
                this.angle = new svg.Property('angle', a[0]);
                this.cx = a[1] || 0;
                this.cy = a[2] || 0;
                this.apply = function(ctx)
                {
                    ctx.translate(this.cx, this.cy);
                    ctx.rotate(this.angle.Angle.toRadians());
                    ctx.translate(-this.cx, -this.cy)
                };
                this.applyToPoint = function(p)
                {
                    var a = this.angle.Angle.toRadians();
                    p.applyTransform([1, 0, 0, 1, this.p.x || 0.0, this.p.y || 0.0]);
                    p.applyTransform([Math.cos(a), Math.sin(a), -Math.sin(a), Math.cos(a), 0, 0]);
                    p.applyTransform([1, 0, 0, 1, -this.p.x || 0.0, -this.p.y || 0.0])
                }
            };
            this.Type.scale = function(s)
            {
                this.p = svg.CreatePoint(s);
                this.apply = function(ctx)
                {
                    ctx.scale(this.p.x || 1.0, this.p.y || this.p.x || 1.0)
                };
                this.applyToPoint = function(p)
                {
                    p.applyTransform([this.p.x || 0.0, 0, 0, this.p.y || 0.0, 0, 0])
                }
            };
            this.Type.matrix = function(s)
            {
                this.m = svg.ToNumberArray(s);
                this.apply = function(ctx)
                {
                    ctx.transform(this.m[0], this.m[1], this.m[2], this.m[3], this.m[4], this.m[5])
                };
                this.applyToPoint = function(p)
                {
                    p.applyTransform(this.m)
                }
            };
            this.Type.SkewBase = function(s)
            {
                this.base = that.Type.matrix;
                this.base(s);
                this.angle = new svg.Property('angle', s)
            };
            this.Type.SkewBase.prototype = new this.Type.matrix;
            this.Type.skewX = function(s)
            {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, 0, Math.tan(this.angle.Angle.toRadians()), 1, 0, 0]
            };
            this.Type.skewX.prototype = new this.Type.SkewBase;
            this.Type.skewY = function(s)
            {
                this.base = that.Type.SkewBase;
                this.base(s);
                this.m = [1, Math.tan(this.angle.Angle.toRadians()), 0, 1, 0, 0]
            };
            this.Type.skewY.prototype = new this.Type.SkewBase;
            this.transforms = [];
            this.apply = function(ctx)
            {
                for (var i = 0; i < this.transforms.length; i++)
                {
                    this.transforms[i].apply(ctx)
                }
            };
            this.applyToPoint = function(p)
            {
                for (var i = 0; i < this.transforms.length; i++)
                {
                    this.transforms[i].applyToPoint(p)
                }
            };
            var data = svg.trim(svg.compressSpaces(v)).split(/\s(?=[a-z])/);
            for (var i = 0; i < data.length; i++)
            {
                var type = data[i].split('(')[0];
                var s = data[i].split('(')[1].replace(')', '');
                var transform = new this.Type[type](s);
                this.transforms.push(transform)
            }
        };
        svg.AspectRatio = function(ctx, aspectRatio, width, desiredWidth, height, desiredHeight, minX, minY, refX, refY)
        {
            aspectRatio = svg.compressSpaces(aspectRatio);
            aspectRatio = aspectRatio.replace(/^defer\s/, '');
            var align = aspectRatio.split(' ')[0] || 'xMidYMid';
            var meetOrSlice = aspectRatio.split(' ')[1] || 'meet';
            var scaleX = width / desiredWidth;
            var scaleY = height / desiredHeight;
            var scaleMin = Math.min(scaleX, scaleY);
            var scaleMax = Math.max(scaleX, scaleY);
            if (meetOrSlice == 'meet')
            {
                desiredWidth *= scaleMin;
                desiredHeight *= scaleMin
            }
            if (meetOrSlice == 'slice')
            {
                desiredWidth *= scaleMax;
                desiredHeight *= scaleMax
            }
            refX = new svg.Property('refX', refX);
            refY = new svg.Property('refY', refY);
            if (refX.hasValue() && refY.hasValue())
            {
                ctx.translate(-scaleMin * refX.Length.toPixels('x'), -scaleMin * refY.Length.toPixels('y'))
            }
            else
            {
                if (align.match(/^xMid/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY)))
                    ctx.translate(width / 2.0 - desiredWidth / 2.0, 0);
                if (align.match(/YMid$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX)))
                    ctx.translate(0, height / 2.0 - desiredHeight / 2.0);
                if (align.match(/^xMax/) && ((meetOrSlice == 'meet' && scaleMin == scaleY) || (meetOrSlice == 'slice' && scaleMax == scaleY)))
                    ctx.translate(width - desiredWidth, 0);
                if (align.match(/YMax$/) && ((meetOrSlice == 'meet' && scaleMin == scaleX) || (meetOrSlice == 'slice' && scaleMax == scaleX)))
                    ctx.translate(0, height - desiredHeight)
            }
            if (align == 'none')
                ctx.scale(scaleX, scaleY);
            else if (meetOrSlice == 'meet')
                ctx.scale(scaleMin, scaleMin);
            else if (meetOrSlice == 'slice')
                ctx.scale(scaleMax, scaleMax);
            ctx.translate(minX == null ? 0 : -minX, minY == null ? 0 : -minY)
        };
        svg.Element = {};
        svg.Element.ElementBase = function(node)
        {
            this.attributes = {};
            this.styles = {};
            this.children = [];
            this.attribute = function(name, createIfNotExists)
            {
                var a = this.attributes[name];
                if (a != null)
                    return a;
                a = new svg.Property(name, '');
                if (createIfNotExists == true)
                    this.attributes[name] = a;
                return a
            };
            this.style = function(name, createIfNotExists)
            {
                var s = this.styles[name];
                if (s != null)
                    return s;
                var a = this.attribute(name);
                if (a != null && a.hasValue())
                {
                    return a
                }
                var p = this.parent;
                if (p != null)
                {
                    var ps = p.style(name);
                    if (ps != null && ps.hasValue())
                    {
                        return ps
                    }
                }
                s = new svg.Property(name, '');
                if (createIfNotExists == true)
                    this.styles[name] = s;
                return s
            };
            this.render = function(ctx)
            {
                if (this.style('display').value == 'none')
                    return;
                if (this.attribute('visibility').value == 'hidden')
                    return;
                ctx.save();
                this.setContext(ctx);
                if (this.attribute('mask').hasValue())
                {
                    var mask = this.attribute('mask').Definition.getDefinition();
                    if (mask != null)
                        mask.apply(ctx, this)
                }
                else if (this.style('filter').hasValue())
                {
                    var filter = this.style('filter').Definition.getDefinition();
                    if (filter != null)
                        filter.apply(ctx, this)
                }
                else
                    this.renderChildren(ctx);
                this.clearContext(ctx);
                ctx.restore()
            };
            this.setContext = function(ctx){};
            this.clearContext = function(ctx){};
            this.renderChildren = function(ctx)
            {
                for (var i = 0; i < this.children.length; i++)
                {
                    this.children[i].render(ctx)
                }
            };
            this.addChild = function(childNode, create)
            {
                var child = childNode;
                if (create)
                    child = svg.CreateElement(childNode);
                child.parent = this;
                this.children.push(child)
            };
            if (node != null && node.nodeType == 1)
            {
                for (var i = 0; i < node.childNodes.length; i++)
                {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1)
                        this.addChild(childNode, true)
                }
                for (var i = 0; i < node.attributes.length; i++)
                {
                    var attribute = node.attributes[i];
                    this.attributes[attribute.nodeName] = new svg.Property(attribute.nodeName, attribute.nodeValue)
                }
                var styles = svg.Styles[node.nodeName];
                if (styles != null)
                {
                    for (var name in styles)
                    {
                        this.styles[name] = styles[name]
                    }
                }
                if (this.attribute('class').hasValue())
                {
                    var classes = svg.compressSpaces(this.attribute('class').value).split(' ');
                    for (var j = 0; j < classes.length; j++)
                    {
                        styles = svg.Styles['.' + classes[j]];
                        if (styles != null)
                        {
                            for (var name in styles)
                            {
                                this.styles[name] = styles[name]
                            }
                        }
                        styles = svg.Styles[node.nodeName + '.' + classes[j]];
                        if (styles != null)
                        {
                            for (var name in styles)
                            {
                                this.styles[name] = styles[name]
                            }
                        }
                    }
                }
                if (this.attribute('style').hasValue())
                {
                    var styles = this.attribute('style').value.split(';');
                    for (var i = 0; i < styles.length; i++)
                    {
                        if (svg.trim(styles[i]) != '')
                        {
                            var style = styles[i].split(':');
                            var name = svg.trim(style[0]);
                            var value = svg.trim(style[1]);
                            this.styles[name] = new svg.Property(name, value)
                        }
                    }
                }
                if (this.attribute('id').hasValue())
                {
                    if (svg.Definitions[this.attribute('id').value] == null)
                    {
                        svg.Definitions[this.attribute('id').value] = this
                    }
                }
            }
        };
        svg.Element.RenderedElementBase = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.setContext = function(ctx)
            {
                if (this.style('fill').Definition.isUrl())
                {
                    var fs = this.style('fill').Definition.getFillStyle(this);
                    if (fs != null)
                        ctx.fillStyle = fs
                }
                else if (this.style('fill').hasValue())
                {
                    var fillStyle = this.style('fill');
                    if (this.style('fill-opacity').hasValue())
                        fillStyle = fillStyle.Color.addOpacity(this.style('fill-opacity').value);
                    ctx.fillStyle = (fillStyle.value == 'none' ? 'rgba(0,0,0,0)' : fillStyle.value)
                }
                if (this.style('stroke').Definition.isUrl())
                {
                    var fs = this.style('stroke').Definition.getFillStyle(this);
                    if (fs != null)
                        ctx.strokeStyle = fs
                }
                else if (this.style('stroke').hasValue())
                {
                    var strokeStyle = this.style('stroke');
                    if (this.style('stroke-opacity').hasValue())
                        strokeStyle = strokeStyle.Color.addOpacity(this.style('stroke-opacity').value);
                    ctx.strokeStyle = (strokeStyle.value == 'none' ? 'rgba(0,0,0,0)' : strokeStyle.value)
                }
                if (this.style('stroke-width').hasValue())
                    ctx.lineWidth = this.style('stroke-width').Length.toPixels();
                if (this.style('stroke-linecap').hasValue())
                    ctx.lineCap = this.style('stroke-linecap').value;
                if (this.style('stroke-linejoin').hasValue())
                    ctx.lineJoin = this.style('stroke-linejoin').value;
                if (this.style('stroke-miterlimit').hasValue())
                    ctx.miterLimit = this.style('stroke-miterlimit').value;
                if (typeof(ctx.font) != 'undefined')
                {
                    ctx.font = svg.Font.CreateFont(this.style('font-style').value, this.style('font-variant').value, this.style('font-weight').value, this.style('font-size').hasValue() ? this.style('font-size').Length.toPixels() + 'px' : '', this.style('font-family').value).toString()
                }
                if (this.attribute('transform').hasValue())
                {
                    var transform = new svg.Transform(this.attribute('transform').value);
                    transform.apply(ctx)
                }
                if (this.attribute('clip-path').hasValue())
                {
                    var clip = this.attribute('clip-path').Definition.getDefinition();
                    if (clip != null)
                        clip.apply(ctx)
                }
                if (this.style('opacity').hasValue())
                {
                    ctx.globalAlpha = this.style('opacity').numValue()
                }
            }
        };
        svg.Element.RenderedElementBase.prototype = new svg.Element.ElementBase;
        svg.Element.PathElementBase = function(node)
        {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.path = function(ctx)
            {
                if (ctx != null)
                    ctx.beginPath();
                return new svg.BoundingBox
            };
            this.renderChildren = function(ctx)
            {
                this.path(ctx);
                svg.Mouse.checkPath(this, ctx);
                if (ctx.fillStyle != '')
                    ctx.fill();
                if (ctx.strokeStyle != '')
                    ctx.stroke();
                var markers = this.getMarkers();
                if (markers != null)
                {
                    if (this.style('marker-start').Definition.isUrl())
                    {
                        var marker = this.style('marker-start').Definition.getDefinition();
                        marker.render(ctx, markers[0][0], markers[0][1])
                    }
                    if (this.style('marker-mid').Definition.isUrl())
                    {
                        var marker = this.style('marker-mid').Definition.getDefinition();
                        for (var i = 1; i < markers.length - 1; i++)
                        {
                            marker.render(ctx, markers[i][0], markers[i][1])
                        }
                    }
                    if (this.style('marker-end').Definition.isUrl())
                    {
                        var marker = this.style('marker-end').Definition.getDefinition();
                        marker.render(ctx, markers[markers.length - 1][0], markers[markers.length - 1][1])
                    }
                }
            };
            this.getBoundingBox = function()
            {
                return this.path()
            };
            this.getMarkers = function()
            {
                return null
            }
        };
        svg.Element.PathElementBase.prototype = new svg.Element.RenderedElementBase;
        svg.Element.svg = function(node)
        {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseClearContext = this.clearContext;
            this.clearContext = function(ctx)
            {
                this.baseClearContext(ctx);
                svg.ViewPort.RemoveCurrent()
            };
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx)
            {
                ctx.strokeStyle = 'rgba(0,0,0,0)';
                ctx.lineCap = 'butt';
                ctx.lineJoin = 'miter';
                ctx.miterLimit = 4;
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue() && this.attribute('y').hasValue())
                {
                    ctx.translate(this.attribute('x').Length.toPixels('x'), this.attribute('y').Length.toPixels('y'))
                }
                var width = svg.ViewPort.width();
                var height = svg.ViewPort.height();
                if (typeof(this.root) == 'undefined' && this.attribute('width').hasValue() && this.attribute('height').hasValue())
                {
                    width = this.attribute('width').Length.toPixels('x');
                    height = this.attribute('height').Length.toPixels('y');
                    var x = 0;
                    var y = 0;
                    if (this.attribute('refX').hasValue() && this.attribute('refY').hasValue())
                    {
                        x = -this.attribute('refX').Length.toPixels('x');
                        y = -this.attribute('refY').Length.toPixels('y')
                    }
                    ctx.beginPath();
                    ctx.moveTo(x, y);
                    ctx.lineTo(width, y);
                    ctx.lineTo(width, height);
                    ctx.lineTo(x, height);
                    ctx.closePath();
                    ctx.clip()
                }
                svg.ViewPort.SetCurrent(width, height);
                if (this.attribute('viewBox').hasValue())
                {
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    svg.AspectRatio(ctx, this.attribute('preserveAspectRatio').value, svg.ViewPort.width(), width, svg.ViewPort.height(), height, minX, minY, this.attribute('refX').value, this.attribute('refY').value);
                    svg.ViewPort.RemoveCurrent();
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3])
                }
            }
        };
        svg.Element.svg.prototype = new svg.Element.RenderedElementBase;
        svg.Element.rect = function(node)
        {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx)
            {
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                var width = this.attribute('width').Length.toPixels('x');
                var height = this.attribute('height').Length.toPixels('y');
                var rx = this.attribute('rx').Length.toPixels('x');
                var ry = this.attribute('ry').Length.toPixels('y');
                if (this.attribute('rx').hasValue() && !this.attribute('ry').hasValue())
                    ry = rx;
                if (this.attribute('ry').hasValue() && !this.attribute('rx').hasValue())
                    rx = ry;
                if (ctx != null)
                {
                    ctx.beginPath();
                    ctx.moveTo(x + rx, y);
                    ctx.lineTo(x + width - rx, y);
                    ctx.quadraticCurveTo(x + width, y, x + width, y + ry);
                    ctx.lineTo(x + width, y + height - ry);
                    ctx.quadraticCurveTo(x + width, y + height, x + width - rx, y + height);
                    ctx.lineTo(x + rx, y + height);
                    ctx.quadraticCurveTo(x, y + height, x, y + height - ry);
                    ctx.lineTo(x, y + ry);
                    ctx.quadraticCurveTo(x, y, x + rx, y);
                    ctx.closePath()
                }
                return new svg.BoundingBox(x, y, x + width, y + height)
            }
        };
        svg.Element.rect.prototype = new svg.Element.PathElementBase;
        svg.Element.circle = function(node)
        {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx)
            {
                var cx = this.attribute('cx').Length.toPixels('x');
                var cy = this.attribute('cy').Length.toPixels('y');
                var r = this.attribute('r').Length.toPixels();
                if (ctx != null)
                {
                    ctx.beginPath();
                    ctx.arc(cx, cy, r, 0, Math.PI * 2, true);
                    ctx.closePath()
                }
                return new svg.BoundingBox(cx - r, cy - r, cx + r, cy + r)
            }
        };
        svg.Element.circle.prototype = new svg.Element.PathElementBase;
        svg.Element.ellipse = function(node)
        {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.path = function(ctx)
            {
                var KAPPA = 4 * ((Math.sqrt(2) - 1) / 3);
                var rx = this.attribute('rx').Length.toPixels('x');
                var ry = this.attribute('ry').Length.toPixels('y');
                var cx = this.attribute('cx').Length.toPixels('x');
                var cy = this.attribute('cy').Length.toPixels('y');
                if (ctx != null)
                {
                    ctx.beginPath();
                    ctx.moveTo(cx, cy - ry);
                    ctx.bezierCurveTo(cx + (KAPPA * rx), cy - ry, cx + rx, cy - (KAPPA * ry), cx + rx, cy);
                    ctx.bezierCurveTo(cx + rx, cy + (KAPPA * ry), cx + (KAPPA * rx), cy + ry, cx, cy + ry);
                    ctx.bezierCurveTo(cx - (KAPPA * rx), cy + ry, cx - rx, cy + (KAPPA * ry), cx - rx, cy);
                    ctx.bezierCurveTo(cx - rx, cy - (KAPPA * ry), cx - (KAPPA * rx), cy - ry, cx, cy - ry);
                    ctx.closePath()
                }
                return new svg.BoundingBox(cx - rx, cy - ry, cx + rx, cy + ry)
            }
        };
        svg.Element.ellipse.prototype = new svg.Element.PathElementBase;
        svg.Element.line = function(node)
        {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.getPoints = function()
            {
                return [new svg.Point(this.attribute('x1').Length.toPixels('x'), this.attribute('y1').Length.toPixels('y')), new svg.Point(this.attribute('x2').Length.toPixels('x'), this.attribute('y2').Length.toPixels('y'))]
            };
            this.path = function(ctx)
            {
                var points = this.getPoints();
                if (ctx != null)
                {
                    ctx.beginPath();
                    ctx.moveTo(points[0].x, points[0].y);
                    ctx.lineTo(points[1].x, points[1].y)
                }
                return new svg.BoundingBox(points[0].x, points[0].y, points[1].x, points[1].y)
            };
            this.getMarkers = function()
            {
                var points = this.getPoints();
                var a = points[0].angleTo(points[1]);
                return [[points[0], a], [points[1], a]]
            }
        };
        svg.Element.line.prototype = new svg.Element.PathElementBase;
        svg.Element.polyline = function(node)
        {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            this.points = svg.CreatePath(this.attribute('points').value);
            this.path = function(ctx)
            {
                var bb = new svg.BoundingBox(this.points[0].x, this.points[0].y);
                if (ctx != null)
                {
                    ctx.beginPath();
                    ctx.moveTo(this.points[0].x, this.points[0].y)
                }
                for (var i = 1; i < this.points.length; i++)
                {
                    bb.addPoint(this.points[i].x, this.points[i].y);
                    if (ctx != null)
                        ctx.lineTo(this.points[i].x, this.points[i].y)
                }
                return bb
            };
            this.getMarkers = function()
            {
                var markers = [];
                for (var i = 0; i < this.points.length - 1; i++)
                {
                    markers.push([this.points[i], this.points[i].angleTo(this.points[i + 1])])
                }
                markers.push([this.points[this.points.length - 1], markers[markers.length - 1][1]]);
                return markers
            }
        };
        svg.Element.polyline.prototype = new svg.Element.PathElementBase;
        svg.Element.polygon = function(node)
        {
            this.base = svg.Element.polyline;
            this.base(node);
            this.basePath = this.path;
            this.path = function(ctx)
            {
                var bb = this.basePath(ctx);
                if (ctx != null)
                {
                    ctx.lineTo(this.points[0].x, this.points[0].y);
                    ctx.closePath()
                }
                return bb
            }
        };
        svg.Element.polygon.prototype = new svg.Element.polyline;
        svg.Element.path = function(node)
        {
            this.base = svg.Element.PathElementBase;
            this.base(node);
            var d = this.attribute('d').value;
            d = d.replace(/,/gm, ' ');
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, '$1 $2');
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([MmZzLlHhVvCcSsQqTtAa])/gm, '$1 $2');
            d = d.replace(/([MmZzLlHhVvCcSsQqTtAa])([^\s])/gm, '$1 $2');
            d = d.replace(/([^\s])([MmZzLlHhVvCcSsQqTtAa])/gm, '$1 $2');
            d = d.replace(/([0-9])([+\-])/gm, '$1 $2');
            d = d.replace(/(\.[0-9]*)(\.)/gm, '$1 $2');
            d = d.replace(/([Aa](\s+[0-9]+){3})\s+([01])\s*([01])/gm, '$1 $3 $4 ');
            d = svg.compressSpaces(d);
            d = svg.trim(d);
            this.PathParser = new(function(d)
            {
                this.tokens = d.split(' ');
                this.reset = function()
                {
                    this.i = -1;
                    this.command = '';
                    this.previousCommand = '';
                    this.start = new svg.Point(0, 0);
                    this.control = new svg.Point(0, 0);
                    this.current = new svg.Point(0, 0);
                    this.points = [];
                    this.angles = []
                };
                this.isEnd = function()
                {
                    return this.i >= this.tokens.length - 1
                };
                this.isCommandOrEnd = function()
                {
                    if (this.isEnd())
                        return true;
                    return this.tokens[this.i + 1].match(/^[A-Za-z]$/) != null
                };
                this.isRelativeCommand = function()
                {
                    return this.command == this.command.toLowerCase()
                };
                this.getToken = function()
                {
                    this.i = this.i + 1;
                    return this.tokens[this.i]
                };
                this.getScalar = function()
                {
                    return parseFloat(this.getToken())
                };
                this.nextCommand = function()
                {
                    this.previousCommand = this.command;
                    this.command = this.getToken()
                };
                this.getPoint = function()
                {
                    var p = new svg.Point(this.getScalar(), this.getScalar());
                    return this.makeAbsolute(p)
                };
                this.getAsControlPoint = function()
                {
                    var p = this.getPoint();
                    this.control = p;
                    return p
                };
                this.getAsCurrentPoint = function()
                {
                    var p = this.getPoint();
                    this.current = p;
                    return p
                };
                this.getReflectedControlPoint = function()
                {
                    if (this.previousCommand.toLowerCase() != 'c' && this.previousCommand.toLowerCase() != 's')
                    {
                        return this.current
                    }
                    var p = new svg.Point(2 * this.current.x - this.control.x, 2 * this.current.y - this.control.y);
                    return p
                };
                this.makeAbsolute = function(p)
                {
                    if (this.isRelativeCommand())
                    {
                        p.x = this.current.x + p.x;
                        p.y = this.current.y + p.y
                    }
                    return p
                };
                this.addMarker = function(p, from, priorTo)
                {
                    if (priorTo != null && this.angles.length > 0 && this.angles[this.angles.length - 1] == null)
                    {
                        this.angles[this.angles.length - 1] = this.points[this.points.length - 1].angleTo(priorTo)
                    }
                    this.addMarkerAngle(p, from == null ? null : from.angleTo(p))
                };
                this.addMarkerAngle = function(p, a)
                {
                    this.points.push(p);
                    this.angles.push(a)
                };
                this.getMarkerPoints = function()
                {
                    return this.points
                };
                this.getMarkerAngles = function()
                {
                    for (var i = 0; i < this.angles.length; i++)
                    {
                        if (this.angles[i] == null)
                        {
                            for (var j = i + 1; j < this.angles.length; j++)
                            {
                                if (this.angles[j] != null)
                                {
                                    this.angles[i] = this.angles[j];
                                    break
                                }
                            }
                        }
                    }
                    return this.angles
                }
            })(d);
            this.path = function(ctx)
            {
                var pp = this.PathParser;
                pp.reset();
                var bb = new svg.BoundingBox;
                if (ctx != null)
                    ctx.beginPath();
                while (!pp.isEnd())
                {
                    pp.nextCommand();
                    switch (pp.command.toUpperCase())
                    {
                        case'M':
                            var p = pp.getAsCurrentPoint();
                            pp.addMarker(p);
                            bb.addPoint(p.x, p.y);
                            if (ctx != null)
                                ctx.moveTo(p.x, p.y);
                            pp.start = pp.current;
                            while (!pp.isCommandOrEnd())
                            {
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, pp.start);
                                bb.addPoint(p.x, p.y);
                                if (ctx != null)
                                    ctx.lineTo(p.x, p.y)
                            }
                            break;
                        case'L':
                            while (!pp.isCommandOrEnd())
                            {
                                var c = pp.current;
                                var p = pp.getAsCurrentPoint();
                                pp.addMarker(p, c);
                                bb.addPoint(p.x, p.y);
                                if (ctx != null)
                                    ctx.lineTo(p.x, p.y)
                            }
                            break;
                        case'H':
                            while (!pp.isCommandOrEnd())
                            {
                                var newP = new svg.Point((pp.isRelativeCommand() ? pp.current.x : 0) + pp.getScalar(), pp.current.y);
                                pp.addMarker(newP, pp.current);
                                pp.current = newP;
                                bb.addPoint(pp.current.x, pp.current.y);
                                if (ctx != null)
                                    ctx.lineTo(pp.current.x, pp.current.y)
                            }
                            break;
                        case'V':
                            while (!pp.isCommandOrEnd())
                            {
                                var newP = new svg.Point(pp.current.x, (pp.isRelativeCommand() ? pp.current.y : 0) + pp.getScalar());
                                pp.addMarker(newP, pp.current);
                                pp.current = newP;
                                bb.addPoint(pp.current.x, pp.current.y);
                                if (ctx != null)
                                    ctx.lineTo(pp.current.x, pp.current.y)
                            }
                            break;
                        case'C':
                            while (!pp.isCommandOrEnd())
                            {
                                var curr = pp.current;
                                var p1 = pp.getPoint();
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1);
                                bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null)
                                    ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case'S':
                            while (!pp.isCommandOrEnd())
                            {
                                var curr = pp.current;
                                var p1 = pp.getReflectedControlPoint();
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, p1);
                                bb.addBezierCurve(curr.x, curr.y, p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null)
                                    ctx.bezierCurveTo(p1.x, p1.y, cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case'Q':
                            while (!pp.isCommandOrEnd())
                            {
                                var curr = pp.current;
                                var cntrl = pp.getAsControlPoint();
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl);
                                bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null)
                                    ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case'T':
                            while (!pp.isCommandOrEnd())
                            {
                                var curr = pp.current;
                                var cntrl = pp.getReflectedControlPoint();
                                pp.control = cntrl;
                                var cp = pp.getAsCurrentPoint();
                                pp.addMarker(cp, cntrl, cntrl);
                                bb.addQuadraticCurve(curr.x, curr.y, cntrl.x, cntrl.y, cp.x, cp.y);
                                if (ctx != null)
                                    ctx.quadraticCurveTo(cntrl.x, cntrl.y, cp.x, cp.y)
                            }
                            break;
                        case'A':
                            while (!pp.isCommandOrEnd())
                            {
                                var curr = pp.current;
                                var rx = pp.getScalar();
                                var ry = pp.getScalar();
                                var xAxisRotation = pp.getScalar() * (Math.PI / 180.0);
                                var largeArcFlag = pp.getScalar();
                                var sweepFlag = pp.getScalar();
                                var cp = pp.getAsCurrentPoint();
                                var currp = new svg.Point(Math.cos(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.sin(xAxisRotation) * (curr.y - cp.y) / 2.0, -Math.sin(xAxisRotation) * (curr.x - cp.x) / 2.0 + Math.cos(xAxisRotation) * (curr.y - cp.y) / 2.0);
                                var l = Math.pow(currp.x, 2) / Math.pow(rx, 2) + Math.pow(currp.y, 2) / Math.pow(ry, 2);
                                if (l > 1)
                                {
                                    rx *= Math.sqrt(l);
                                    ry *= Math.sqrt(l)
                                }
                                var s = (largeArcFlag == sweepFlag ? -1 : 1) * Math.sqrt(((Math.pow(rx, 2) * Math.pow(ry, 2)) - (Math.pow(rx, 2) * Math.pow(currp.y, 2)) - (Math.pow(ry, 2) * Math.pow(currp.x, 2))) / (Math.pow(rx, 2) * Math.pow(currp.y, 2) + Math.pow(ry, 2) * Math.pow(currp.x, 2)));
                                if (isNaN(s))
                                    s = 0;
                                var cpp = new svg.Point(s * rx * currp.y / ry, s * -ry * currp.x / rx);
                                var centp = new svg.Point((curr.x + cp.x) / 2.0 + Math.cos(xAxisRotation) * cpp.x - Math.sin(xAxisRotation) * cpp.y, (curr.y + cp.y) / 2.0 + Math.sin(xAxisRotation) * cpp.x + Math.cos(xAxisRotation) * cpp.y);
                                var m = function(v)
                                    {
                                        return Math.sqrt(Math.pow(v[0], 2) + Math.pow(v[1], 2))
                                    };
                                var r = function(u, v)
                                    {
                                        return (u[0] * v[0] + u[1] * v[1]) / (m(u) * m(v))
                                    };
                                var a = function(u, v)
                                    {
                                        return (u[0] * v[1] < u[1] * v[0] ? -1 : 1) * Math.acos(r(u, v))
                                    };
                                var a1 = a([1, 0], [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry]);
                                var u = [(currp.x - cpp.x) / rx, (currp.y - cpp.y) / ry];
                                var v = [(-currp.x - cpp.x) / rx, (-currp.y - cpp.y) / ry];
                                var ad = a(u, v);
                                if (r(u, v) <= -1)
                                    ad = Math.PI;
                                if (r(u, v) >= 1)
                                    ad = 0;
                                if (sweepFlag == 0 && ad > 0)
                                    ad = ad - 2 * Math.PI;
                                if (sweepFlag == 1 && ad < 0)
                                    ad = ad + 2 * Math.PI;
                                var halfWay = new svg.Point(centp.x - rx * Math.cos((a1 + ad) / 2), centp.y - ry * Math.sin((a1 + ad) / 2));
                                pp.addMarkerAngle(halfWay, (a1 + ad) / 2 + (sweepFlag == 0 ? 1 : -1) * Math.PI / 2);
                                pp.addMarkerAngle(cp, ad + (sweepFlag == 0 ? 1 : -1) * Math.PI / 2);
                                bb.addPoint(cp.x, cp.y);
                                if (ctx != null)
                                {
                                    var r = rx > ry ? rx : ry;
                                    var sx = rx > ry ? 1 : rx / ry;
                                    var sy = rx > ry ? ry / rx : 1;
                                    ctx.translate(centp.x, centp.y);
                                    ctx.rotate(xAxisRotation);
                                    ctx.scale(sx, sy);
                                    ctx.arc(0, 0, r, a1, a1 + ad, 1 - sweepFlag);
                                    ctx.scale(1 / sx, 1 / sy);
                                    ctx.rotate(-xAxisRotation);
                                    ctx.translate(-centp.x, -centp.y)
                                }
                            }
                            break;
                        case'Z':
                            if (ctx != null)
                                ctx.closePath();
                            pp.current = pp.start
                    }
                }
                return bb
            };
            this.getMarkers = function()
            {
                var points = this.PathParser.getMarkerPoints();
                var angles = this.PathParser.getMarkerAngles();
                var markers = [];
                for (var i = 0; i < points.length; i++)
                {
                    markers.push([points[i], angles[i]])
                }
                return markers
            }
        };
        svg.Element.path.prototype = new svg.Element.PathElementBase;
        svg.Element.pattern = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.createPattern = function(ctx, element)
            {
                var tempSvg = new svg.Element.svg;
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['x'] = new svg.Property('x', this.attribute('x').value);
                tempSvg.attributes['y'] = new svg.Property('y', this.attribute('y').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('width').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('height').value);
                tempSvg.children = this.children;
                var c = document.createElement('canvas');
                c.width = this.attribute('width').Length.toPixels('x');
                c.height = this.attribute('height').Length.toPixels('y');
                tempSvg.render(c.getContext('2d'));
                return ctx.createPattern(c, 'repeat')
            }
        };
        svg.Element.pattern.prototype = new svg.Element.ElementBase;
        svg.Element.marker = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.baseRender = this.render;
            this.render = function(ctx, point, angle)
            {
                ctx.translate(point.x, point.y);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto')
                    ctx.rotate(angle);
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth')
                    ctx.scale(ctx.lineWidth, ctx.lineWidth);
                ctx.save();
                var tempSvg = new svg.Element.svg;
                tempSvg.attributes['viewBox'] = new svg.Property('viewBox', this.attribute('viewBox').value);
                tempSvg.attributes['refX'] = new svg.Property('refX', this.attribute('refX').value);
                tempSvg.attributes['refY'] = new svg.Property('refY', this.attribute('refY').value);
                tempSvg.attributes['width'] = new svg.Property('width', this.attribute('markerWidth').value);
                tempSvg.attributes['height'] = new svg.Property('height', this.attribute('markerHeight').value);
                tempSvg.attributes['fill'] = new svg.Property('fill', this.attribute('fill').valueOrDefault('black'));
                tempSvg.attributes['stroke'] = new svg.Property('stroke', this.attribute('stroke').valueOrDefault('none'));
                tempSvg.children = this.children;
                tempSvg.render(ctx);
                ctx.restore();
                if (this.attribute('markerUnits').valueOrDefault('strokeWidth') == 'strokeWidth')
                    ctx.scale(1 / ctx.lineWidth, 1 / ctx.lineWidth);
                if (this.attribute('orient').valueOrDefault('auto') == 'auto')
                    ctx.rotate(-angle);
                ctx.translate(-point.x, -point.y)
            }
        };
        svg.Element.marker.prototype = new svg.Element.ElementBase;
        svg.Element.defs = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.render = function(ctx){}
        };
        svg.Element.defs.prototype = new svg.Element.ElementBase;
        svg.Element.GradientBase = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.gradientUnits = this.attribute('gradientUnits').valueOrDefault('objectBoundingBox');
            this.stops = [];
            for (var i = 0; i < this.children.length; i++)
            {
                var child = this.children[i];
                this.stops.push(child)
            }
            this.getGradient = function(){};
            this.createGradient = function(ctx, element)
            {
                var stopsContainer = this;
                if (this.attribute('xlink:href').hasValue())
                {
                    stopsContainer = this.attribute('xlink:href').Definition.getDefinition()
                }
                var g = this.getGradient(ctx, element);
                for (var i = 0; i < stopsContainer.stops.length; i++)
                {
                    g.addColorStop(stopsContainer.stops[i].offset, stopsContainer.stops[i].color)
                }
                if (this.attribute('gradientTransform').hasValue())
                {
                    var rootView = svg.ViewPort.viewPorts[0];
                    var rect = new svg.Element.rect;
                    rect.attributes['x'] = new svg.Property('x', -svg.MAX_VIRTUAL_PIXELS / 3.0);
                    rect.attributes['y'] = new svg.Property('y', -svg.MAX_VIRTUAL_PIXELS / 3.0);
                    rect.attributes['width'] = new svg.Property('width', svg.MAX_VIRTUAL_PIXELS);
                    rect.attributes['height'] = new svg.Property('height', svg.MAX_VIRTUAL_PIXELS);
                    var group = new svg.Element.g;
                    group.attributes['transform'] = new svg.Property('transform', this.attribute('gradientTransform').value);
                    group.children = [rect];
                    var tempSvg = new svg.Element.svg;
                    tempSvg.attributes['x'] = new svg.Property('x', 0);
                    tempSvg.attributes['y'] = new svg.Property('y', 0);
                    tempSvg.attributes['width'] = new svg.Property('width', rootView.width);
                    tempSvg.attributes['height'] = new svg.Property('height', rootView.height);
                    tempSvg.children = [group];
                    var c = document.createElement('canvas');
                    c.width = rootView.width;
                    c.height = rootView.height;
                    var tempCtx = c.getContext('2d');
                    tempCtx.fillStyle = g;
                    tempSvg.render(tempCtx);
                    return tempCtx.createPattern(c, 'no-repeat')
                }
                return g
            }
        };
        svg.Element.GradientBase.prototype = new svg.Element.ElementBase;
        svg.Element.linearGradient = function(node)
        {
            this.base = svg.Element.GradientBase;
            this.base(node);
            this.getGradient = function(ctx, element)
            {
                var bb = element.getBoundingBox();
                var x1 = (this.gradientUnits == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('x1').numValue() : this.attribute('x1').Length.toPixels('x'));
                var y1 = (this.gradientUnits == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('y1').numValue() : this.attribute('y1').Length.toPixels('y'));
                var x2 = (this.gradientUnits == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('x2').numValue() : this.attribute('x2').Length.toPixels('x'));
                var y2 = (this.gradientUnits == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('y2').numValue() : this.attribute('y2').Length.toPixels('y'));
                return ctx.createLinearGradient(x1, y1, x2, y2)
            }
        };
        svg.Element.linearGradient.prototype = new svg.Element.GradientBase;
        svg.Element.radialGradient = function(node)
        {
            this.base = svg.Element.GradientBase;
            this.base(node);
            this.getGradient = function(ctx, element)
            {
                var bb = element.getBoundingBox();
                var cx = (this.gradientUnits == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('cx').numValue() : this.attribute('cx').Length.toPixels('x'));
                var cy = (this.gradientUnits == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('cy').numValue() : this.attribute('cy').Length.toPixels('y'));
                var fx = cx;
                var fy = cy;
                if (this.attribute('fx').hasValue())
                {
                    fx = (this.gradientUnits == 'objectBoundingBox' ? bb.x() + bb.width() * this.attribute('fx').numValue() : this.attribute('fx').Length.toPixels('x'))
                }
                if (this.attribute('fy').hasValue())
                {
                    fy = (this.gradientUnits == 'objectBoundingBox' ? bb.y() + bb.height() * this.attribute('fy').numValue() : this.attribute('fy').Length.toPixels('y'))
                }
                var r = (this.gradientUnits == 'objectBoundingBox' ? (bb.width() + bb.height()) / 2.0 * this.attribute('r').numValue() : this.attribute('r').Length.toPixels());
                return ctx.createRadialGradient(fx, fy, 0, cx, cy, r)
            }
        };
        svg.Element.radialGradient.prototype = new svg.Element.GradientBase;
        svg.Element.stop = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.offset = this.attribute('offset').numValue();
            var stopColor = this.style('stop-color');
            if (this.style('stop-opacity').hasValue())
                stopColor = stopColor.Color.addOpacity(this.style('stop-opacity').value);
            this.color = stopColor.value
        };
        svg.Element.stop.prototype = new svg.Element.ElementBase;
        svg.Element.AnimateBase = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            svg.Animations.push(this);
            this.duration = 0.0;
            this.begin = this.attribute('begin').Time.toMilliseconds();
            this.maxDuration = this.begin + this.attribute('dur').Time.toMilliseconds();
            this.getProperty = function()
            {
                var attributeType = this.attribute('attributeType').value;
                var attributeName = this.attribute('attributeName').value;
                if (attributeType == 'CSS')
                {
                    return this.parent.style(attributeName, true)
                }
                return this.parent.attribute(attributeName, true)
            };
            this.initialValue = null;
            this.removed = false;
            this.calcValue = function()
            {
                return ''
            };
            this.update = function(delta)
            {
                if (this.initialValue == null)
                {
                    this.initialValue = this.getProperty().value
                }
                if (this.duration > this.maxDuration)
                {
                    if (this.attribute('repeatCount').value == 'indefinite')
                    {
                        this.duration = 0.0
                    }
                    else if (this.attribute('fill').valueOrDefault('remove') == 'remove' && !this.removed)
                    {
                        this.removed = true;
                        this.getProperty().value = this.initialValue;
                        return true
                    }
                    else
                    {
                        return false
                    }
                }
                this.duration = this.duration + delta;
                var updated = false;
                if (this.begin < this.duration)
                {
                    var newValue = this.calcValue();
                    if (this.attribute('type').hasValue())
                    {
                        var type = this.attribute('type').value;
                        newValue = type + '(' + newValue + ')'
                    }
                    this.getProperty().value = newValue;
                    updated = true
                }
                return updated
            };
            this.progress = function()
            {
                return ((this.duration - this.begin) / (this.maxDuration - this.begin))
            }
        };
        svg.Element.AnimateBase.prototype = new svg.Element.ElementBase;
        svg.Element.animate = function(node)
        {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            this.calcValue = function()
            {
                var from = this.attribute('from').numValue();
                var to = this.attribute('to').numValue();
                return from + (to - from) * this.progress()
            }
        };
        svg.Element.animate.prototype = new svg.Element.AnimateBase;
        svg.Element.animateColor = function(node)
        {
            this.base = svg.Element.AnimateBase;
            this.base(node);
            this.calcValue = function()
            {
                var from = new RGBColor(this.attribute('from').value);
                var to = new RGBColor(this.attribute('to').value);
                if (from.ok && to.ok)
                {
                    var r = from.r + (to.r - from.r) * this.progress();
                    var g = from.g + (to.g - from.g) * this.progress();
                    var b = from.b + (to.b - from.b) * this.progress();
                    return 'rgb(' + parseInt(r, 10) + ',' + parseInt(g, 10) + ',' + parseInt(b, 10) + ')'
                }
                return this.attribute('from').value
            }
        };
        svg.Element.animateColor.prototype = new svg.Element.AnimateBase;
        svg.Element.animateTransform = function(node)
        {
            this.base = svg.Element.animate;
            this.base(node)
        };
        svg.Element.animateTransform.prototype = new svg.Element.animate;
        svg.Element.font = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.isRTL = false;
            this.isArabic = false;
            this.fontFace = null;
            this.missingGlyph = null;
            this.glyphs = [];
            for (var i = 0; i < this.children.length; i++)
            {
                var child = this.children[i];
                if (child.type == 'font-face')
                {
                    this.fontFace = child;
                    if (child.style('font-family').hasValue())
                    {
                        svg.Definitions[child.style('font-family').value] = this
                    }
                }
                else if (child.type == 'missing-glyph')
                    this.missingGlyph = child;
                else if (child.type == 'glyph')
                {
                    if (child.arabicForm != '')
                    {
                        this.isRTL = true;
                        this.isArabic = true;
                        if (typeof(this.glyphs[child.unicode]) == 'undefined')
                            this.glyphs[child.unicode] = [];
                        this.glyphs[child.unicode][child.arabicForm] = child
                    }
                    else
                    {
                        this.glyphs[child.unicode] = child
                    }
                }
            }
        };
        svg.Element.font.prototype = new svg.Element.ElementBase;
        svg.Element.fontface = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.ascent = this.attribute('ascent').value;
            this.descent = this.attribute('descent').value;
            this.unitsPerEm = this.attribute('units-per-em').numValue()
        };
        svg.Element.fontface.prototype = new svg.Element.ElementBase;
        svg.Element.missingglyph = function(node)
        {
            this.base = svg.Element.path;
            this.base(node);
            this.horizAdvX = 0
        };
        svg.Element.missingglyph.prototype = new svg.Element.path;
        svg.Element.glyph = function(node)
        {
            this.base = svg.Element.path;
            this.base(node);
            this.horizAdvX = this.attribute('horiz-adv-x').numValue();
            this.unicode = this.attribute('unicode').value;
            this.arabicForm = this.attribute('arabic-form').value
        };
        svg.Element.glyph.prototype = new svg.Element.path;
        svg.Element.text = function(node)
        {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            if (node != null)
            {
                this.children = [];
                for (var i = 0; i < node.childNodes.length; i++)
                {
                    var childNode = node.childNodes[i];
                    if (childNode.nodeType == 1)
                    {
                        this.addChild(childNode, true)
                    }
                    else if (childNode.nodeType == 3)
                    {
                        this.addChild(new svg.Element.tspan(childNode), false)
                    }
                }
            }
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx)
            {
                this.baseSetContext(ctx);
                if (this.style('dominant-baseline').hasValue())
                    ctx.textBaseline = this.style('dominant-baseline').value;
                if (this.style('alignment-baseline').hasValue())
                    ctx.textBaseline = this.style('alignment-baseline').value
            };
            this.renderChildren = function(ctx)
            {
                var textAnchor = this.style('text-anchor').valueOrDefault('start');
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                for (var i = 0; i < this.children.length; i++)
                {
                    var child = this.children[i];
                    if (child.attribute('x').hasValue())
                    {
                        child.x = child.attribute('x').Length.toPixels('x')
                    }
                    else
                    {
                        if (child.attribute('dx').hasValue())
                            x += child.attribute('dx').Length.toPixels('x');
                        child.x = x
                    }
                    var childLength = child.measureText(ctx);
                    if (textAnchor != 'start' && (i == 0 || child.attribute('x').hasValue()))
                    {
                        var groupLength = childLength;
                        for (var j = i + 1; j < this.children.length; j++)
                        {
                            var childInGroup = this.children[j];
                            if (childInGroup.attribute('x').hasValue())
                                break;
                            groupLength += childInGroup.measureText(ctx)
                        }
                        child.x -= (textAnchor == 'end' ? groupLength : groupLength / 2.0)
                    }
                    x = child.x + childLength;
                    if (child.attribute('y').hasValue())
                    {
                        child.y = child.attribute('y').Length.toPixels('y')
                    }
                    else
                    {
                        if (child.attribute('dy').hasValue())
                            y += child.attribute('dy').Length.toPixels('y');
                        child.y = y
                    }
                    y = child.y;
                    child.render(ctx)
                }
            }
        };
        svg.Element.text.prototype = new svg.Element.RenderedElementBase;
        svg.Element.TextElementBase = function(node)
        {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.getGlyph = function(font, text, i)
            {
                var c = text[i];
                var glyph = null;
                if (font.isArabic)
                {
                    var arabicForm = 'isolated';
                    if ((i == 0 || text[i - 1] == ' ') && i < text.length - 2 && text[i + 1] != ' ')
                        arabicForm = 'terminal';
                    if (i > 0 && text[i - 1] != ' ' && i < text.length - 2 && text[i + 1] != ' ')
                        arabicForm = 'medial';
                    if (i > 0 && text[i - 1] != ' ' && (i == text.length - 1 || text[i + 1] == ' '))
                        arabicForm = 'initial';
                    if (typeof(font.glyphs[c]) != 'undefined')
                    {
                        glyph = font.glyphs[c][arabicForm];
                        if (glyph == null && font.glyphs[c].type == 'glyph')
                            glyph = font.glyphs[c]
                    }
                }
                else
                {
                    glyph = font.glyphs[c]
                }
                if (glyph == null)
                    glyph = font.missingGlyph;
                return glyph
            };
            this.renderChildren = function(ctx)
            {
                var customFont = this.parent.style('font-family').Definition.getDefinition();
                if (customFont != null)
                {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var fontStyle = this.parent.style('font-style').valueOrDefault(svg.Font.Parse(svg.ctx.font).fontStyle);
                    var text = this.getText();
                    if (customFont.isRTL)
                        text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i = 0; i < text.length; i++)
                    {
                        var glyph = this.getGlyph(customFont, text, i);
                        var scale = fontSize / customFont.fontFace.unitsPerEm;
                        ctx.translate(this.x, this.y);
                        ctx.scale(scale, -scale);
                        var lw = ctx.lineWidth;
                        ctx.lineWidth = ctx.lineWidth * customFont.fontFace.unitsPerEm / fontSize;
                        if (fontStyle == 'italic')
                            ctx.transform(1, 0, .4, 1, 0, 0);
                        glyph.render(ctx);
                        if (fontStyle == 'italic')
                            ctx.transform(1, 0, -.4, 1, 0, 0);
                        ctx.lineWidth = lw;
                        ctx.scale(1 / scale, -1 / scale);
                        ctx.translate(-this.x, -this.y);
                        this.x += fontSize * (glyph.horizAdvX || customFont.horizAdvX) / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i]))
                        {
                            this.x += dx[i]
                        }
                    }
                    return
                }
                if (ctx.strokeStyle != '')
                    ctx.strokeText(svg.compressSpaces(this.getText()), this.x, this.y);
                if (ctx.fillStyle != '')
                    ctx.fillText(svg.compressSpaces(this.getText()), this.x, this.y)
            };
            this.getText = function(){};
            this.measureText = function(ctx)
            {
                var customFont = this.parent.style('font-family').Definition.getDefinition();
                if (customFont != null)
                {
                    var fontSize = this.parent.style('font-size').numValueOrDefault(svg.Font.Parse(svg.ctx.font).fontSize);
                    var measure = 0;
                    var text = this.getText();
                    if (customFont.isRTL)
                        text = text.split("").reverse().join("");
                    var dx = svg.ToNumberArray(this.parent.attribute('dx').value);
                    for (var i = 0; i < text.length; i++)
                    {
                        var glyph = this.getGlyph(customFont, text, i);
                        measure += (glyph.horizAdvX || customFont.horizAdvX) * fontSize / customFont.fontFace.unitsPerEm;
                        if (typeof(dx[i]) != 'undefined' && !isNaN(dx[i]))
                        {
                            measure += dx[i]
                        }
                    }
                    return measure
                }
                var textToMeasure = svg.compressSpaces(this.getText());
                if (!ctx.measureText)
                    return textToMeasure.length * 10;
                ctx.save();
                this.setContext(ctx);
                var width = ctx.measureText(textToMeasure).width;
                ctx.restore();
                return width
            }
        };
        svg.Element.TextElementBase.prototype = new svg.Element.RenderedElementBase;
        svg.Element.tspan = function(node)
        {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.text = node.nodeType == 3 ? node.nodeValue : node.childNodes.length > 0 ? node.childNodes[0].nodeValue : node.text;
            this.getText = function()
            {
                return this.text
            }
        };
        svg.Element.tspan.prototype = new svg.Element.TextElementBase;
        svg.Element.tref = function(node)
        {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.getText = function()
            {
                var element = this.attribute('xlink:href').Definition.getDefinition();
                if (element != null)
                    return element.children[0].getText()
            }
        };
        svg.Element.tref.prototype = new svg.Element.TextElementBase;
        svg.Element.a = function(node)
        {
            this.base = svg.Element.TextElementBase;
            this.base(node);
            this.hasText = true;
            for (var i = 0; i < node.childNodes.length; i++)
            {
                if (node.childNodes[i].nodeType != 3)
                    this.hasText = false
            }
            this.text = this.hasText ? node.childNodes[0].nodeValue : '';
            this.getText = function()
            {
                return this.text
            };
            this.baseRenderChildren = this.renderChildren;
            this.renderChildren = function(ctx)
            {
                if (this.hasText)
                {
                    this.baseRenderChildren(ctx);
                    var fontSize = new svg.Property('fontSize', svg.Font.Parse(svg.ctx.font).fontSize);
                    svg.Mouse.checkBoundingBox(this, new svg.BoundingBox(this.x, this.y - fontSize.Length.toPixels('y'), this.x + this.measureText(ctx), this.y))
                }
                else
                {
                    var g = new svg.Element.g;
                    g.children = this.children;
                    g.parent = this;
                    g.render(ctx)
                }
            };
            this.onclick = function()
            {
                window.open(this.attribute('xlink:href').value)
            };
            this.onmousemove = function()
            {
                svg.ctx.canvas.style.cursor = 'pointer'
            }
        };
        svg.Element.a.prototype = new svg.Element.TextElementBase;
        svg.Element.image = function(node)
        {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            svg.Images.push(this);
            this.img = document.createElement('img');
            this.loaded = false;
            var that = this;
            this.img.onload = function()
            {
                that.loaded = true
            };
            this.img.src = this.attribute('xlink:href').value;
            this.renderChildren = function(ctx)
            {
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                var width = this.attribute('width').Length.toPixels('x');
                var height = this.attribute('height').Length.toPixels('y');
                if (width == 0 || height == 0)
                    return;
                ctx.save();
                ctx.translate(x, y);
                svg.AspectRatio(ctx, this.attribute('preserveAspectRatio').value, width, this.img.width, height, this.img.height, 0, 0);
                ctx.drawImage(this.img, 0, 0);
                ctx.restore()
            }
        };
        svg.Element.image.prototype = new svg.Element.RenderedElementBase;
        svg.Element.g = function(node)
        {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.getBoundingBox = function()
            {
                var bb = new svg.BoundingBox;
                for (var i = 0; i < this.children.length; i++)
                {
                    bb.addBoundingBox(this.children[i].getBoundingBox())
                }
                return bb
            }
        };
        svg.Element.g.prototype = new svg.Element.RenderedElementBase;
        svg.Element.symbol = function(node)
        {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx)
            {
                this.baseSetContext(ctx);
                if (this.attribute('viewBox').hasValue())
                {
                    var viewBox = svg.ToNumberArray(this.attribute('viewBox').value);
                    var minX = viewBox[0];
                    var minY = viewBox[1];
                    width = viewBox[2];
                    height = viewBox[3];
                    svg.AspectRatio(ctx, this.attribute('preserveAspectRatio').value, this.attribute('width').Length.toPixels('x'), width, this.attribute('height').Length.toPixels('y'), height, minX, minY);
                    svg.ViewPort.SetCurrent(viewBox[2], viewBox[3])
                }
            }
        };
        svg.Element.symbol.prototype = new svg.Element.RenderedElementBase;
        svg.Element.style = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            var css = node.childNodes[0].nodeValue + (node.childNodes.length > 1 ? node.childNodes[1].nodeValue : '');
            css = css.replace(/(\/\*([^*]|[\r\n]|(\*+([^*\/]|[\r\n])))*\*+\/)|(^[\s]*\/\/.*)/gm, '');
            css = svg.compressSpaces(css);
            var cssDefs = css.split('}');
            for (var i = 0; i < cssDefs.length; i++)
            {
                if (svg.trim(cssDefs[i]) != '')
                {
                    var cssDef = cssDefs[i].split('{');
                    var cssClasses = cssDef[0].split(',');
                    var cssProps = cssDef[1].split(';');
                    for (var j = 0; j < cssClasses.length; j++)
                    {
                        var cssClass = svg.trim(cssClasses[j]);
                        if (cssClass != '')
                        {
                            var props = {};
                            for (var k = 0; k < cssProps.length; k++)
                            {
                                var prop = cssProps[k].indexOf(':');
                                var name = cssProps[k].substr(0, prop);
                                var value = cssProps[k].substr(prop + 1, cssProps[k].length - prop);
                                if (name != null && value != null)
                                {
                                    props[svg.trim(name)] = new svg.Property(svg.trim(name), svg.trim(value))
                                }
                            }
                            svg.Styles[cssClass] = props;
                            if (cssClass == '@font-face')
                            {
                                var fontFamily = props['font-family'].value.replace(/"/g, '');
                                var srcs = props['src'].value.split(',');
                                for (var s = 0; s < srcs.length; s++)
                                {
                                    if (srcs[s].indexOf('format("svg")') > 0)
                                    {
                                        var urlStart = srcs[s].indexOf('url');
                                        var urlEnd = srcs[s].indexOf(')', urlStart);
                                        var url = srcs[s].substr(urlStart + 5, urlEnd - urlStart - 6);
                                        var doc = svg.parseXml(svg.ajax(url));
                                        var fonts = doc.getElementsByTagName('font');
                                        for (var f = 0; f < fonts.length; f++)
                                        {
                                            var font = svg.CreateElement(fonts[f]);
                                            svg.Definitions[fontFamily] = font
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
        };
        svg.Element.style.prototype = new svg.Element.ElementBase;
        svg.Element.use = function(node)
        {
            this.base = svg.Element.RenderedElementBase;
            this.base(node);
            this.baseSetContext = this.setContext;
            this.setContext = function(ctx)
            {
                this.baseSetContext(ctx);
                if (this.attribute('x').hasValue())
                    ctx.translate(this.attribute('x').Length.toPixels('x'), 0);
                if (this.attribute('y').hasValue())
                    ctx.translate(0, this.attribute('y').Length.toPixels('y'))
            };
            this.getDefinition = function()
            {
                var element = this.attribute('xlink:href').Definition.getDefinition();
                if (this.attribute('width').hasValue())
                    element.attribute('width', true).value = this.attribute('width').value;
                if (this.attribute('height').hasValue())
                    element.attribute('height', true).value = this.attribute('height').value;
                return element
            };
            this.path = function(ctx)
            {
                var element = this.getDefinition();
                if (element != null)
                    element.path(ctx)
            };
            this.renderChildren = function(ctx)
            {
                var element = this.getDefinition();
                if (element != null)
                    element.render(ctx)
            }
        };
        svg.Element.use.prototype = new svg.Element.RenderedElementBase;
        svg.Element.mask = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, element)
            {
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                var width = this.attribute('width').Length.toPixels('x');
                var height = this.attribute('height').Length.toPixels('y');
                var mask = element.attribute('mask').value;
                element.attribute('mask').value = '';
                var cMask = document.createElement('canvas');
                cMask.width = x + width;
                cMask.height = y + height;
                var maskCtx = cMask.getContext('2d');
                this.renderChildren(maskCtx);
                var c = document.createElement('canvas');
                c.width = x + width;
                c.height = y + height;
                var tempCtx = c.getContext('2d');
                element.render(tempCtx);
                tempCtx.globalCompositeOperation = 'destination-in';
                tempCtx.fillStyle = maskCtx.createPattern(cMask, 'no-repeat');
                tempCtx.fillRect(0, 0, x + width, y + height);
                ctx.fillStyle = tempCtx.createPattern(c, 'no-repeat');
                ctx.fillRect(0, 0, x + width, y + height);
                element.attribute('mask').value = mask
            };
            this.render = function(ctx){}
        };
        svg.Element.mask.prototype = new svg.Element.ElementBase;
        svg.Element.clipPath = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx)
            {
                for (var i = 0; i < this.children.length; i++)
                {
                    if (this.children[i].path)
                    {
                        this.children[i].path(ctx);
                        ctx.clip()
                    }
                }
            };
            this.render = function(ctx){}
        };
        svg.Element.clipPath.prototype = new svg.Element.ElementBase;
        svg.Element.filter = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            this.apply = function(ctx, element)
            {
                var bb = element.getBoundingBox();
                var x = this.attribute('x').Length.toPixels('x');
                var y = this.attribute('y').Length.toPixels('y');
                if (x == 0 || y == 0)
                {
                    x = bb.x1;
                    y = bb.y1
                }
                var width = this.attribute('width').Length.toPixels('x');
                var height = this.attribute('height').Length.toPixels('y');
                if (width == 0 || height == 0)
                {
                    width = bb.width();
                    height = bb.height()
                }
                var filter = element.style('filter').value;
                element.style('filter').value = '';
                var extraPercent = .20;
                var px = extraPercent * width;
                var py = extraPercent * height;
                var c = document.createElement('canvas');
                c.width = width + 2 * px;
                c.height = height + 2 * py;
                var tempCtx = c.getContext('2d');
                tempCtx.translate(-x + px, -y + py);
                element.render(tempCtx);
                for (var i = 0; i < this.children.length; i++)
                {
                    this.children[i].apply(tempCtx, 0, 0, width + 2 * px, height + 2 * py)
                }
                ctx.drawImage(c, 0, 0, width + 2 * px, height + 2 * py, x - px, y - py, width + 2 * px, height + 2 * py);
                element.style('filter', true).value = filter
            };
            this.render = function(ctx){}
        };
        svg.Element.filter.prototype = new svg.Element.ElementBase;
        svg.Element.feGaussianBlur = function(node)
        {
            this.base = svg.Element.ElementBase;
            this.base(node);
            function make_fgauss(sigma)
            {
                sigma = Math.max(sigma, 0.01);
                var len = Math.ceil(sigma * 4.0) + 1;
                mask = [];
                for (var i = 0; i < len; i++)
                {
                    mask[i] = Math.exp(-0.5 * (i / sigma) * (i / sigma))
                }
                return mask
            }
            function normalize(mask)
            {
                var sum = 0;
                for (var i = 1; i < mask.length; i++)
                {
                    sum += Math.abs(mask[i])
                }
                sum = 2 * sum + Math.abs(mask[0]);
                for (var i = 0; i < mask.length; i++)
                {
                    mask[i] /= sum
                }
                return mask
            }
            function convolve_even(src, dst, mask, width, height)
            {
                for (var y = 0; y < height; y++)
                {
                    for (var x = 0; x < width; x++)
                    {
                        var a = imGet(src, x, y, width, height, 3) / 255;
                        for (var rgba = 0; rgba < 4; rgba++)
                        {
                            var sum = mask[0] * (a == 0 ? 255 : imGet(src, x, y, width, height, rgba)) * (a == 0 || rgba == 3 ? 1 : a);
                            for (var i = 1; i < mask.length; i++)
                            {
                                var a1 = imGet(src, Math.max(x - i, 0), y, width, height, 3) / 255;
                                var a2 = imGet(src, Math.min(x + i, width - 1), y, width, height, 3) / 255;
                                sum += mask[i] * ((a1 == 0 ? 255 : imGet(src, Math.max(x - i, 0), y, width, height, rgba)) * (a1 == 0 || rgba == 3 ? 1 : a1) + (a2 == 0 ? 255 : imGet(src, Math.min(x + i, width - 1), y, width, height, rgba)) * (a2 == 0 || rgba == 3 ? 1 : a2))
                            }
                            imSet(dst, y, x, height, width, rgba, sum)
                        }
                    }
                }
            }
            function imGet(img, x, y, width, height, rgba)
            {
                return img[y * width * 4 + x * 4 + rgba]
            }
            function imSet(img, x, y, width, height, rgba, val)
            {
                img[y * width * 4 + x * 4 + rgba] = val
            }
            function blur(ctx, width, height, sigma)
            {
                var srcData = ctx.getImageData(0, 0, width, height);
                var mask = make_fgauss(sigma);
                mask = normalize(mask);
                tmp = [];
                convolve_even(srcData.data, tmp, mask, width, height);
                convolve_even(tmp, srcData.data, mask, height, width);
                ctx.clearRect(0, 0, width, height);
                ctx.putImageData(srcData, 0, 0)
            }
            this.apply = function(ctx, x, y, width, height)
            {
                blur(ctx, width, height, this.attribute('stdDeviation').numValue())
            }
        };
        svg.Element.filter.prototype = new svg.Element.feGaussianBlur;
        svg.Element.title = function(node){};
        svg.Element.title.prototype = new svg.Element.ElementBase;
        svg.Element.desc = function(node){};
        svg.Element.desc.prototype = new svg.Element.ElementBase;
        svg.Element.MISSING = function(node)
        {
            console.log('ERROR: Element \'' + node.nodeName + '\' not yet implemented.')
        };
        svg.Element.MISSING.prototype = new svg.Element.ElementBase;
        svg.CreateElement = function(node)
        {
            var className = node.nodeName.replace(/^[^:]+:/, '');
            className = className.replace(/\-/g, '');
            var e = null;
            if (typeof(svg.Element[className]) != 'undefined')
            {
                e = new svg.Element[className](node)
            }
            else
            {
                e = new svg.Element.MISSING(node)
            }
            e.type = node.nodeName;
            return e
        };
        svg.load = function(ctx, url)
        {
            svg.loadXml(ctx, svg.ajax(url))
        };
        svg.loadXml = function(ctx, xml)
        {
            svg.loadXmlDoc(ctx, svg.parseXml(xml))
        };
        svg.loadXmlDoc = function(ctx, dom)
        {
            svg.init(ctx);
            var mapXY = function(p)
                {
                    var e = ctx.canvas;
                    while (e)
                    {
                        p.x -= e.offsetLeft;
                        p.y -= e.offsetTop;
                        e = e.offsetParent
                    }
                    if (window.scrollX)
                        p.x += window.scrollX;
                    if (window.scrollY)
                        p.y += window.scrollY;
                    return p
                };
            if (svg.opts['ignoreMouse'] != true)
            {
                ctx.canvas.onclick = function(e)
                {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onclick(p.x, p.y)
                };
                ctx.canvas.onmousemove = function(e)
                {
                    var p = mapXY(new svg.Point(e != null ? e.clientX : event.clientX, e != null ? e.clientY : event.clientY));
                    svg.Mouse.onmousemove(p.x, p.y)
                }
            }
            var e = svg.CreateElement(dom.documentElement);
            e.root = true;
            var isFirstRender = true;
            var draw = function()
                {
                    svg.ViewPort.Clear();
                    if (ctx.canvas.parentNode)
                        svg.ViewPort.SetCurrent(ctx.canvas.parentNode.clientWidth, ctx.canvas.parentNode.clientHeight);
                    if (svg.opts['ignoreDimensions'] != true)
                    {
                        if (e.style('width').hasValue())
                        {
                            ctx.canvas.width = e.style('width').Length.toPixels('x');
                            ctx.canvas.style.width = ctx.canvas.width + 'px'
                        }
                        if (e.style('height').hasValue())
                        {
                            ctx.canvas.height = e.style('height').Length.toPixels('y');
                            ctx.canvas.style.height = ctx.canvas.height + 'px'
                        }
                    }
                    var cWidth = ctx.canvas.clientWidth || ctx.canvas.width;
                    var cHeight = ctx.canvas.clientHeight || ctx.canvas.height;
                    svg.ViewPort.SetCurrent(cWidth, cHeight);
                    if (svg.opts != null && svg.opts['offsetX'] != null)
                        e.attribute('x', true).value = svg.opts['offsetX'];
                    if (svg.opts != null && svg.opts['offsetY'] != null)
                        e.attribute('y', true).value = svg.opts['offsetY'];
                    if (svg.opts != null && svg.opts['scaleWidth'] != null && svg.opts['scaleHeight'] != null)
                    {
                        var xRatio = 1,
                            yRatio = 1;
                        if (e.attribute('width').hasValue())
                            xRatio = e.attribute('width').Length.toPixels('x') / svg.opts['scaleWidth'];
                        if (e.attribute('height').hasValue())
                            yRatio = e.attribute('height').Length.toPixels('y') / svg.opts['scaleHeight'];
                        e.attribute('width', true).value = svg.opts['scaleWidth'];
                        e.attribute('height', true).value = svg.opts['scaleHeight'];
                        e.attribute('viewBox', true).value = '0 0 ' + (cWidth * xRatio) + ' ' + (cHeight * yRatio);
                        e.attribute('preserveAspectRatio', true).value = 'none'
                    }
                    if (svg.opts['ignoreClear'] != true)
                    {
                        ctx.clearRect(0, 0, cWidth, cHeight)
                    }
                    e.render(ctx);
                    if (isFirstRender)
                    {
                        isFirstRender = false;
                        if (svg.opts != null && typeof(svg.opts['renderCallback']) == 'function')
                            svg.opts['renderCallback']()
                    }
                };
            var waitingForImages = true;
            if (svg.ImagesLoaded())
            {
                waitingForImages = false;
                draw()
            }
            svg.intervalID = setInterval(function()
            {
                var needUpdate = false;
                if (waitingForImages && svg.ImagesLoaded())
                {
                    waitingForImages = false;
                    needUpdate = true
                }
                if (svg.opts['ignoreMouse'] != true)
                {
                    needUpdate = needUpdate | svg.Mouse.hasEvents()
                }
                if (svg.opts['ignoreAnimation'] != true)
                {
                    for (var i = 0; i < svg.Animations.length; i++)
                    {
                        needUpdate = needUpdate | svg.Animations[i].update(1000 / svg.FRAMERATE)
                    }
                }
                if (svg.opts != null && typeof(svg.opts['forceRedraw']) == 'function')
                {
                    if (svg.opts['forceRedraw']() == true)
                        needUpdate = true
                }
                if (needUpdate)
                {
                    draw();
                    svg.Mouse.runEvents()
                }
            }, 1000 / svg.FRAMERATE)
        };
        svg.stop = function()
        {
            if (svg.intervalID)
            {
                clearInterval(svg.intervalID)
            }
        };
        svg.Mouse = new(function()
        {
            this.events = [];
            this.hasEvents = function()
            {
                return this.events.length != 0
            };
            this.onclick = function(x, y)
            {
                this.events.push({
                    type: 'onclick', x: x, y: y, run: function(e)
                        {
                            if (e.onclick)
                                e.onclick()
                        }
                })
            };
            this.onmousemove = function(x, y)
            {
                this.events.push({
                    type: 'onmousemove', x: x, y: y, run: function(e)
                        {
                            if (e.onmousemove)
                                e.onmousemove()
                        }
                })
            };
            this.eventElements = [];
            this.checkPath = function(element, ctx)
            {
                for (var i = 0; i < this.events.length; i++)
                {
                    var e = this.events[i];
                    if (ctx.isPointInPath && ctx.isPointInPath(e.x, e.y))
                        this.eventElements[i] = element
                }
            };
            this.checkBoundingBox = function(element, bb)
            {
                for (var i = 0; i < this.events.length; i++)
                {
                    var e = this.events[i];
                    if (bb.isPointInBox(e.x, e.y))
                        this.eventElements[i] = element
                }
            };
            this.runEvents = function()
            {
                svg.ctx.canvas.style.cursor = '';
                for (var i = 0; i < this.events.length; i++)
                {
                    var e = this.events[i];
                    var element = this.eventElements[i];
                    while (element)
                    {
                        e.run(element);
                        element = element.parent
                    }
                }
                this.events = [];
                this.eventElements = []
            }
        });
        return svg
    }
})();
if (CanvasRenderingContext2D)
{
    CanvasRenderingContext2D.prototype.drawSvg = function(s, dx, dy, dw, dh)
    {
        canvg(this.canvas, s, {
            ignoreMouse: true, ignoreAnimation: true, ignoreDimensions: true, ignoreClear: true, offsetX: dx, offsetY: dy, scaleWidth: dw, scaleHeight: dh
        })
    }
}